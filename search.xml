<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>lua学习</title>
      <link href="/2020/07/16/lua%E5%AD%A6%E4%B9%A0/"/>
      <url>/2020/07/16/lua%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="lua"><a href="#lua" class="headerlink" title="lua"></a>lua</h1><h3 id="函数可变参数"><a href="#函数可变参数" class="headerlink" title="函数可变参数"></a>函数可变参数</h3><p>Lua 函数可以接受可变数目的参数，和 C 语言类似，在函数参数列表中<strong>使用三点 … 表示函数有可变的参数</strong>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function add(...)  </span><br><span class="line">  local s &#x3D; 0  </span><br><span class="line">  local arg &#x3D; &#123;...&#125;--&gt; arg 为一个表，局部变量</span><br><span class="line">  for i, v in ipairs(arg) do   --&gt; &#123;...&#125; 表示一个由所有变长参数构成的数组  </span><br><span class="line">    s &#x3D; s + v  </span><br><span class="line">  end  </span><br><span class="line">  return s  </span><br><span class="line">end  </span><br><span class="line">print(add(3,4,5,6,7))  ---&gt;25</span><br></pre></td></tr></table></figure><h2 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h2><h3 id="链接两个字符串"><a href="#链接两个字符串" class="headerlink" title="链接两个字符串    .."></a>链接两个字符串    ..</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(&quot;www.runoob.&quot;..&quot;com&quot;)</span><br><span class="line">&#x3D;&gt;  www.runoob.com</span><br></pre></td></tr></table></figure><h3 id="字符串替换-string-gsub"><a href="#字符串替换-string-gsub" class="headerlink" title="字符串替换 string.gsub"></a>字符串替换 string.gsub</h3><p><strong>string.gsub(mainString,findString,replaceString,num)</strong></p><p>在字符串中替换。mainString 为要操作的字符串， findString 为被替换的字符，replaceString 要替换的字符，num 替换次数（可以忽略，则全部替换），如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string.gsub(&quot;aaaa&quot;,&quot;a&quot;,&quot;z&quot;,3);</span><br><span class="line">&#x3D;&gt;  zzza    3(3为替换的次数)</span><br></pre></td></tr></table></figure><h3 id="截取字符串-string-sub"><a href="#截取字符串-string-sub" class="headerlink" title="截取字符串  string.sub"></a>截取字符串  string.sub</h3><p>string.sub() 用于截取字符串，原型为：<code>string.sub(s, i [, j])</code>  截取字符串s的从第i个字符到第j个字符之间的串,j默认为-1,最后一个</p><h3 id="字符串查找-string-find"><a href="#字符串查找-string-find" class="headerlink" title="字符串查找  string.find"></a>字符串查找  <strong>string.find</strong></h3><p><strong>string.find (str, substr, [init, [end]])</strong>   若存在，<strong>则返回2个值</strong>：匹配串开始索引和结束索引。若不存在，返回nil。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">local a, b &#x3D; string.find(&quot;Hello Lua user&quot;, &quot;Lua&quot;, 1)</span><br><span class="line">print(a, b)</span><br><span class="line">&#x3D;&gt; 7  9</span><br></pre></td></tr></table></figure><h3 id="字符串匹对-string-match"><a href="#字符串匹对-string-match" class="headerlink" title="字符串匹对  string.match"></a>字符串匹对  string.match</h3><p><strong>string.match(str, pattern, init)</strong></p><p>string.match()只寻找源字串str中的第一个配对. 参数init可选, 指定搜寻过程的起点, 默认为1。<br>在成功配对时, 函数将返回配对表达式中的所有捕获结果; 如果没有设置捕获标记, 则返回整个配对字符串. 当没有成功的配对时, 返回nil。</p><p>pattern没有指定captures,那么将返回整个匹配内容。<strong>capture是指pattern中用小括号括起来的内容</strong>。<strong>比如print(string.match(“hello world”, “h(ell)o wor”)),这将打印ell</strong>，如果没有这个小括号呢，比如print(string.match(“hello world”, “hello”)),这将打印hello.这就是与“hello”整个相匹配的内容都返回了。</p><p><strong>pattern 要了解lua的正则表达式</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">local str &#x3D; &quot;ACK(22,33,55)&quot;</span><br><span class="line">local res &#x3D; string.match(str, &quot;ACK%((.-)%)$&quot;)  --&gt;  22,33,55</span><br><span class="line">local n1, n2, n3 &#x3D; string.match(s, &quot;(%d+),(%d+),(%d+),&quot;)  --&gt;  22   33  55</span><br></pre></td></tr></table></figure><h2 id="Lua的正则表达式"><a href="#Lua的正则表达式" class="headerlink" title="Lua的正则表达式"></a>Lua的正则表达式</h2><p>​    网页跳转到：    <a href="https://blog.csdn.net/xiejunna/article/details/52161097" target="_blank" rel="noopener">Lua的正则表达式</a>    查看详细</p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/lanning5/blogCDN/img/md%E6%88%AA%E5%9B%BE/lua/lua%E6%AD%A3%E5%88%99.png" alt="正则表达式"></p>]]></content>
      
      
      <categories>
          
          <category> lua </category>
          
      </categories>
      
      
        <tags>
            
            <tag> lua </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++学习</title>
      <link href="/2020/07/16/C-%E5%AD%A6%E4%B9%A0/"/>
      <url>/2020/07/16/C-%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="枚举："><a href="#枚举：" class="headerlink" title="枚举："></a>枚举：</h3><p>枚举类型(enumeration)是C++中的一种派生数据类型，它是由用户定义的若干枚举常量的集合。</p><p>如果一个变量只有几种可能的值，可以定义为枚举(enumeration)类型。所谓”枚举”是指将变量的值一一列举出来，变量的值只能在列举出来的值的范围内。</p><h4 id="一般形式"><a href="#一般形式" class="headerlink" title="一般形式"></a>一般形式</h4><p>创建枚举，需要使用关键字 <strong>enum</strong>。枚举类型的一般形式为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">enum 枚举名&#123; </span><br><span class="line">     标识符[&#x3D;整型常数], </span><br><span class="line">     标识符[&#x3D;整型常数], </span><br><span class="line">... </span><br><span class="line">    标识符[&#x3D;整型常数]</span><br><span class="line">&#125; 枚举变量;</span><br></pre></td></tr></table></figure><p>如果枚举没有初始化, 即<strong>省掉”=整型常数”</strong>时, 则从第一个标识符开始。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">例如：</span><br><span class="line">enum color &#123; red, green, blue &#125; c;</span><br><span class="line">c &#x3D; blue;</span><br></pre></td></tr></table></figure><h4 id="枚举类型与基础类型的转换"><a href="#枚举类型与基础类型的转换" class="headerlink" title="枚举类型与基础类型的转换"></a><strong>枚举类型与基础类型的转换</strong></h4><p><strong>基础类型不能隐式转换为枚举类型； 枚举类型也不能隐式转换为基础类型。</strong></p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/lanning5/blogCDN/img/md%E6%88%AA%E5%9B%BE/C++/%E6%9E%9A%E4%B8%BE%E4%B8%8E%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2.png" alt="枚举类型与基础类型的转换"></p><h3 id="存储类"><a href="#存储类" class="headerlink" title="存储类"></a>存储类</h3><p>存储类定义 C++ 程序中变量/函数的范围（可见性）和生命周期。这些说明符放置在它们所修饰的类型之前。下面列出 C++ 程序中可用的存储类：</p><ul><li>auto</li><li>register</li><li>static</li><li>extern</li><li>mutable</li><li>thread_local (C++11)</li></ul><p>从 C++ 17 开始，auto 关键字不再是 C++ 存储类说明符，且 register 关键字被弃用。</p><h4 id="static-存储类"><a href="#static-存储类" class="headerlink" title="static 存储类"></a>static 存储类</h4><p><strong>static</strong> 存储类指示编译器在程序的生命周期内保持局部变量的存在，而不需要在每次它进入和离开作用域时进行创建和销毁。因此，<strong>使用 static 修饰局部变量可以在函数调用之间保持局部变量的值</strong>。</p><p>static 修饰符也可以应用于全局变量。当 static 修饰全局变量时，会使变量的作用域限制在声明它的文件内。</p><p>在 C++ 中，当 static 用在类数据成员上时，会导致仅有一个该成员的副本被类的所有对象共享。</p><center>实例：</center><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt; </span><br><span class="line">&#x2F;&#x2F; 函数声明 </span><br><span class="line">void func(void);</span><br><span class="line"> </span><br><span class="line">static int count &#x3D; 10; &#x2F;* 全局变量 *&#x2F;</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    while(count--)</span><br><span class="line">    &#123;</span><br><span class="line">       func();</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 函数定义</span><br><span class="line">void func( void )</span><br><span class="line">&#123;</span><br><span class="line">    static int i &#x3D; 5; &#x2F;&#x2F; 局部静态变量</span><br><span class="line">    i++;</span><br><span class="line">    std::cout &lt;&lt; &quot;变量 i 为 &quot; &lt;&lt; i ;</span><br><span class="line">    std::cout &lt;&lt; &quot; , 变量 count 为 &quot; &lt;&lt; count &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><center>结果</center><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">变量 i 为 6 , 变量 count 为 9</span><br><span class="line">变量 i 为 7 , 变量 count 为 8</span><br><span class="line">变量 i 为 8 , 变量 count 为 7</span><br><span class="line">变量 i 为 9 , 变量 count 为 6</span><br><span class="line">变量 i 为 10 , 变量 count 为 5</span><br><span class="line">变量 i 为 11 , 变量 count 为 4</span><br><span class="line">变量 i 为 12 , 变量 count 为 3</span><br><span class="line">变量 i 为 13 , 变量 count 为 2</span><br><span class="line">变量 i 为 14 , 变量 count 为 1</span><br><span class="line">变量 i 为 15 , 变量 count 为 0</span><br></pre></td></tr></table></figure><h4 id="extern-存储类"><a href="#extern-存储类" class="headerlink" title="extern 存储类"></a>extern 存储类</h4><p><strong>extern</strong> 存储类用于提供一个全局变量的引用，全局变量对所有的程序文件都是可见的。当您使用 ‘extern’ 时，对于无法初始化的变量，会把变量名指向一个之前定义过的存储位置。</p><p>当您有多个文件且定义了一个可以在其他文件中使用的全局变量或函数时，可以在其他文件中使用 <em>extern</em> 来得到已定义的变量或函数的引用。可以这么理解，<strong><em>extern</em> 是用来在另一个文件中声明一个全局变量或函数</strong>。</p><p>extern 修饰符通常用于当有两个或多个文件共享相同的全局变量或函数的时候，如下所示：</p><center>第一个文件：main.cpp</center><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int count ;</span><br><span class="line">extern void write_extern();</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">   count &#x3D; 5;</span><br><span class="line">   write_extern();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><center>第二个文件：support.cpp</center><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">extern int count;</span><br><span class="line"> </span><br><span class="line">void write_extern(void)</span><br><span class="line">&#123;</span><br><span class="line">   std::cout &lt;&lt; &quot;Count is &quot; &lt;&lt; count &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h3><p>位运算符作用于位，并逐位执行操作。</p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/lanning5/blogCDN/img/md%E6%88%AA%E5%9B%BE/C++/%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6.png" alt="位运算符"></p><h3 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h3><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/lanning5/blogCDN/img/md%E6%88%AA%E5%9B%BE/C++/%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7.png" alt="位运算符"></p>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vs常用快捷键</title>
      <link href="/2020/07/15/vs%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
      <url>/2020/07/15/vs%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="vs"><a href="#vs" class="headerlink" title="vs"></a>vs</h1><h2 id="在vs中设置或查看快捷键"><a href="#在vs中设置或查看快捷键" class="headerlink" title="在vs中设置或查看快捷键"></a>在vs中设置或查看快捷键</h2><p>在工具栏    <font color=red>工具 =&gt; 选项 =&gt; 环境 =&gt; 键盘  </font>  中查看或修改快捷键</p><h2 id="常用快捷键"><a href="#常用快捷键" class="headerlink" title="常用快捷键"></a>常用快捷键</h2><p>智能提示：ctrl + J<br>CTRL + SHIFT + B 生成解决方案<br>F4 显示属性窗口<br>F5 运行调试<br>F10 跨过程序执行<br>F11 单步逐句执行<br>F7: 查看代码<br>Shift+F7: 查看窗体设计器<br>Ctrl+F: 查找<br>F3: 查找下一个<br>Ctrl+H: 替换<br>Ctrl+F5: 开始执行(不调试)<br>F9: 切换断点<br>Ctrl+Shift+F9: 删除全部断点<br>Ctrl+Shift+F: 在文件中查找<br>Ctrl+K,S: 插入外侧代码</p><p><font color=red>代码格式化：ctrl+E+F</font></p><p><font color=red>删除当前行      Ctrl+Shift+L</font>  </p><p><font color=red>注释    Ctrl + K + C    取消注释 Ctrl + K + U</font>  </p><p><font color=red>折叠代码  </font>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Ctrl + M + O: 折叠所有方法</span><br><span class="line"></span><br><span class="line">Ctrl + M + M: 折叠或者展开当前方法</span><br><span class="line"></span><br><span class="line">Ctrl + M + S: 折叠当前区域</span><br><span class="line"></span><br><span class="line">Ctrl + M + L: 展开所有方法</span><br></pre></td></tr></table></figure><p><font color=red>代码排版 ：</font>  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">格式化cs(选中)代码：Ctrl+k+f</span><br><span class="line"></span><br><span class="line">格式化aspx(文档)代码：Ctrl+k+d</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> vs </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>halcon基础学习</title>
      <link href="/2020/07/14/halcon%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
      <url>/2020/07/14/halcon%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="halcon"><a href="#halcon" class="headerlink" title="halcon"></a>halcon</h1><h2 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">控制变量</span><br><span class="line">arr :&#x3D; [1, 2, 3, 4, 5] &#x2F;&#x2F;数组</span><br><span class="line">num :&#x3D; |arr|&#x2F;&#x2F;num&#x3D;5 求模（注意：不是求绝对值）</span><br><span class="line">SingerElenment :&#x3D; arr[3]  &#x2F;&#x2F;SingerElenment&#x3D;4，取数组下标为3的值</span><br><span class="line">Part :&#x3D; arr[1:3] &#x2F;&#x2F;Part&#x3D;[2,3,4] 取下标从1到3的值</span><br><span class="line">Copy :&#x3D; arr[0: |arr|-1]&#x2F;&#x2F;Copy&#x3D;arr, 相当于复杂arr</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">简单的示例</span><br><span class="line">read_image(Image, &#39;filePath&#39;)&#x2F;&#x2F;读取图形， 第二个参数为图片的地址(路径)</span><br><span class="line">regiongrowing(Image, Regions, 3, 3, 6, 100)&#x2F;&#x2F;图像分割，区域增长，把整个图像分成各个区域</span><br><span class="line">count_obj(Regions, Number)&#x2F;&#x2F;统计区域的个数， 第二个参数为变量</span><br><span class="line">open_file(&#39;fileName&#39;, &#39;output&#39;, FileHandle)&#x2F;&#x2F;FileHandle 文件句柄</span><br><span class="line">for i :&#x3D; 1 to Number by 1</span><br><span class="line">select_obj (Regions, Selected, i)</span><br><span class="line">area_center (Selected, Area, Row, Column)</span><br><span class="line">fwrite_string (FileHandle, i + &#39; &#39; + Area)</span><br><span class="line">fnew_line(FileHandle)</span><br><span class="line">endfor</span><br><span class="line">close_file(FileHandle)</span><br></pre></td></tr></table></figure><h2 id="算子"><a href="#算子" class="headerlink" title="算子"></a>算子</h2><p>read_image：</p>]]></content>
      
      
      <categories>
          
          <category> 视觉 </category>
          
          <category> halcon </category>
          
      </categories>
      
      
        <tags>
            
            <tag> halcon </tag>
            
            <tag> 视觉 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实习学习01</title>
      <link href="/2020/07/14/%E5%AE%9E%E4%B9%A0%E5%AD%A6%E4%B9%A001/"/>
      <url>/2020/07/14/%E5%AE%9E%E4%B9%A0%E5%AD%A6%E4%B9%A001/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 视觉 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 视觉 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>markdown的一些语法</title>
      <link href="/2020/07/10/markdown%E7%9A%84%E4%B8%80%E4%BA%9B%E8%AF%AD%E6%B3%95/"/>
      <url>/2020/07/10/markdown%E7%9A%84%E4%B8%80%E4%BA%9B%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="markdown"><a href="#markdown" class="headerlink" title="markdown"></a>markdown</h1><p>Markdown是一种可以使用普通文本编辑器编写的<a href="https://baike.baidu.com/item/标记语言/5964436" target="_blank" rel="noopener"><strong>标记语言</strong></a>，通过简单的标记语法，它可以使普通文本内容具有一定的格式。blog文章的编写就需要掌握一些markdown的语法。</p><p>推荐使用的md编辑器：<a href="https://www.typora.io/" target="_blank" rel="noopener"><strong>typora</strong></a></p><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><h3 id="入门语法"><a href="#入门语法" class="headerlink" title="入门语法"></a>入门语法</h3><p><strong>标题</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 一级标题</span><br><span class="line">## 二级标题</span><br></pre></td></tr></table></figure><p><strong>加粗斜体</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">** 加粗的字体 **</span><br></pre></td></tr></table></figure><p><strong>分割线</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一行，连续输入三个星号 ***</span><br></pre></td></tr></table></figure><p><strong>表格插入</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">书籍名称|书籍编号|学时</span><br><span class="line">---|---|---</span><br><span class="line">计算机网络|002|48</span><br></pre></td></tr></table></figure><p><strong>引用</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;  引用文字</span><br></pre></td></tr></table></figure><p>这些都是很基本的入门语法，还有许多为列出，但是使用 <strong>typora</strong> 等编辑器这些基本语法都无需记牢，编辑器里功能都有，可以快速通过快捷键来写出格式，但是其它的一些格式编写编辑器里不提供，要自己掌握它们的语法去编写，例如居中，文字大小颜色等。</p><h2 id="常用语法"><a href="#常用语法" class="headerlink" title="常用语法"></a>常用语法</h2><h3 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h3><h4 id="颜色"><a href="#颜色" class="headerlink" title="颜色"></a>颜色</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">浅红色文字：&lt;font color&#x3D;&quot;#dd0000&quot;&gt;浅红色文字：&lt;&#x2F;font&gt;</span><br></pre></td></tr></table></figure><p><strong>效果</strong>：<img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/lanning5/blogCDN/img/md%E6%88%AA%E5%9B%BE/md%E8%AF%AD%E6%B3%95/fontcolor.png" alt="浅红色文字效果"></p><h4 id="字体大小"><a href="#字体大小" class="headerlink" title="字体大小"></a>字体大小</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">size为1：&lt;font size&#x3D;&quot;1&quot;&gt;size为1&lt;&#x2F;font&gt;</span><br></pre></td></tr></table></figure><p><strong>size 为1~7， 浏览器默认为3</strong></p><h4 id="标准字体"><a href="#标准字体" class="headerlink" title="标准字体"></a>标准字体</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;font face&#x3D;&quot;黑体&quot;&gt;我是黑体字&lt;&#x2F;font&gt;</span><br><span class="line"></span><br><span class="line">&lt;font face&#x3D;&quot;微软雅黑&quot;&gt;我是微软雅黑&lt;&#x2F;font&gt;</span><br><span class="line"></span><br><span class="line">&lt;font face&#x3D;&quot;STCAIYUN&quot;&gt;我是华文彩云</span><br></pre></td></tr></table></figure><h3 id="背景色"><a href="#背景色" class="headerlink" title="背景色"></a>背景色</h3><p><strong>bgcolor=颜色</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;table&gt;&lt;tr&gt;&lt;td bgcolor&#x3D;#FF00FF&gt;背景色的设置是按照十六进制颜色值：#7FFFD4&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;table&gt;</span><br></pre></td></tr></table></figure><p>效果：<img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/lanning5/blogCDN/img/md%E6%88%AA%E5%9B%BE/md%E8%AF%AD%E6%B3%95/bgcolor.png" alt="背景色展示"></p><h3 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h3><p><strong>基本形式</strong>是：<code>![]()</code> <code>![这里放图片描述](这里放图片链接)</code> 例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![背景色展示](https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;lanning5&#x2F;blogCDN&#x2F;img&#x2F;md截图&#x2F;md语法&#x2F;bgcolor.png)</span><br></pre></td></tr></table></figure><p>也可以用类 <strong>html5</strong>  标签语法格式</p><p><strong>定义尺寸</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img width &#x3D; &#39;550&#39; height &#x3D;&#39;50&#39; src &#x3D;&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;lanning5&#x2F;blogCDN&#x2F;img&#x2F;md截图&#x2F;md语法&#x2F;bgcolor.png&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure><h3 id="对齐方式"><a href="#对齐方式" class="headerlink" title="对齐方式"></a>对齐方式</h3><h4 id="居中"><a href="#居中" class="headerlink" title="居中"></a>居中</h4><h5 id="文字居中："><a href="#文字居中：" class="headerlink" title="文字居中："></a>文字居中：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;center&gt;诶嘿&lt;&#x2F;center&gt;</span><br></pre></td></tr></table></figure><h5 id="图片等居中"><a href="#图片等居中" class="headerlink" title="图片等居中"></a>图片等居中</h5><p><strong>align = center</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;div align&#x3D;center&gt;  &lt;img width &#x3D; &#39;550&#39; height &#x3D;&#39;50&#39; src &#x3D;&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;lanning5&#x2F;blogCDN&#x2F;img&#x2F;md截图&#x2F;md语法&#x2F;bgcolor.png&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><h4 id="左右对齐"><a href="#左右对齐" class="headerlink" title="左右对齐"></a>左右对齐</h4><p><strong>align = left</strong></p><h3 id="换行"><a href="#换行" class="headerlink" title="换行"></a>换行</h3><p><strong>连续两个以上空格+回车</strong>  or <code>&lt;br/&gt;</code></p><h3 id="特殊符号"><a href="#特殊符号" class="headerlink" title="特殊符号"></a>特殊符号</h3><p>利用 <strong>转义字符\</strong> 可输出符号本身 <code>\* 输出*字符</code></p><h4 id="其它特殊字符"><a href="#其它特殊字符" class="headerlink" title="其它特殊字符"></a>其它特殊字符</h4><p>使用 <strong>Unicode码</strong>  示例如下：</p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/lanning5/blogCDN/img/md%E6%88%AA%E5%9B%BE/md%E8%AF%AD%E6%B3%95/%E7%89%B9%E6%AE%8A%E5%AD%97%E7%AC%A6.png" alt="特殊字符"></p><p>字符对应的Unicode码，可以看这个网站：<a href="https://unicode-table.com/cn/" target="_blank" rel="noopener">https://unicode-table.com/cn/</a></p><h3 id="锚点"><a href="#锚点" class="headerlink" title="锚点"></a>锚点</h3><p>在预定的跳转到的位置添加 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">## 目录&#123;#index&#125;</span><br><span class="line">跳转到[目录](</span><br></pre></td></tr></table></figure><p> 然后在文档的其它地方写上连接到锚点的链接。</p><h2 id="高级用法"><a href="#高级用法" class="headerlink" title="高级用法"></a>高级用法</h2><h3 id="Todo-列表"><a href="#Todo-列表" class="headerlink" title="Todo 列表"></a>Todo 列表</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-[] 已处理的事情</span><br><span class="line"></span><br><span class="line">-[x] 未处理的事情</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/lanning5/blogCDN/img/md%E6%88%AA%E5%9B%BE/md%E8%AF%AD%E6%B3%95/todo.png" alt="Todo 列表展示"></p><h3 id="流程图-数学公式-序列图"><a href="#流程图-数学公式-序列图" class="headerlink" title="流程图 数学公式 序列图"></a>流程图 数学公式 序列图</h3><p>请参考CSDN 的一篇文章： <a href="https://blog.csdn.net/u014061630/article/details/81359144?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-9.nonecase&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-9.nonecase#4%E9%94%9A%E7%82%B9" target="_blank" rel="noopener">跳转</a></p>]]></content>
      
      
      <categories>
          
          <category> markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何用hexo建立自己的blog并部署到github中</title>
      <link href="/2020/07/07/%E5%A6%82%E4%BD%95%E7%94%A8hexo%E5%BB%BA%E7%AB%8B%E8%87%AA%E5%B7%B1%E7%9A%84blog%E5%B9%B6%E9%83%A8%E7%BD%B2%E5%88%B0github%E4%B8%AD/"/>
      <url>/2020/07/07/%E5%A6%82%E4%BD%95%E7%94%A8hexo%E5%BB%BA%E7%AB%8B%E8%87%AA%E5%B7%B1%E7%9A%84blog%E5%B9%B6%E9%83%A8%E7%BD%B2%E5%88%B0github%E4%B8%AD/</url>
      
        <content type="html"><![CDATA[<h1 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h1><p>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 <a href="http://daringfireball.net/projects/markdown/" target="_blank" rel="noopener">Markdown</a>（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p><p>hexo的网站：<a href="https://hexo.io/zh-cn" target="_blank" rel="noopener">hexo</a></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h3><ul><li><a href="http://nodejs.org/" target="_blank" rel="noopener">Node.js</a> (Node.js 版本需不低于 8.10，建议使用 Node.js 10.0 及以上版本)</li><li><a href="http://git-scm.com/" target="_blank" rel="noopener">Git</a></li></ul><h3 id="安装-Hexo"><a href="#安装-Hexo" class="headerlink" title="安装 Hexo"></a>安装 Hexo</h3><p>全局安装：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g hexo-cli</span><br></pre></td></tr></table></figure><h2 id="建站"><a href="#建站" class="headerlink" title="建站"></a>建站</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#&#x2F;&#x2F; &lt;folder&gt;是你的文件名  如 hexo init blog</span><br><span class="line">$ hexo init &lt;folder&gt;</span><br><span class="line">$ cd &lt;folder&gt;</span><br><span class="line">$ npm install</span><br></pre></td></tr></table></figure><p>建好后，可以运行<code>$ hexo server</code>查看你的本地博客</p><h2 id="部署到github中"><a href="#部署到github中" class="headerlink" title="部署到github中"></a>部署到github中</h2><ol><li><p>安装 <a href="https://github.com/hexojs/hexo-deployer-git" target="_blank" rel="noopener">hexo-deployer-git</a>.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i --save hexo-deployer-git</span><br></pre></td></tr></table></figure></li><li><p>在github创建一个新的repository，命名为<code>&lt;username&gt;.github.io</code></p></li><li><p>在 <strong>_config.yml</strong>（如果有已存在的请删除）添加如下配置：</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: https:&#x2F;&#x2F;github.com&#x2F;&lt;username&gt;&#x2F;&lt;project&gt;</span><br><span class="line">  #repo是github创建的地址 example, https:&#x2F;&#x2F;github.com&#x2F;hexojs&#x2F;hexojs.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><ol start="4"><li>运行<code>hexo g</code> and <code>hexo deploy</code>推送到github仓库</li></ol><h1 id="hexo-的指令"><a href="#hexo-的指令" class="headerlink" title="hexo 的指令"></a>hexo 的指令</h1><h2 id="官网网址"><a href="#官网网址" class="headerlink" title="官网网址"></a>官网网址</h2><p>hexo指令官网的网址： <a href="https://hexo.io/zh-cn/docs/commands" target="_blank" rel="noopener">网址</a></p><h2 id="常用的指令"><a href="#常用的指令" class="headerlink" title="常用的指令"></a>常用的指令</h2><h3 id="new"><a href="#new" class="headerlink" title="new"></a>new</h3><p>new指令是用来<strong>新建一篇文章</strong>，格式<code>hexo new [layout] &lt;title&gt;</code>  ，例如我要在blog新发布一篇文章，就可以</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new &quot;新建文章名&quot;</span><br></pre></td></tr></table></figure><p>这样，可以在source/_posts/ 文件夹中找到这个文件，直接编写即可。</p><p>要<strong>建立独立的页面</strong>，格式为<code>hexo new page &lt;title&gt;</code>或者<code>hexo new page --path &lt;path&gt; &lt;title&gt;</code> , 例如我要在blog 建立一个图片集页面，就可以 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new page photo</span><br></pre></td></tr></table></figure><p>我的photo页面下有壁纸子页面，壁纸的地址为photo/wallpaper/，则可以</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new page --path photo&#x2F;wallpaper&#x2F;index.md &quot;壁纸&quot;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> butterfly </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redux and react-redux</title>
      <link href="/2020/07/05/redux/"/>
      <url>/2020/07/05/redux/</url>
      
        <content type="html"><![CDATA[<h1 id="redux"><a href="#redux" class="headerlink" title="redux"></a>redux</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>React有props和state:</p><ol><li>props意味着父级分发下来的属性</li><li>state意味着组件内部可以自行管理的状态，并且整个React没有数据向上回溯的能力，这就是react的单向数据流</li></ol><p>这就意味着如果是一个数据状态非常复杂的应用，更多的时候发现<strong>React根本无法让两个组件互相交流</strong>，使用对方的数据，react的通过层级传递数据的这种方法是非常难受的，这个时候，迫切需要一个机制，<strong>把所有的state集中到组件顶部，能够灵活的将所有state各取所需的分发给所有的组件</strong>，是的，这就是redux</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ol><li>redux是的诞生是为了给 React 应用提供「可预测化的状态管理」机制。</li><li>Redux会将整个应用状态(其实也就是数据)存储到到一个地方，称为store</li><li>这个store里面保存一棵状态树(state tree)</li><li>组件改变state的唯一方法是通过调用store的dispatch方法，触发一个action，这个action被对应的reducer处理，于是state完成更新</li><li>组件可以派发(dispatch)行为(action)给store,而不是直接通知其它组件</li><li>其它组件可以通过订阅store中的状态(state)来刷新自己的视图</li></ol><h2 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h2><ol><li>创建reducer<ul><li>可以使用单独的一个reducer,也可以将多个reducer合并为一个reducer，即：<code>combineReducers()</code></li><li>action发出命令后将state放入reucer加工函数中，返回新的state,对state进行加工处理</li></ul></li><li>创建action<ul><li>用户是接触不到state的，只能有view触发，所以，这个action可以理解为指令，需要发出多少动作就有多少指令</li><li>action是一个对象，必须有一个叫type的参数，定义action类型</li></ul></li><li>创建的store，使用createStore方法<ul><li>store 可以理解为有多个加工机器的总工厂</li><li>提供subscribe，dispatch，getState这些方法。</li></ul></li></ol><h2 id="按步骤手把手实战。"><a href="#按步骤手把手实战。" class="headerlink" title="按步骤手把手实战。"></a>按步骤手把手实战。</h2><p>上述步骤，对应的序号，我会在相关代码标出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">npm install redux -S &#x2F;&#x2F; 安装</span><br><span class="line"></span><br><span class="line">import &#123; createStore &#125; from &#39;redux&#39; &#x2F;&#x2F; 引入</span><br><span class="line"></span><br><span class="line">const reducer &#x3D; (state &#x3D; &#123;count: 0&#125;, action) &#x3D;&gt; &#123;----------&gt; ⑴</span><br><span class="line">  switch (action.type)&#123;</span><br><span class="line">    case &#39;INCREASE&#39;: return &#123;count: state.count + 1&#125;;</span><br><span class="line">    case &#39;DECREASE&#39;: return &#123;count: state.count - 1&#125;;</span><br><span class="line">    default: return state;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const actions &#x3D; &#123;----------&gt;⑵</span><br><span class="line">  increase: () &#x3D;&gt; (&#123;type: &#39;INCREASE&#39;&#125;),</span><br><span class="line">  decrease: () &#x3D;&gt; (&#123;type: &#39;DECREASE&#39;&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const store &#x3D; createStore(reducer);----------&gt;⑶</span><br><span class="line"></span><br><span class="line">store.subscribe(() &#x3D;&gt;</span><br><span class="line">  console.log(store.getState())</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">store.dispatch(actions.increase()) &#x2F;&#x2F; &#123;count: 1&#125;</span><br><span class="line">store.dispatch(actions.increase()) &#x2F;&#x2F; &#123;count: 2&#125;</span><br><span class="line">store.dispatch(actions.increase()) &#x2F;&#x2F; &#123;count: 3&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>自己画了一张非常简陋的流程图，方便理解redux的工作流程</p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/lanning5/blogCDN/img/20200709000020.png" alt="img"></p><h1 id="react-redux"><a href="#react-redux" class="headerlink" title="react-redux"></a>react-redux</h1><p>刚开始就说了，如果把store直接集成到React应用的顶层props里面，只要各个子组件能访问到顶层props就行了，比如这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;顶层组件 store&#x3D;&#123;store&#125;&gt;</span><br><span class="line">  &lt;App &#x2F;&gt;</span><br><span class="line">&lt;&#x2F;顶层组件&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>不就ok了吗？这就是 react-redux。Redux 官方提供的 React 绑定库。 具有高效且灵活的特性。</p><h2 id="React-Redux-将组件区分为-容器组件-和-UI-组件"><a href="#React-Redux-将组件区分为-容器组件-和-UI-组件" class="headerlink" title="React Redux 将组件区分为 容器组件 和 UI 组件"></a><strong>React Redux 将组件区分为 容器组件 和 UI 组件</strong></h2><ol><li>前者会处理逻辑</li><li>后者只负责显示和交互，内部不处理逻辑，状态完全由外部掌控</li></ol><h2 id="两个核心"><a href="#两个核心" class="headerlink" title="两个核心"></a>两个核心</h2><h3 id="Provider"><a href="#Provider" class="headerlink" title="Provider"></a>Provider</h3><p>看我上边那个代码的<strong>顶层组件</strong>4个字。对，你没有猜错。这个顶级组件就是Provider,一般我们都将顶层组件包裹在Provider组件之中，这样的话，所有组件就都可以在react-redux的控制之下了,<strong>但是store必须作为参数放到Provider组件中去</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;Provider store &#x3D; &#123;store&#125;&gt;</span><br><span class="line">    &lt;App &#x2F;&gt;</span><br><span class="line">&lt;Provider&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">这个组件的目的是让所有组件都能够访问到Redux中的数据。 </span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="connect"><a href="#connect" class="headerlink" title="connect"></a>connect</h3><p>这个才是react-redux中比较难的部分，我们详细解释一下</p><p>首先，先记住下边的这行代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">connect(mapStateToProps, mapDispatchToProps)(MyComponent)</span><br></pre></td></tr></table></figure><h4 id="mapStateToProps"><a href="#mapStateToProps" class="headerlink" title="mapStateToProps"></a>mapStateToProps</h4><p>这个单词翻译过来就是<strong>把state映射到props中去</strong> ,其实也就是<strong>把Redux中的数据映射到React中的props中去。</strong></p><p>举个栗子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    const mapStateToProps &#x3D; (state) &#x3D;&gt; &#123;</span><br><span class="line">      return &#123;</span><br><span class="line">      &#x2F;&#x2F; prop : state.xxx  | 意思是将state中的某个数据映射到props中</span><br><span class="line">        foo: state.bar</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>然后渲染的时候就可以使用this.props.foo</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Foo extends Component &#123;</span><br><span class="line">    constructor(props)&#123;</span><br><span class="line">        super(props);</span><br><span class="line">    &#125;</span><br><span class="line">    render()&#123;</span><br><span class="line">        return(</span><br><span class="line">        &#x2F;&#x2F; 这样子渲染的其实就是state.bar的数据了</span><br><span class="line">            &lt;div&gt;this.props.foo&lt;&#x2F;div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Foo &#x3D; connect()(Foo);</span><br><span class="line">export default Foo;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>然后这样就可以完成渲染了</p><h4 id="mapDispatchToProps"><a href="#mapDispatchToProps" class="headerlink" title="mapDispatchToProps"></a>mapDispatchToProps</h4><p>这个单词翻译过来就是就是<strong>把各种dispatch也变成了props让你可以直接使用</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">const mapDispatchToProps &#x3D; (dispatch) &#x3D;&gt; &#123; &#x2F;&#x2F; 默认传递参数就是dispatch</span><br><span class="line">  return &#123;</span><br><span class="line">    onClick: () &#x3D;&gt; &#123;</span><br><span class="line">      dispatch(&#123;</span><br><span class="line">        type: &#39;increatment&#39;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br><span class="line">class Foo extends Component &#123;</span><br><span class="line">    constructor(props)&#123;</span><br><span class="line">        super(props);</span><br><span class="line">    &#125;</span><br><span class="line">    render()&#123;</span><br><span class="line">        return(</span><br><span class="line">        </span><br><span class="line">             &lt;button onClick &#x3D; &#123;this.props.onClick&#125;&gt;点击increase&lt;&#x2F;button&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Foo &#x3D; connect()(Foo);</span><br><span class="line">export default Foo;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>组件也就改成了上边这样，可以直接通过this.props.onClick，来调用dispatch,这样子就不需要在代码中来进行store.dispatch了</p><h4 id="mapDispatchToProps多种写法"><a href="#mapDispatchToProps多种写法" class="headerlink" title="mapDispatchToProps多种写法"></a>mapDispatchToProps多种写法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">传统写法：</span><br><span class="line">const mapDispatchToProps &#x3D; (dispatch)&#x3D;&gt;&#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    abc:(aaa)&#x3D;&gt;</span><br><span class="line">      dispatch(&#123;</span><br><span class="line">        type:&#39;ADD&#39;,</span><br><span class="line">        id:num++,</span><br><span class="line">        text:aaa,</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">      qqw:(aaa)&#x3D;&gt;&#123;</span><br><span class="line">          dispatch(&#123;</span><br><span class="line">              type:&#39;TYY&#39;,</span><br><span class="line">              id:num++,</span><br><span class="line">              text:aaa,</span><br><span class="line">          &#125;)</span><br><span class="line">      &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">或者：</span><br><span class="line">function mapDispatchToProps(dispatch) &#123;</span><br><span class="line">   return &#123;</span><br><span class="line">         onIncrement: (...args) &#x3D;&gt; dispatch(actions.onIncrement(...args)),</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">第二种写法：</span><br><span class="line">const ActionCreators &#x3D; &#123;</span><br><span class="line"> abc:aaa&#x3D;&gt;&#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            type:&#39;ADD&#39;,</span><br><span class="line">            id:num++,</span><br><span class="line">            text:aaa,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    qqw:aaa&#x3D;&gt;(&#123;</span><br><span class="line">        type:&#39;TYY&#39;,</span><br><span class="line">        id:num++,</span><br><span class="line">        text:aaa,</span><br><span class="line">    &#125;),</span><br><span class="line">&#125;</span><br><span class="line">const mapDispatchToProps &#x3D; ActionCreators</span><br><span class="line">实例：</span><br><span class="line">import &#123; creament, decreament, setcount &#125; from &#39;..&#x2F;redux&#x2F;actions.js&#39;</span><br><span class="line">import ReduxTest from &#39;..&#x2F;views&#x2F;reduxTest.jsx&#39;</span><br><span class="line"></span><br><span class="line">export default connect((state) &#x3D;&gt; (&#123;count: state.count &#125;), &#123;</span><br><span class="line">  creament,</span><br><span class="line">  decreament,</span><br><span class="line">  setcount,</span><br><span class="line">&#125;)(ReduxTest)</span><br><span class="line"></span><br><span class="line">方法三：</span><br><span class="line">const mapDispatchToProps &#x3D; (dispatch) &#x3D;&gt; &#123;</span><br><span class="line">return bindActionCreators(ActionCreators, dispatch)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>react-redux的基本介绍就到这里了</p><h1 id="Redux-DevTool"><a href="#Redux-DevTool" class="headerlink" title="Redux DevTool"></a>Redux DevTool</h1><p><code>npm i --save--dev redux-devtools-extension</code></p><h1 id="redux-saga"><a href="#redux-saga" class="headerlink" title="redux-saga"></a>redux-saga</h1><p>如果按照原始的redux工作流程，当组件中产生一个action后会直接触发reducer修改state，reducer又是一个纯函数，也就是不能再reducer中进行异步操作；</p><p><strong>而往往实际中，组件中发生的action后，在进入reducer之前需要完成一个异步任务,比如发送ajax请求后拿到数据后，再进入reducer,显然原生的redux是不支持这种操作的</strong></p><p>这个时候急需一个中间件来处理这种业务场景，目前最优雅的处理方式自然就是redux-saga</p><h2 id="核心讲解"><a href="#核心讲解" class="headerlink" title="核心讲解"></a>核心讲解</h2><h3 id="1、Saga-辅助函数"><a href="#1、Saga-辅助函数" class="headerlink" title="1、Saga 辅助函数"></a><strong>1、Saga 辅助函数</strong></h3><p>redux-saga提供了一些辅助函数，用来在一些特定的action 被发起到Store时派生任务，下面我先来讲解两个辅助函数：<code>takeEvery</code> 和 <code>takeLatest</code></p><ul><li><h4 id="takeEvery"><a href="#takeEvery" class="headerlink" title="takeEvery"></a>takeEvery</h4></li></ul><p><strong>takeEvery就像一个流水线的洗碗工，过来一个脏盘子就直接执行后面的洗碗函数，一旦你请了这个洗碗工他会一直执行这个工作，绝对不会停止接盘子的监听过程和触发洗盘子函数</strong></p><p>例如：每次点击 按钮去Fetch获取数据时时，我们发起一个 FETCH_REQUESTED 的 action。 我们想通过启动一个任务从服务器获取一些数据，来处理这个action，类似于</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">window.addEventLister(&#39;xxx&#39;,fn)</span><br></pre></td></tr></table></figure><p>当dispatch xxx的时候，就会执行fn方法，</p><p>首先我们创建一个将执行异步 action 的任务(也就是上边的fn)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; put：你就认为put就等于 dispatch就可以了；</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; call：可以理解为实行一个异步函数,是阻塞型的，只有运行完后面的函数，才会继续往下；</span><br><span class="line">&#x2F;&#x2F; 在这里可以片面的理解为async中的await！但写法直观多了！</span><br><span class="line">import &#123; call, put &#125; from &#39;redux-saga&#x2F;effects&#39;</span><br><span class="line"></span><br><span class="line">export function* fetchData(action) &#123;</span><br><span class="line">   try &#123;</span><br><span class="line">      const apiAjax &#x3D; (params) &#x3D;&gt; fetch(url, params);</span><br><span class="line">      const data &#x3D; yield call(apiAjax);</span><br><span class="line">      yield put(&#123;type: &quot;FETCH_SUCCEEDED&quot;, data&#125;);</span><br><span class="line">   &#125; catch (error) &#123;</span><br><span class="line">      yield put(&#123;type: &quot;FETCH_FAILED&quot;, error&#125;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>然后在每次 FETCH_REQUESTED action 被发起时启动上面的任务,也就<strong>相当于每次触发一个名字为 FETCH_REQUESTED 的action就会执行上边的任务</strong>,代码如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import &#123; takeEvery &#125; from &#39;redux-saga&#39;</span><br><span class="line"></span><br><span class="line">function* watchFetchData() &#123;</span><br><span class="line"></span><br><span class="line">  yield* takeEvery(&quot;FETCH_REQUESTED&quot;, fetchData)</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：上面的 takeEvery 函数可以使用下面的写法替换</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function* watchFetchData() &#123;</span><br><span class="line">  </span><br><span class="line">   while(true)&#123;</span><br><span class="line">     yield take(&#39;FETCH_REQUESTED&#39;);</span><br><span class="line">     yield fork(fetchData);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><ul><li><h4 id="takeLatest"><a href="#takeLatest" class="headerlink" title="takeLatest"></a>takeLatest</h4></li></ul><p>在上面的例子中，takeEvery <strong>允许多个 fetchData 实例同时启动</strong>，在某个特定时刻，我们可以启动一个新的 fetchData 任务， 尽管之前还有一个或多个 fetchData 尚未结束</p><p>如果我们<strong>只想得到最新那个请求的响应</strong>（例如，始终显示最新版本的数据），我们可以使用 takeLatest 辅助函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import &#123; takeLatest &#125; from &#39;redux-saga&#39;</span><br><span class="line"></span><br><span class="line">function* watchFetchData() &#123;</span><br><span class="line">  yield* takeLatest(&#39;FETCH_REQUESTED&#39;, fetchData)</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><strong>和takeEvery不同，在任何时刻 takeLatest 只允许执行一个 fetchData 任务，并且这个任务是最后被启动的那个，如果之前已经有一个任务在执行，那之前的这个任务会自动被取消</strong></p><h3 id="2、Effect-Creators"><a href="#2、Effect-Creators" class="headerlink" title="2、Effect Creators"></a><strong>2、Effect Creators</strong></h3><p>redux-saga框架提供了很多创建effect的函数，下面我们就来简单的介绍下开发中最常用的几种</p><ul><li>take(pattern)</li><li>put(action)</li><li>call(fn, …args)</li><li>fork(fn, …args)</li><li>select(selector, …args)</li></ul><h4 id="take-pattern"><a href="#take-pattern" class="headerlink" title="take(pattern)"></a><strong>take(pattern)</strong></h4><p>take函数可以理解为监听未来的action，它创建了一个命令对象，告诉middleware等待一个特定的action， Generator会暂停，直到一个与pattern匹配的action被发起，才会继续执行下面的语句，也就是说，take是一个阻塞的 effect</p><p>用法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function* watchFetchData() &#123;</span><br><span class="line">   while(true) &#123;</span><br><span class="line">   &#x2F;&#x2F; 监听一个type为 &#39;FETCH_REQUESTED&#39; 的action的执行，直到等到这个Action被触发，才会接着执行下面的 yield fork(fetchData)  语句</span><br><span class="line">     yield take(&#39;FETCH_REQUESTED&#39;);</span><br><span class="line">     yield fork(fetchData);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="put-action"><a href="#put-action" class="headerlink" title="put(action)"></a><strong>put(action)</strong></h4><p>put函数是用来发送action的 effect，你可以简单的<strong>把它理解成为redux框架中的dispatch函数</strong>，当put一个action后，reducer中就会计算新的state并返回，<strong>注意：</strong> <strong>put 也是阻塞 effect</strong></p><p>用法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">export function* toggleItemFlow() &#123;</span><br><span class="line">    let list &#x3D; []</span><br><span class="line">    &#x2F;&#x2F; 发送一个type为 &#39;UPDATE_DATA&#39; 的Action，用来更新数据，参数为 &#96;data：list&#96;</span><br><span class="line">    yield put(&#123;</span><br><span class="line">      type: actionTypes.UPDATE_DATA,</span><br><span class="line">      data: list</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="call-fn-…args"><a href="#call-fn-…args" class="headerlink" title="call(fn, …args)"></a><strong>call(fn, …args)</strong></h4><p><strong>call函数你可以把它简单的理解为就是可以调用其他函数的函数</strong>，它命令 middleware 来调用fn 函数， args为函数的参数，<strong>注意：</strong> <strong>fn 函数可以是一个 Generator 函数，也可以是一个返回 Promise 的普通函数</strong>，call 函数也是<strong>阻塞 effect</strong></p><p>用法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">export const delay &#x3D; ms &#x3D;&gt; new Promise(resolve &#x3D;&gt; setTimeout(resolve, ms))</span><br><span class="line"></span><br><span class="line">export function* removeItem() &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    &#x2F;&#x2F; 这里call 函数就调用了 delay 函数，delay 函数为一个返回promise 的函数</span><br><span class="line">    return yield call(delay, 500)</span><br><span class="line">  &#125; catch (err) &#123;</span><br><span class="line">    yield put(&#123;type: actionTypes.ERROR&#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="fork-fn-…args"><a href="#fork-fn-…args" class="headerlink" title="fork(fn, …args)"></a><strong>fork(fn, …args)</strong></h4><p>fork 函数和 call 函数很像，<strong>都是用来调用其他函数的，但是fork函数是非阻塞函数</strong>，也就是说，<strong>程序执行完 <code>yield fork(fn， args)</code> 这一行代码后，会立即接着执行下一行代码语句，而不会等待fn函数返回结果后</strong>，在执行下面的语句</p><p>用法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import &#123; fork &#125; from &#39;redux-saga&#x2F;effects&#39;</span><br><span class="line"></span><br><span class="line">export default function* rootSaga() &#123;</span><br><span class="line">  &#x2F;&#x2F; 下面的四个 Generator 函数会一次执行，不会阻塞执行</span><br><span class="line">  yield fork(addItemFlow)</span><br><span class="line">  yield fork(removeItemFlow)</span><br><span class="line">  yield fork(toggleItemFlow)</span><br><span class="line">  yield fork(modifyItem)</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="select-selector-…args"><a href="#select-selector-…args" class="headerlink" title="select(selector, …args)"></a><strong>select(selector, …args)</strong></h4><p>select 函数是用来指示 middleware调用提供的选择器获取Store上的state数据，你也可以简单的把它理解为<strong>redux框架中获取store上的 state数据一样的功能</strong> ：<code>store.getState()</code></p><p>用法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">export function* toggleItemFlow() &#123;</span><br><span class="line">     &#x2F;&#x2F; 通过 select effect 来获取 全局 state上的 &#96;getTodoList&#96; 中的 list</span><br><span class="line">     let tempList &#x3D; yield select(state &#x3D;&gt; state.getTodoList.list)</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h1 id="一个具体的实例"><a href="#一个具体的实例" class="headerlink" title="一个具体的实例"></a>一个具体的实例</h1><p>*<em>index.js *</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">import React from &#39;react&#39;;</span><br><span class="line">import ReactDOM from &#39;react-dom&#39;;</span><br><span class="line">import &#123;createStore, applyMiddleware&#125; from &#39;redux&#39;</span><br><span class="line">import createSagaMiddleware from &#39;redux-saga&#39;</span><br><span class="line"></span><br><span class="line">import rootSaga from &#39;.&#x2F;sagas&#39;</span><br><span class="line">import Counter from &#39;.&#x2F;Counter&#39;</span><br><span class="line">import rootReducer from &#39;.&#x2F;reducers&#39;</span><br><span class="line"></span><br><span class="line">const sagaMiddleware &#x3D; createSagaMiddleware() &#x2F;&#x2F; 创建了一个saga中间件实例</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 下边这句话和下边的两行代码创建store的方式是一样的</span><br><span class="line">&#x2F;&#x2F; const store &#x3D; createStore(reducers,applyMiddlecare(middlewares))</span><br><span class="line"></span><br><span class="line">const createStoreWithMiddleware &#x3D; applyMiddleware(middlewares)(createStore)</span><br><span class="line">const store &#x3D; createStoreWithMiddleware(rootReducer)</span><br><span class="line"></span><br><span class="line">sagaMiddleware.run(rootSaga)</span><br><span class="line"></span><br><span class="line">const action &#x3D; type &#x3D;&gt; store.dispatch(&#123; type &#125;)</span><br><span class="line"></span><br><span class="line">function render() &#123;</span><br><span class="line">  ReactDOM.render(</span><br><span class="line">    &lt;Counter</span><br><span class="line">      value&#x3D;&#123;store.getState()&#125;</span><br><span class="line">      onIncrement&#x3D;&#123;() &#x3D;&gt; action(&#39;INCREMENT&#39;)&#125;</span><br><span class="line">      onDecrement&#x3D;&#123;() &#x3D;&gt; action(&#39;DECREMENT&#39;)&#125;</span><br><span class="line">      onIncrementAsync&#x3D;&#123;() &#x3D;&gt; action(&#39;INCREMENT_ASYNC&#39;)&#125; &#x2F;&gt;,</span><br><span class="line">    document.getElementById(&#39;root&#39;)</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">render()</span><br><span class="line"></span><br><span class="line">store.subscribe(render)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><strong>sagas.js</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">import &#123; put, call, take,fork &#125; from &#39;redux-saga&#x2F;effects&#39;;</span><br><span class="line">import &#123; takeEvery, takeLatest &#125; from &#39;redux-saga&#39;</span><br><span class="line"></span><br><span class="line">export const delay &#x3D; ms &#x3D;&gt; new Promise(resolve &#x3D;&gt; setTimeout(resolve, ms));</span><br><span class="line"></span><br><span class="line">function* incrementAsync() &#123;</span><br><span class="line">  &#x2F;&#x2F; 延迟 1s 在执行 + 1操作</span><br><span class="line">  yield call(delay, 1000);</span><br><span class="line">  yield put(&#123; type: &#39;INCREMENT&#39; &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default function* rootSaga() &#123;</span><br><span class="line">  &#x2F;&#x2F; while(true)&#123;</span><br><span class="line">  &#x2F;&#x2F;   yield take(&#39;INCREMENT_ASYNC&#39;);</span><br><span class="line">  &#x2F;&#x2F;   yield fork(incrementAsync);</span><br><span class="line">  &#x2F;&#x2F; &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 下面的写法与上面的写法上等效</span><br><span class="line">  yield* takeEvery(&quot;INCREMENT_ASYNC&quot;, incrementAsync)</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><strong>reducer.js</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">export default function counter(state &#x3D; 0, action) &#123;</span><br><span class="line">  switch (action.type) &#123;</span><br><span class="line">    case &#39;INCREMENT&#39;:</span><br><span class="line">      return state + 1</span><br><span class="line">    case &#39;DECREMENT&#39;:</span><br><span class="line">      return state - 1</span><br><span class="line">    case &#39;INCREMENT_ASYNC&#39;:</span><br><span class="line">      return state</span><br><span class="line">    default:</span><br><span class="line">      return state</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>从上面的代码结构可以看出，redux-saga的使用方式还是比较简单的，相比较之前的redux框架的CounterApp，多了一个sagas的文件，reducers文件还是之前的使用方式</p><h3 id="redux-saga基本用法总结："><a href="#redux-saga基本用法总结：" class="headerlink" title="redux-saga基本用法总结："></a>redux-saga基本用法总结：</h3><ol><li><strong>使用 createSagaMiddleware 方法创建 saga 的 Middleware ，然后在创建的 redux 的 store 时，使用 applyMiddleware 函数将创建的 saga Middleware 实例绑定到 store 上，最后可以调用 saga Middleware 的 run 函数来执行某个或者某些 Middleware 。</strong></li><li><strong>在 saga 的 Middleware 中，可以使用 takeEvery 或者 takeLatest 等 API 来监听某个 action ，当某个 action 触发后， saga 可以使用 call 发起异步操作，操作完成后使用 put 函数触发 action ，同步更新 state ，从而完成整个 State 的更新。</strong></li></ol><hr><p>ok,故事到这里就接近尾声了，以上主要介绍了redux,react-redux和redux-saga目前redux全家桶主流的一些产品,接下来,主要会产出一下根据源码,<strong>手写一下redux和react-redux的轮子</strong></p>]]></content>
      
      
      <categories>
          
          <category> web前端 </category>
          
          <category> redux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web前端 </tag>
            
            <tag> redux </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
