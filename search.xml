<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>资源分享</title>
      <link href="/2021/04/11/share/%E8%B5%84%E6%BA%90/"/>
      <url>/2021/04/11/share/%E8%B5%84%E6%BA%90/</url>
      
        <content type="html"><![CDATA[<h1 id="资源分享"><a href="#资源分享" class="headerlink" title="资源分享"></a>资源分享</h1><h2 id="资源分享网站"><a href="#资源分享网站" class="headerlink" title="资源分享网站"></a>资源分享网站</h2><p><a href="https://www.sixyin.com/" target="_blank" rel="noopener">六音软件</a>        <a href="https://www.yeyulingfeng.com/" target="_blank" rel="noopener">夜雨聆风</a>    </p><h2 id="壁纸网站"><a href="#壁纸网站" class="headerlink" title="壁纸网站"></a>壁纸网站</h2><p><a href="https://wallhaven.cc/" target="_blank" rel="noopener">wallhaven</a>        <a href="https://wall.alphacoders.com/" target="_blank" rel="noopener">wallpaper    </a>    <a href="https://bz.zzzmh.cn/" target="_blank" rel="noopener">极简壁纸</a>    </p><h2 id="音乐下载"><a href="#音乐下载" class="headerlink" title="音乐下载"></a>音乐下载</h2><p>下载工具：<strong>MusicTools</strong>        <strong>五音助手</strong></p><p>网站：<a href="http://www.acgjc.com/yy/" target="_blank" rel="noopener">acg音乐网站</a>        <a href="https://www.ape8.cn/" target="_blank" rel="noopener">无损音乐</a>    </p><h2 id="Game"><a href="#Game" class="headerlink" title="Game"></a>Game</h2><p><a href="http://aiwan.jifen2345.cn/" target="_blank" rel="noopener">爱玩游戏</a>    </p>]]></content>
      
      
      <categories>
          
          <category> share </category>
          
      </categories>
      
      
        <tags>
            
            <tag> share </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>halcon算子</title>
      <link href="/2020/08/26/halcon%E7%AE%97%E5%AD%90/"/>
      <url>/2020/08/26/halcon%E7%AE%97%E5%AD%90/</url>
      
        <content type="html"><![CDATA[<h1 id="Chapter-1-Classification"><a href="#Chapter-1-Classification" class="headerlink" title="Chapter_1:Classification"></a>Chapter_1:Classification</h1><h2 id="1-1-Gaussian-Mixture-Models"><a href="#1-1-Gaussian-Mixture-Models" class="headerlink" title="1.1 Gaussian-Mixture-Models"></a>1.1 Gaussian-Mixture-Models</h2><p>1.add_sample_class_gmm</p><p>功能：把一个训练样本添加到一个高斯混合模型的训练数据上。</p><p>2.classify_class_gmm</p><p>功能：通过一个高斯混合模型来计算一个特征向量的类。</p><p>\3. clear_all_class_gmm</p><p> 功能：清除所有高斯混合模型。</p><p>\4. clear_class_gmm</p><p> 功能：清除一个高斯混合模型。</p><p>\5. clear_samples_class_gmm</p><p> 功能：清除一个高斯混合模型的训练数据。</p><p>\6. create_class_gmm</p><p>功能：为分类创建一个高斯混合模型。</p><p>7.evaluate_class_gmm</p><p> 功能：通过一个高斯混合模型评价一个特征向量。</p><p>\8. get_params_class_gmm</p><p>功能：返回一个高斯混合模型的参数。</p><p>\9. get_prep_info_class_gmm</p><p> 功能：计算一个高斯混合模型的预处理特征向量的信息内容。</p><p>\10. get_sample_class_gmm</p><p>  功能：从一个高斯混合模型的训练数据返回训练样本。</p><p>\11. get_sample_num_class_gmm</p><p>  功能：返回存储在一个高斯混合模型的训练数据中的训练样本的数量。</p><p>\12. read_class_gmm</p><p>  功能：从一个文件中读取一个高斯混合模型。</p><p>\13. read_samples_class_gmm</p><p>  功能：从一个文件中读取一个高斯混合模型的训练数据。</p><p>\14. train_class_gmm</p><p>  功能：训练一个高斯混合模型。</p><p>\15. write_class_gmm</p><p>  功能：向文件中写入一个高斯混合模型。</p><p>\16. write_samples_class_gmm</p><p>  功能：向文件中写入一个高斯混合模型的训练数据。</p><h2 id="1-2-Hyperboxes"><a href="#1-2-Hyperboxes" class="headerlink" title="1.2 Hyperboxes"></a>1.2 Hyperboxes</h2><p>\1. clear_sampset</p><p> 功能：释放一个数据集的内存。</p><p>\2. close_all_class_box</p><p> 功能：清除所有分类器。</p><p>\3. close_class_box</p><p> 功能：清除分类器。</p><p>\4. create_class_box</p><p> 功能：创建一个新的分类器。</p><p>\5. descript_class_box</p><p> 功能：分类器的描述。</p><p>\6. enquire_class_box</p><p> 功能：为一组属性分类。</p><p>\7. enquire_reject_class_box</p><p> 功能：为一组带抑制类的属性分类。</p><p>\8. get_class_box_param</p><p> 功能：获取关于现在参数的信息。</p><p>\9. learn_class_box</p><p> 功能：训练分类器。</p><p>\10. learn_sampset_box</p><p>  功能：用数据组训练分类器。</p><p>\11. read_class_box</p><p>  功能：从一个文件中读取分类器。</p><p>12.read_sampset</p><p>  功能：从一个文件中读取一个训练数据组。</p><p>\13. set_class_box_param</p><p>  功能：为分类器设计系统参数。</p><p>\14. test_sampset_box</p><p>  功能：为一组数组分类。</p><p>\15. write_class_box</p><p>  功能：在一个文件中保存分类器。</p><h2 id="1-3-Neural-Nets"><a href="#1-3-Neural-Nets" class="headerlink" title="1.3 Neural-Nets"></a>1.3 Neural-Nets</h2><p>\1. add_sample_class_mlp</p><p> 功能：把一个训练样本添加到一个多层感知器的训练数据中。</p><p>\2. classify_class_mlp</p><p> 功能：通过一个多层感知器计算一个特征向量的类。</p><p>\3. clear_all_class_mlp</p><p> 功能：清除所有多层感知器。</p><p>\4. clear_class_mlp</p><p> 功能：清除一个多层感知器。</p><p>\5. clear_samples_class_mlp</p><p> 功能：清除一个多层感知器的训练数据。</p><p>\6. create_class_mlp</p><p> 功能：为分类或者回归创建一个多层感知器。</p><p>\7. evaluate_class_mlp</p><p> 功能：通过一个多层感知器计算一个特征向量的评估。</p><p>\8. get_params_class_mlp</p><p> 功能：返回一个多层感知器的参数。</p><p>\9. get_prep_info_class_mlp</p><p> 功能：计算一个多层感知器的预处理特征向量的信息内容。</p><p>\10. get_sample_class_mlp</p><p>  功能：从一个多层感知器的训练数据返回一个训练样本。</p><p>\11. get_sample_num_class_mlp</p><p>  功能：返回存储在一个多层感知器的训练数据中的训练样本的数量。</p><p>\12. read_class_mlp</p><p>  功能：从一个文件中读取一个多层感知器。</p><p>\13. read_samples_class_mlp</p><p>  功能：从一个文件中读取一个多层感知器的训练数据。</p><p>\14. train_class_mlp、</p><p>  功能：训练一个多层感知器。</p><p>\15. write_class_mlp</p><p>  功能：向一个文件中写入一个多层感知器。</p><p>\16. write_samples_class_mlp</p><p>  功能：向一个文件中写入一个多层感知器的训练数据。</p><h2 id="1-4-Support-Vector-Machines"><a href="#1-4-Support-Vector-Machines" class="headerlink" title="1.4 Support-Vector-Machines"></a>1.4 Support-Vector-Machines</h2><p>\1. add_sample_class_svm</p><p> 功能：把一个训练样本添加到一个支持向量机的训练数据上。</p><p>\2. classify_class_svm</p><p> 功能：通过一个支持向量机为一个特征向量分类。</p><p>\3. clear_all_class_svm</p><p> 功能：清除所有支持向量机。</p><p>\4. clear_class_svm</p><p> 功能：清除一个支持向量机。</p><p>\5. clear_samples_class_svm</p><p> 功能：清除一个支持向量机的训练数据。</p><p>\6. create_class_svm</p><p> 功能：为模式分类创建一个支持向量机。</p><p>\7. get_params_class_svm</p><p> 功能：返回一个支持向量机的参数。</p><p>\8. get_prep_info_class_svm</p><p> 功能：计算一个支持向量机的预处理特征向量的信息内容。</p><p>\9. get_sample_class_svm</p><p> 功能：从一个支持向量机的训练数据返回一个训练样本。</p><p>\10. get_sample_num_class_svm</p><p>  功能：返回存储在一个支持向量机训练数据中的训练样本的数量。</p><p>\11. get_support_vector_class_svm</p><p>  功能：从一个训练过的支持向量机返回一个支持向量的索引。</p><p>\12. get_support_vector_num_class_svm</p><p>  功能：返回一个支持向量机的支持向量的数量。</p><p>\13. read_class_svm</p><p>  功能：从一个文件中读取一个支持向量机。</p><p>\14. read_samples_class_svm</p><p>  功能：从一个文件中读取一个支持向量机的训练数据。</p><p>\15. reduce_class_svm</p><p>  功能：为了更快分类，用一个降低的支持向量机近似一个训练过的支持向量机。</p><p>\16. train_class_svm</p><p>  功能：训练一个支持向量机。</p><p>\17. write_class_svm</p><p>  功能：向一个文件中写入一个支持向量机。</p><p>18.write_samples_class_svm</p><p>  功能：向一个文件中写入一个支持向量机的训练数据。</p><h1 id="Chapter-2-Control"><a href="#Chapter-2-Control" class="headerlink" title="Chapter_2 Control"></a>Chapter_2 Control</h1><p>1.assign</p><p>功能：为一个控制变量分配一个新值。</p><p>2.break</p><p> 功能：终止循环执行。</p><ol start="3"><li><p>comment</p><p>功能：向程序添加一行注释。</p></li><li><p>continue</p><p>功能：跳过现在的循环执行。</p></li><li><p>else</p><p>功能：条件语句的替换。</p></li><li><p>elseif</p><p>功能：可选择的条件语句。</p></li><li><p>endfor</p><p>功能：for循环的终止。</p></li><li><p>endif</p><p>功能：if命令的终止。</p></li><li><p>endwhile</p><p>功能：while循环的终止。</p></li><li><p>exit</p><p>功能：终止HDevelop。</p></li><li><p>for</p><p>功能：执行一定数量的主体。</p></li><li><p>if</p><p>功能：条件语句。</p></li></ol><p>13.ifelse</p><p>  功能：有选择的条件语句。</p><ol start="14"><li><p>insert</p><p>功能：向一个元组分配一个量。</p></li></ol><p>15.repeat</p><p>  功能：repeat..until循环的开始。</p><ol start="16"><li><p>return</p><p>功能：终止程序调用。</p></li><li><p>stop</p><p>功能：停止程序执行。</p></li></ol><p>18.until</p><p>  功能：继续执行主体，只要条件是不真实的。</p><ol start="19"><li><p>while</p><p>功能：继续执行主体，只要条件是真实的。</p></li></ol><h1 id="Chapter-3-Develop"><a href="#Chapter-3-Develop" class="headerlink" title="Chapter_3 :Develop"></a>Chapter_3 :Develop</h1><p>\1. dev_clear_obj</p><p>功能：从HALCON数据库中删除一个图标。</p><p>\2. dev_clear_window</p><p> 功能：清除活动图形窗口。</p><p>\3. dev_close_inspect_ctrl</p><p> 功能：关闭一个控制变量的监视窗口。</p><p>\4. dev_close_window</p><p> 功能：关闭活动图形窗口。</p><p>\5. dev_display</p><p> 功能：在现有图形窗口中显示图像目标。</p><p>\6. dev_error_var</p><p> 功能：定义或者不定义一个错误变量。</p><p>\7. dev_get_preferences</p><p> 功能：通过设计查询HDevelop的参数选择。</p><p>\8. dev_inspect_ctrl</p><p> 功能：打开一个窗口来检查一个控制变量。</p><p>\9. dev_map_par</p><p> 功能：打开一个对话框来指定显示参数。</p><p>\10. dev_map_prog</p><p>  功能：使HDevelop_的主窗口可视化。</p><p>\11. dev_map_var</p><p>  功能：在屏幕上绘制可视化窗口。</p><p>\12. dev_open_window</p><p>  功能：打开一个图形窗口。</p><p>\13. dev_set_check</p><p>  功能：指定错误处理。</p><p>\14. dev_set_color</p><p>  功能：设置一个或更多输出颜色。</p><p>\15. dev_set_colored</p><p>  功能：设置混合输出颜色。</p><p>\16. dev_set_draw</p><p>  功能：定义区域填充模式。</p><p>\17. dev_set_line_width</p><p>  功能：定义区域轮廓输出的线宽。</p><p>\18. dev_set_lut</p><p>  功能：设置查询表_(lut).</p><p>\19. dev_set_paint</p><p>  功能：定义灰度值输出模式。</p><p>\20. dev_set_part</p><p>  功能：修改显示图像部分。</p><p>\21. dev_set_preferences</p><p>  功能：通过设计设置HDevelop的参数选择。</p><p>\22. dev_set_shape</p><p>  功能：定义区域输出形状。</p><p>\23. dev_set_window</p><p>  功能：激活一个图形窗口。</p><p>\24. dev_set_window_extents</p><p>  功能：改变一个图形窗口的位置和大小。</p><p>\25. dev_unmap_par </p><p>  功能：为图形参数隐藏窗口。</p><p>\26. dev_unmap_prog</p><p>  功能：隐藏主窗口。</p><p>\27. dev_unmap_var</p><p>  功能：隐藏变量窗口。</p><p>\28. dev_update_pc</p><p>  功能：在程序执行中指定PC的行为。</p><p>\29. dev_update_time</p><p>  功能：为操作符打开或关闭切换时间测量。</p><p>\30. dev_update_var</p><p>  功能：在程序执行中指定活动窗口的行为。</p><p>\31. dev_update_window</p><p>  功能：在程序执行中指定输出行为。</p><h1 id="Chapter-4-File"><a href="#Chapter-4-File" class="headerlink" title="Chapter_4_:File"></a>Chapter_4_:File</h1><h2 id="4-1-Images"><a href="#4-1-Images" class="headerlink" title="4.1 Images"></a>4.1 Images</h2><p>\1. read_image</p><p> 功能：读取有不同文件格式的图像。</p><p>\2. read_sequence</p><p> 功能：读取图像。</p><p>\3. write_image</p><p> 功能：用图形格式写图像。</p><h2 id="4-2-Misc"><a href="#4-2-Misc" class="headerlink" title="4.2 Misc"></a>4.2 Misc</h2><p>\1. delete_file</p><p> 功能：删除一个文件。</p><p>\2. file_exists</p><p> 功能：检查文件是否存在。</p><p>\3. list_files</p><p> 功能：列出目录中的所有文件。</p><p>\4. read_world_file</p><p> 功能：从一个ARC/INFO世界文件中读取地理编码。</p><h2 id="4-3-Region"><a href="#4-3-Region" class="headerlink" title="4.3 Region"></a>4.3 Region</h2><p>\1. read_region</p><p> 功能：读取二值图像或者HALCON区域。</p><p>\2. write_region</p><p> 功能：在文件中写入地域。</p><h2 id="4-4-Text"><a href="#4-4-Text" class="headerlink" title="4.4 Text"></a>4.4 Text</h2><p>\1. close_all_files</p><p> 功能：关闭所有打开的文件。</p><p>2.close_file</p><p> 功能：关闭一个文本文件。</p><p>\3. fnew_line</p><p> 功能：创建一个换行符。</p><p>\4. fread_char</p><p> 功能：从一个文本文件中读取一个字符。</p><p>\5. fread_line</p><p> 功能：从一个文本文件中读取一行。</p><p>\6. fread_string</p><p> 功能：从一个文本文件中读取字符串。</p><p>\7. fwrite_string</p><p> 功能：向一个文本文件中写入值。</p><p>\8. open_file</p><p> 功能：打开文本文件。</p><h2 id="4-5-Tuple"><a href="#4-5-Tuple" class="headerlink" title="4.5 Tuple"></a>4.5 Tuple</h2><p>\1. read_tuple</p><p> 功能：从一个文件中读取一个数组。</p><p>\2. write_tuple</p><p> 功能：向一个文件中写入一个数组。</p><h2 id="4-6-XLD"><a href="#4-6-XLD" class="headerlink" title="4.6 XLD"></a>4.6 XLD</h2><p>\1. read_contour_xld_arc_info</p><p> 功能：从用ARC/INFO生成格式表示的文件读取XLD轮廓。</p><p>\2. read_contour_xld_dxf</p><p> 功能：从一个DXF文件中读取_XLD轮廓。</p><p>\3. read_polygon_xld_arc_info</p><p> 功能：从用ARC/INFO生成格式表示的文件读取XLD多边形。</p><p>\4. read_polygon_xld_dxf</p><p> 功能：从一个DXF文件中读取_XLD多边形。</p><p>\5. write_contour_xld_arc_info</p><p> 功能：向用ARC/INFO生成格式表示的文件写入XLD轮廓。</p><p>\6. write_contour_xld_dxf</p><p> 功能：向一个DXF格式的文件中写入_XLD轮廓。</p><p>\7. write_polygon_xld_arc_info</p><p> 功能：向用ARC/INFO生成格式表示的文件写入XLD多边形。</p><p>\8. write_polygon_xld_dxf</p><p> 功能：向一个DXF格式的文件中写入_XLD多边形。</p><h1 id="Chapter-5-Filter"><a href="#Chapter-5-Filter" class="headerlink" title="Chapter_5:Filter"></a>Chapter_5:Filter</h1><h2 id="5-1-Arithmetic"><a href="#5-1-Arithmetic" class="headerlink" title="5.1 Arithmetic"></a>5.1 Arithmetic</h2><p>\1. abs_image</p><p> 功能：计算一个图像的绝对值（模数）。</p><p>\2. add_image</p><p> 功能：使两个图像相加。</p><p>\3. div_image</p><p> 功能：使两个图像相除。</p><p>\4. invert_image</p><p> 功能：使一个图像反像。</p><p>\5. max_image</p><p> 功能：按像素计算两个图像的最大值。</p><p>\6. min_image</p><p> 功能：按像素计算两个图像的最大小值。</p><p>\7. mult_image</p><p> 功能：使两个图像相乘。</p><p>\8. scale_image</p><p> 功能：为一个图像的灰度值分级。</p><p>\9. sqrt_image</p><p> 功能：计算一个图像的平方根。</p><p>\10. sub_image</p><p>  功能：使两个图像相减。</p><h2 id="5-2-Bit"><a href="#5-2-Bit" class="headerlink" title="5.2 Bit"></a>5.2 Bit</h2><p>\1. bit_and</p><p> 功能：输入图像的所有像素的逐位与。</p><p>\2. bit_lshift</p><p> 功能：图像的所有像素的左移。</p><p>\3. bit_mask</p><p> 功能：使用位掩码的每个像素的逻辑与。</p><p>\4. bit_not</p><p> 功能：对像素的所有位求补。</p><p>\5. bit_or</p><p> 功能：输入图像的所有像素的逐位或。</p><p>\6. bit_rshift</p><p> 功能：图像的所有像素的右移。</p><p>\7. bit_slice</p><p> 功能：从像素中提取一位。</p><p>\8. bit_xor</p><p> 功能：输入图像的所有像素的逐位异或。</p><h2 id="5-3-Color"><a href="#5-3-Color" class="headerlink" title="5.3 Color"></a>5.3 Color</h2><p>\1. cfa_to_rgb</p><p> 功能：把一个单通道颜色滤波阵列图像变成RGB图像。</p><p>\2. gen_principal_comp_trans</p><p> 功能：计算多通道图像的主要部分分析的转换矩阵。</p><p>\3. linear_trans_color</p><p> 功能：计算多通道图像的颜色值的一个仿射转换。</p><p>\4. principal_comp</p><p> 功能：计算多通道图像的主要部分。</p><p>\5. rgb1_to_gray</p><p> 功能：把一个RGB图像转变成一个灰度图像。</p><p>\6. rgb3_to_gray</p><p>功能：把一个RGB图像转变成一个灰度图像。</p><p>\7. trans_from_rgb</p><p> 功能：把一个图像从RGB颜色空间转变成任意颜色空间。</p><p>\8. trans_to_rgb</p><p> 功能：把一个图像从任意颜色空间转变成RGB颜色空间。</p><h2 id="5-4-Edges"><a href="#5-4-Edges" class="headerlink" title="5.4 Edges"></a>5.4 Edges</h2><p>1.close_edges</p><p> 功能：使用边缘幅值图像消除边缘缺陷。</p><p>\2. close_edges_length</p><p> 功能：使用边缘幅值图像消除边缘缺陷。</p><p>\3. derivate_gauss</p><p> 功能：用高斯派生物对一个图像卷积。</p><p>\4. diff_of_gauss</p><p> 功能：近似高斯的拉普拉斯算子。</p><p>\5. edges_color</p><p> 功能：使用Canny、Deriche或者_Shen_滤波器提取颜色边缘。</p><p>\6. edges_color_sub_pix</p><p> 功能：使用Canny、Deriche或者_Shen_滤波器提取子像素精确颜色边缘。</p><p>\7. edges_image</p><p> 功能：使用Deriche、_Lanser、Shen或者_Canny滤波器提取边缘。</p><p>\8. edges_sub_pix</p><p> 功能：使用Deriche、_Lanser、Shen或者_Canny滤波器提取子像素精确边缘。</p><p>\9. frei_amp</p><p> 功能：使用Frei-Chen算子检测边缘（幅值）。</p><p>\10. frei_dir</p><p>  功能：使用Frei-Chen算子检测边缘（幅值和相位）。</p><p>\11. highpass_image</p><p>  功能：从一个图像提取高频成分。</p><p>\12. info_edges</p><p>  功能：在edges_image估计滤波器的宽度。</p><p>\13. kirsch_amp</p><p>  功能：使用Kirsch算子检测边缘（幅值）。</p><p>\14. kirsch_dir</p><p>  功能：使用Kirsch算子检测边缘（幅值和相位）。</p><p>\15. laplace</p><p>  功能：使用有限差计算拉普拉斯算子。</p><p>\16. laplace_of_gauss</p><p>  功能：高斯的拉普拉斯算子。</p><p>\17. prewitt_amp</p><p>  功能：使用Prewitt算子检测边缘（幅值）。</p><p>\18. prewitt_dir</p><p>  功能：使用Prewitt算子检测边缘（幅值和相位）。</p><p>\19. roberts</p><p>  功能：使用Roberts滤波器检测边缘。</p><p>\20. robinson_amp</p><p>  功能：使用Robinson算子检测边缘（幅值）。</p><p>\21. robinson_dir</p><p>  功能：使用Robinson算子检测边缘（幅值和相位）。</p><p>\22. sobel_amp</p><p>  功能：使用Sobel算子检测边缘（幅值）。</p><p>\23. sobel_dir</p><p>  功能：使用Sobel算子检测边缘（幅值和相位）。</p><h2 id="5-5-Enhancement"><a href="#5-5-Enhancement" class="headerlink" title="5.5 Enhancement"></a>5.5 Enhancement</h2><p>\1. adjust_mosaic_images</p><p> 功能：全景图像的自动颜色更改。</p><p>\2. coherence_enhancing_diff</p><p> 功能：执行一个图像的一个一致性增强扩散。</p><p>\3. emphasize</p><p> 功能：增强图像对比度。</p><p>\4. equ_histo_image</p><p> 功能：图像的柱状图线性化。</p><p>\5. illuminate</p><p> 功能：增强图像对比度。</p><p>\6. mean_curvature_flow</p><p> 功能：把平均曲率应用在一个图像中。</p><p>\7. scale_image_max_</p><p> 功能：最大灰度值在0到255范围内。</p><p>\8. shock_filter</p><p> 功能：把一个冲击滤波器应用到一个图像中。</p><h2 id="5-6-FFT"><a href="#5-6-FFT" class="headerlink" title="5.6 FFT"></a>5.6 FFT</h2><p>\1. convol_fft</p><p> 功能：用在频域内的滤波器使一个图像卷积。</p><p>\2. convol_gabor</p><p> 功能：用在频域内的一个Gabor滤波器使一个图像卷积。</p><p>\3. correlation_fft</p><p> 功能：计算在频域内的两个图像的相互关系。</p><p>\4. energy_gabor</p><p> 功能：计算一个两通道图像的能量。</p><p>\5. fft_generic</p><p> 功能：计算一个图像的快速傅里叶变换。</p><p>\6. fft_image</p><p> 功能：计算一个图像的快速傅里叶变换。</p><p>\7. fft_image_inv</p><p> 功能：计算一个图像的快速傅里叶逆变换。</p><p>\8. gen_bandfilter</p><p> 功能：生成一个理想带通滤波器。</p><p>\9. gen_bandpass</p><p> 功能：生成一个理想带通滤波器。</p><p>\10. gen_derivative_filter</p><p>  功能：在频域内生成一个倒数滤波器。</p><p>\11. gen_filter_mask</p><p>  功能：在空域内存储一个滤波器掩码作为实时图像。</p><p>\12. gen_gabor</p><p>  功能：生成一个Gabor滤波器。</p><p>\13. gen_gauss_filter</p><p>  功能：在频域内生成一个高斯滤波器。</p><p>\14. gen_highpass</p><p>  功能：生成一个理想高通滤波器。</p><p>\15. gen_lowpass</p><p>  功能：生成一个理想低通滤波器。</p><p>\16. gen_sin_bandpass</p><p>  功能：用正弦形状生成一个带通滤波器。</p><p>\17. gen_std_bandpass</p><p>  功能：用高斯或者正弦形状生成一个带通滤波器。</p><p>\18. optimize_fft_speed</p><p>  功能：使FFT的运行时间最优化。</p><p>\19. optimize_rft_speed</p><p>  功能：使实值的FFT的运行时间最优化。</p><p>\20. phase_deg</p><p>  功能：返回用角度表示的一个复杂图像的相位。</p><p>\21. phase_rad</p><p>  功能：返回用弧度表示的一个复杂图像的相位。</p><p>\22. power_byte</p><p>  功能：返回一个复杂图像的功率谱。</p><p>\23. power_ln_</p><p>功能：返回一个复杂图像的功率谱。</p><p>\24. power_real</p><p>功能：返回一个复杂图像的功率谱。</p><p>\25. read_fft_optimization_data</p><p>  功能：从一个文件中下载FFT速度最优数据。</p><p>\26. rft_generic</p><p>  功能：计算一个图像的实值快速傅里叶变换。</p><p>\27. write_fft_optimization_data</p><p>  功能：把FFT速度最优数据存储在一个文件中。</p><h2 id="5-7-Geometric-Transformations"><a href="#5-7-Geometric-Transformations" class="headerlink" title="5.7 Geometric-Transformations"></a>5.7 Geometric-Transformations</h2><p>\1. affine_trans_image</p><p>功能：把任意仿射2D变换应用在图像中。</p><p>\2. affine_trans_image_size</p><p> 功能：把任意仿射2D变换应用在图像中并且指定输出图像大小。</p><p>\3. gen_bundle_adjusted_mosaic</p><p> 功能：把多重图像合成一个马赛克图像。</p><p>\4. gen_cube_map_mosaic</p><p> 功能：创建球形马赛克的6方位图像。</p><p>\5. gen_projective_mosaic</p><p> 功能：把多重图像合成一个马赛克图像。</p><p>\6. gen_spherical_mosaic</p><p> 功能：创建一个球形马赛克图像。</p><p>\7. map_image</p><p> 功能：把一个一般变换应用于一个图像中。</p><p>\8. mirror_image</p><p> 功能：镜像一个图像。</p><p>\9. polar_trans_image</p><p> 功能：把一个图像转换成极坐标。</p><p>\10. polar_trans_image_ext</p><p>  功能：把一个图像中的环形弧转变成极坐标。</p><p>\11. polar_trans_image_inv</p><p>  功能：把极坐标中的图像转变成直角坐标。</p><p>\12. projective_trans_image</p><p>  功能：把投影变换应用于一个图像中。</p><p>\13. projective_trans_image_size</p><p>  功能：把投影变换应用于一个图像中并且指定输出图像的大小。</p><p>\14. rotate_image</p><p>  功能：以一个图像的中心为圆心旋转。</p><p>\15. zoom_image_factor</p><p>  功能：把一个图像缩放规定因子倍。</p><p>\16. zoom_image_size</p><p>  功能：把一个图像缩放到规定大小。</p><h2 id="5-8-Inpainting"><a href="#5-8-Inpainting" class="headerlink" title="5.8 Inpainting"></a>5.8 Inpainting</h2><p>\1. harmonic_interpolation</p><p> 功能：对一个图像区域执行谐波插值。</p><p>\2. inpainting_aniso</p><p> 功能：通过各向异性扩散执行图像修复。</p><p>\3. inpainting_ced</p><p> 功能：通过一致性增强扩散执行图像修复。</p><p>\4. inpainting_ct</p><p> 功能：通过连贯传送执行图像修复。</p><p>\5. inpainting_mcf</p><p> 功能：通过水平线平滑执行图像修复。</p><p>\6. inpainting_texture</p><p> 功能：通过结构传导执行图像修复。</p><h2 id="5-9-Lines"><a href="#5-9-Lines" class="headerlink" title="5.9 Lines"></a>5.9 Lines</h2><p>\1. bandpass_image</p><p> 功能：使用带通滤波器提取边缘。</p><p>\2. lines_color</p><p> 功能：检测色线和它们的宽度。</p><p>\3. lines_facet</p><p> 功能：使用面模型检测线。</p><p>\4. lines_gauss</p><p> 功能：检测线和它们的宽度。</p><h2 id="5-10-Match"><a href="#5-10-Match" class="headerlink" title="5.10 Match"></a>5.10 Match</h2><p>\1. exhaustive_match</p><p> 功能：模板和图像的匹配。</p><p>\2. exhaustive_match_mg</p><p> 功能：在一个分辨率塔式结构中匹配模板和图像。</p><p>\3. gen_gauss_pyramid</p><p> 功能：计算一个高斯金字塔。</p><p>\4. monotony</p><p> 功能：计算单一操作。</p><h2 id="5-11-Misc"><a href="#5-11-Misc" class="headerlink" title="5.11 Misc"></a>5.11 Misc</h2><p>\1. convol_image</p><p> 功能：用一个任意滤波掩码对一个图像卷积。</p><p>\2. expand_domain_gray</p><p> 功能：扩大图像区域并且在扩大的区域中设置灰度值。</p><p>\3. gray_inside</p><p> 功能：对图像中的每一点在图像边界的任意路径计算尽可能低的灰度值。</p><p>\4. gray_skeleton</p><p> 功能：灰度值图像的细化。</p><p>\5. lut_trans</p><p> 功能：使用灰度值查询表转换一个图像。</p><p>\6. symmetry</p><p> 功能：沿一行的灰度值的对称性。</p><p>\7. topographic_sketch</p><p> 功能：计算一个图像的地理原始草图。</p><h2 id="5-12-Noise"><a href="#5-12-Noise" class="headerlink" title="5.12 Noise"></a>5.12 Noise</h2><p>\1. add_noise_distribution</p><p> 功能：向一个图像添加噪声。</p><p>\2. add_noise_white</p><p> 功能：向一个图像添加噪声。</p><p>\3. gauss_distribution</p><p> 功能：产生一个高斯噪声分布。</p><p>\4. noise_distribution_mean</p><p> 功能：测定一个图像的噪声分布。</p><p>\5. sp_distribution</p><p> 功能：产生一个椒盐噪声分布。</p><h2 id="5-13-Optical-Flow"><a href="#5-13-Optical-Flow" class="headerlink" title="5.13 Optical-Flow"></a>5.13 Optical-Flow</h2><p>\1. optical_flow_mg</p><p> 功能：计算两个图像之间的光流。</p><p>\2. unwarp_image_vector_field</p><p> 功能：使用一个矢量场来展开一个图像。</p><p>\3. vector_field_length</p><p> 功能：计算一个矢量场的矢量长度。</p><h2 id="5-14-Points"><a href="#5-14-Points" class="headerlink" title="5.14 Points"></a>5.14 Points</h2><p>\1. corner_response</p><p> 功能：在图像中寻找角点。</p><p>\2. dots_image</p><p> 功能：在一个图像中增强圆形点。</p><p>\3. points_foerstner</p><p> 功能：使用Förstner算子检测关注点。</p><p>\4. points_harris</p><p> 功能：使用Harris算子检测关注点。</p><p>\5. points_sojka</p><p> 功能：使用Sojka算子找出角点。</p><h2 id="5-15-Smoothing"><a href="#5-15-Smoothing" class="headerlink" title="5.15 Smoothing"></a>5.15 Smoothing</h2><p>\1. anisotrope_diff</p><p> 功能：通过保边各向异性扩散平滑一个图像。</p><p>\2. anisotropic_diffusion</p><p> 功能：对一个图像执行各向异性扩散。</p><p>\3. binomial_filter</p><p> 功能：使用binomial滤波器平滑一个图像。</p><p>\4. eliminate_min_max</p><p> 功能：在空域内平滑一个图像来抑制噪声。</p><p>\5. eliminate_sp</p><p> 功能：用中值替代阀值外的值。</p><p>\6. fill_interlace</p><p> 功能：插补两个半个视频图像。</p><p>\9. gauss_image</p><p> 功能：使用离散高斯函数平滑图像。</p><p>\10. info_smooth</p><p>  功能：平滑滤波器smooth_image的信息。</p><p>\11. isotropic_diffusion</p><p>  功能：对一个图像执行各向同性扩散。</p><p>\12. mean_image</p><p>  功能：通过平均平滑一个图像。</p><p>\13. mean_n</p><p>  功能：几个通道的平均灰度值。</p><p>\14. mean_sp</p><p>  功能：抑制椒盐噪声。</p><p>\15. median_image</p><p>  功能：使用不同级别掩码的中值滤波。</p><p>\16. median_separate_</p><p>  功能：使用矩形掩码的离散中值滤波。</p><p>\17. median_weighted</p><p>  功能：使用不同级别掩码的加权中值滤波。</p><p>\18. midrange_image</p><p>  功能：计算掩码内最大和最小值的平均。</p><p>\19. rank_image</p><p>  功能：通过一个任意等级掩码平滑一个图像。</p><p>\20. sigma_image</p><p>  功能：使用sigma滤波器的非线性平滑。</p><p>\21. smooth_image</p><p>  功能：使用递归滤波器平滑一个图像。</p><p>\22. trimmed_mean</p><p>  功能：使用任意等级掩码平滑一个图像。</p><h2 id="5-16-Texture"><a href="#5-16-Texture" class="headerlink" title="5.16 Texture"></a>5.16 Texture</h2><p>\1. deviation_image</p><p> 功能：计算矩形窗口内的灰度值的标准偏差。</p><p>\2. entropy_image</p><p> 功能：计算矩形窗口内的灰度值的熵。</p><p>\3. texture_laws</p><p> 功能：使用一个Laws文本滤波器过滤一个图像。</p><h2 id="5-17-Wiener-Filter"><a href="#5-17-Wiener-Filter" class="headerlink" title="5.17 Wiener-Filter"></a>5.17 Wiener-Filter</h2><p>\1. gen_psf_defocus</p><p> 功能：产生一个均匀散焦模糊的脉冲相应。</p><p>\2. gen_psf_motion</p><p> 功能：产生一个（线性）运动模糊的脉冲相应。</p><p>\3. simulate_defocus</p><p> 功能：对一个图像的均匀散焦模糊进行仿真。</p><p>\4. simulate_motion</p><p> 功能：（线性）运动模糊的仿真。</p><p>\5. wiener_filter</p><p> 功能：通过Wiener滤波进行图像恢复。</p><p>\6. wiener_filter_ni</p><p> 功能：通过Wiener滤波进行图像恢复。</p><h1 id="Chapter-6-Graphics"><a href="#Chapter-6-Graphics" class="headerlink" title="Chapter_6 :Graphics"></a>Chapter_6 :Graphics</h1><h2 id="6-1-Drawing"><a href="#6-1-Drawing" class="headerlink" title="6.1 Drawing"></a>6.1 Drawing</h2><p>\1. drag_region1</p><p> 功能：一个区域的交互运动。</p><p>\2. drag_region2</p><p> 功能：一个带有定点规格区域的交互运动。</p><p>\3. drag_region3</p><p> 功能：一个带有限制位置区域的交互运动。</p><p>\4. draw_circle</p><p> 功能：一个圆的交互绘图。</p><p>\5. draw_circle_mod</p><p> 功能：一个圆的交互绘图。</p><p>\6. draw_ellipse</p><p> 功能：一个椭圆的交互绘图。</p><p>\7. draw_ellipse_mod_</p><p> 功能：一个椭圆的交互绘图。</p><p>\8. draw_line</p><p> 功能：画一根线。</p><p>\9. draw_line_mod</p><p> 功能：画一根线。</p><p>\10. draw_nurbs</p><p>功能：一个NURBS曲线的交互绘图。</p><p>\11. draw_nurbs_interp</p><p>  功能：使用插值的一个NURBS曲线的交互绘图。</p><p>\12. draw_nurbs_interp_mod</p><p>  功能：使用插值的一个NURBS曲线的交互修正。</p><p>\13. draw_nurbs_mod</p><p>  功能：一个NURBS曲线的交互修正。</p><p>\14. draw_point</p><p>  功能：画一个点。</p><p>\15. draw_point_mod</p><p>  功能：画一个点。</p><p>16.draw_polygon</p><p>  功能：一个多边形的交互绘图。</p><p>\17. draw_rectangle1</p><p>  功能：画一个与坐标轴平行的矩形。</p><p>\18. draw_rectangle1_mod</p><p>  功能：画一个与坐标轴平行的矩形。</p><p>\19. draw_rectangle2</p><p>  功能：任意定向矩形的交互绘图。</p><p>\20. draw_rectangle2_mod</p><p>  功能：任意定向矩形的交互绘图。</p><p>\21. draw_region</p><p>  功能：一个闭区域的交互绘图。</p><p>\22. draw_xld</p><p>  功能：一个轮廓的交互绘图。</p><p>\23. draw_xld_mod</p><p>  功能：一个轮廓的交互修正。</p><h2 id="6-2-Gnuplot"><a href="#6-2-Gnuplot" class="headerlink" title="6.2 Gnuplot"></a>6.2 Gnuplot</h2><p>\1. gnuplot_close</p><p> 功能：关闭所有打开的gnuplot文件或者终止一个活动的gnuplot子流程。</p><p>\2. gnuplot_open_file</p><p> 功能：为图像和控制量的可视化打开一个gnuplot文件。</p><p>\3. gnuplot_open_pipe</p><p> 功能：为图像和控制量的可视化打开一个通道的gnuplot流程。</p><p>\4. gnuplot_plot_ctrl</p><p> 功能：使用gnuplot显示控制量。</p><p>\5. gnuplot_plot_funct_1d</p><p> 功能：使用gnuplot显示控制量的功能。</p><p>\6. gnuplot_plot_image</p><p> 功能：使用gnuplot使一个图像可视化。</p><h2 id="6-3-LUT"><a href="#6-3-LUT" class="headerlink" title="6.3 LUT"></a>6.3 LUT</h2><p>\1. disp_lut</p><p> 功能：查询表的图解。</p><p>\2. draw_lut</p><p> 功能：交互利用查询表。</p><p>\3. get_fixed_lut</p><p> 功能：为实际彩色图像获取固定查询表。</p><p>\4. get_lut</p><p> 功能：获取现在的查询表。</p><p>\5. get_lut_style</p><p> 功能：获取查询表的修正参数。</p><p>\6. query_lut</p><p> 功能：查询所有可得到的查询表。</p><p>\7. set_fixed_lut</p><p> 功能：为实际彩色图像固定查询表。</p><p>\8. set_lut</p><p> 功能：设置查询表。</p><p>\9. set_lut_style</p><p> 功能：改变查询表。</p><p>\10. write_lut</p><p> 功能：把查询表作为文件写入。</p><h2 id="6-4-Mouse"><a href="#6-4-Mouse" class="headerlink" title="6.4 Mouse"></a>6.4 Mouse</h2><p>\1. get_mbutton</p><p> 功能：等待直到一个鼠标键被按下。</p><p>\2. get_mposition</p><p>_功能：查询鼠标位置。</p><p>\3. get_mshape</p><p> 功能：查询现在鼠标指针形状。</p><p>\4. query_mshape</p><p> 功能：查询所有可得到的鼠标指针形状。</p><p>\5. set_mshape</p><p> 功能：设置现在鼠标指针形状。</p><h2 id="6-5-Output"><a href="#6-5-Output" class="headerlink" title="6.5 Output"></a>6.5 Output</h2><p>\1. disp_arc</p><p> 功能：在一个窗口中显示圆形弧。</p><p>\2. disp_arrow</p><p> 功能：在一个窗口中显示箭头。</p><p>\3. disp_channel</p><p> 功能：用几个通道显示图像。</p><p>\4. disp_circle</p><p> 功能：在一个窗口中显示圆。</p><p>\5. disp_color</p><p> 功能：显示一个彩色（RGB）图像。</p><p>\6. disp_cross</p><p> 功能：在一个窗口中显示交叉。</p><p>\7. disp_distribution</p><p> 功能：显示一个噪声分布。</p><p>\8. disp_ellipse</p><p> 功能：显示椭圆。</p><p>\9. disp_image</p><p> 功能：显示灰度值图像。</p><p>\10. disp_line</p><p> 功能：在窗口中画一条线。</p><p>\11. disp_obj</p><p>  功能：显示图像目标（图像，区域，XLD）。</p><p>12.disp_polygon</p><p>  功能：显示一个多叉线。</p><p>\13. disp_rectangle1</p><p>  功能：显示和坐标轴对齐的矩形。</p><p>\14. disp_rectangle2</p><p>  功能：显示任意方向的矩形。</p><p>\15. disp_region</p><p>  功能：在一个窗口中显示区域。</p><p>\16. disp_xld</p><p>  功能：显示一个XLD物体。</p><h2 id="6-6-Parameters"><a href="#6-6-Parameters" class="headerlink" title="6.6 Parameters"></a>6.6 Parameters</h2><p>\1. get_comprise</p><p> 功能：获取一个图像矩阵的输出处理。</p><p>\2. get_draw</p><p> 功能：获取现在区域填充模式。</p><p>\3. get_fix</p><p> 功能：获取现在查询表的固定模式。</p><p>\4. get_hsi</p><p> 功能：获取现在颜色的HSI编码。</p><p>\5. get_icon</p><p> 功能：查询区域输出的图标。</p><p>\6. get_insert</p><p> 功能：获取现在显示模式。</p><p>\7. get_line_approx</p><p> 功能：获取轮廓显示的现在近似误差。</p><p>\8. get_line_style</p><p> 功能：获取轮廓的现在图解模式。</p><p>\9. get_line_width</p><p> 功能：获取轮廓显示的现在线宽。</p><p>\10. get_paint</p><p>  功能：获取灰度值的现在显示模式。</p><p>\11. get_part</p><p>  功能：获取图像部分。</p><p>\12. get_part_style</p><p>  功能：获取灰度值显示的现在插值模式。</p><p>\13. get_pixel</p><p> 功能：获取查询表索引的现在颜色。</p><p>\14. get_rgb</p><p>  功能：获取RGB编码中的现在颜色。</p><p>\15. get_shape</p><p>  功能：获取现在区域输出形状。</p><p>\16. query_all_colors</p><p>  功能：查询所有颜色名称。</p><p>\17. query_color</p><p>  功能：查询窗口中显示的所有颜色名称。</p><p>\18. query_colored</p><p>  功能：查询颜色输出的颜色数目。</p><p>\19. query_gray</p><p>  功能：查询显示的灰度值。</p><p>\20. query_insert</p><p>  功能：查询可能的图解模式。</p><p>\21. query_line_width</p><p>  功能：查询可能的线宽。</p><p>\22. query_paint</p><p>  功能：查询灰度值显示模式。</p><p>\23. query_shape</p><p>  功能：查询区域显示模式。</p><p>\24. set_color</p><p>  功能：设置输出颜色。</p><p>\25. set_colored</p><p>  功能：设置多输出颜色。</p><p>\26. set_comprise</p><p>  功能：定义图像矩阵输出剪辑。</p><p>\27. set_draw</p><p>  功能：定义区域填充模式。</p><p>\28. set_fix</p><p>  功能：设置固定的查询表。</p><p>\29. set_gray</p><p>  功能：定义区域输出的灰度值。</p><p>\30. set_hsi</p><p>  功能：定义输出颜色（HSI编码）。</p><p>\31. set_icon</p><p>  功能：区域输出的图标定义。</p><p>\32. set_insert</p><p>  功能：定义图像输出功能。</p><p>\33. set_line_approx</p><p>  功能：定义输出显示的近似误差。</p><p>\34. set_line_style</p><p>  功能：定义一个轮廓输出模式。</p><p>\35. set_line_width</p><p>  功能：定义区域轮廓输出的线宽。</p><p>\36. set_paint</p><p>  功能：定义灰度值输出模式。</p><p>\37. set_part</p><p>  功能：修正显示图像部分。</p><p>\38. set_part_style</p><p>  功能：为灰度值输出定义一个插值方法。</p><p>\39. set_pixel</p><p>  功能：定义一个颜色查询表索引。</p><p>\40. set_rgb</p><p>  功能：通过RGB值设置颜色定义。</p><p>\41. set_shape</p><p>  功能：定义区域输出轮廓。</p><h2 id="6-7-Text"><a href="#6-7-Text" class="headerlink" title="6.7 Text"></a>6.7 Text</h2><p>\1. get_font</p><p> 功能：获取现在字体。</p><p>\2. get_string_extents</p><p> 功能：获取一个字符串的空间大小。</p><p>\3. get_tposition</p><p> 功能：获取光标位置。</p><p>\4. get_tshape</p><p> 功能：获取文本光标的形状。</p><p>\5. new_line</p><p> 功能：设置下一行的开始文本光标的位置。</p><p>\6. query_font</p><p> 功能：查询可得到的字体。</p><p>\7. query_tshape</p><p> 功能：查询文本光标的所有可得到的形状。</p><p>\8. read_char</p><p> 功能：从一个文本窗口读取一个字符。</p><p>\9. read_string</p><p> 功能：从一个文本窗口读取一个字符串。</p><p>\10. set_font</p><p>  功能：设置文本输出的字体。</p><p>\11. set_tposition</p><p>  功能：设置文本光标的位置。</p><p>\12. set_tshape</p><p>  功能：设置文本光标的形状。</p><p>\13. write_string</p><p> 功能：在一个窗口中打印文本。</p><h2 id="6-8-Window"><a href="#6-8-Window" class="headerlink" title="6.8 Window"></a>6.8 Window</h2><p>\1. clear_rectangle</p><p> 功能：在输出窗口中删除一个矩形。</p><p>\2. clear_window</p><p> 功能：删除一个输出窗口。</p><p>\3. close_window</p><p> 功能：关闭一个输出窗口。</p><p>\4. copy_rectangle</p><p> 功能：在输出窗口间复制矩形内所有像素。</p><p>\5. dump_window</p><p> 功能：把窗口内容写入一个文件。</p><p>\6. dump_window_image</p><p> 功能：在一个图像目标中写窗口内容。</p><p>\7. get_os_window_handle</p><p> 功能：获取操作系统图像处理。</p><p>\8. get_window_attr</p><p> 功能：获取窗口特征。</p><p>\9. get_window_extents</p><p> 功能：一个窗口大小和位置的信息。</p><p>\10. get_window_pointer3</p><p>  功能：一个窗口像素数据的通道。</p><p>\11. get_window_type</p><p>  功能：获取窗口类型。</p><p>\12. move_rectangle</p><p>  功能：在一个输出窗口内部复制。</p><p>\13. new_extern_window</p><p>  功能：在Windows_NT下创建一个虚拟图形窗口。</p><p>\14. open_textwindow</p><p>  功能：打开一个文本窗口。</p><p>\15. open_window</p><p>  功能：打开一个图形窗口。</p><p>\16. query_window_type</p><p>  功能：查询所有可得到的窗口类型。</p><p>\17. set_window_attr</p><p>  功能：设置窗口特征。</p><p>\18. set_window_dc</p><p>  功能：设置一个虚拟图形窗口（Windows_NT）的设计背景。</p><p>\19. set_window_extents</p><p>  功能：修正一个窗口的位置和大小。</p><p>\20. set_window_type</p><p>  功能：指定一个窗口类型。</p><p>\21. slide_image</p><p>  功能：两个窗口缓冲区的交互输出。</p><h1 id="Chapter-7-Image"><a href="#Chapter-7-Image" class="headerlink" title="Chapter_7_:Image"></a>Chapter_7_:Image</h1><h2 id="7-1-Access"><a href="#7-1-Access" class="headerlink" title="7.1 Access"></a>7.1 Access</h2><p>\1. get_grayval</p><p> 功能：获取一个图像目标的灰度值。</p><p>\2. get_image_pointer1</p><p> 功能：获取一个通道的指针。</p><p>\3. get_image_pointer1_rect</p><p> 功能：获取图像数据指针和输入图像区域内最小矩形内部的图像数据。</p><p>\4. get_image_pointer3</p><p> 功能：获取一个彩色图像的指针。</p><p>\5. get_image_time</p><p> 功能：查找图像被创建的时间。</p><h2 id="7-2-Acquisition"><a href="#7-2-Acquisition" class="headerlink" title="7.2 Acquisition"></a>7.2 Acquisition</h2><p>\1. close_all_framegrabbers</p><p> 功能：关闭所有图像获取设备。</p><p>\2. close_framegrabber</p><p> 功能：关闭指定的图像获取设备。</p><p>\3. get_framegrabber_lut</p><p> 功能：查找图像获取设备的查询表。</p><p>\4. get_framegrabber_param</p><p> 功能：查找一个图像获取设备的指定参数。</p><p>\5. grab_data</p><p> 功能：从指定的图像获取设备获取图像和预处理图像数据。</p><p>\6. grab_data_async</p><p> 功能：从指定的图像获取设备获取图像和预处理图像数据并且开始下一个异步获取。</p><p>\7. grab_image</p><p> 功能：从指定的图像获取设备获取一个图像。</p><p>\8. grab_image_async</p><p> 功能：从指定的图像获取设备获取一个图像并且开始下一个异步获取。</p><p>\9. grab_image_start</p><p> 功能：从指定的图像获取设备开始下一个异步获取。</p><p>\10. info_framegrabber</p><p>  功能：从指定的图像获取设备查找信息。</p><p>\11. open_framegrabber</p><p>  功能：打开并配置一个图像获取设备。</p><p>\12. set_framegrabber_lut</p><p>  功能：设置图像获取设备查询表。</p><p>\13. set_framegrabber_param</p><p>  功能：设置一个图像获取设备的指定参数。</p><h2 id="7-3-Channel"><a href="#7-3-Channel" class="headerlink" title="7.3 Channel"></a>7.3 Channel</h2><p>\1. access_channel</p><p> 功能：获取一个多通道图像的一个通道。</p><p>\2. append_channel</p><p> 功能：把附加模型（通道）添加到图像上。</p><p>\3. channels_to_image</p><p> 功能：把单通道图像转变为一个多通道图像。</p><p>\4. compose2</p><p> 功能：把两个图像转变为一个两通道图像。</p><p>\5. compose3</p><p> 功能：把三个图像转变为一个三通道图像。</p><p>\6. compose4</p><p> 功能：把四个图像转变为一个四通道图像。</p><p>\7. compose5</p><p>功能：把五个图像转变为一个五通道图像。</p><p>\8. compose6</p><p>功能：把六个图像转变为一个六通道图像。</p><p>\9. compose7</p><p>功能：把七个图像转变为一个七通道图像。</p><p>\10. count_channels</p><p>  功能：计算图像的通道。</p><p>\11. decompose2</p><p>  功能：把一个两通道图像转变为两个图像。</p><p>\12. decompose3</p><p>功能：把一个三通道图像转变为三个图像。</p><p>\13. decompose4</p><p>功能：把一个四通道图像转变为四个图像。</p><p>\14. decompose5</p><p>功能：把一个五通道图像转变为五个图像。</p><p>\15. decompose6</p><p>功能：把一个六通道图像转变为六个图像。</p><p>\16. decompose7</p><p>功能：把一个七通道图像转变为七个图像。</p><p>\17. image_to_channels</p><p>  功能：把一个多通道图像转变为一个通道图像。</p><h2 id="7-4-Creation"><a href="#7-4-Creation" class="headerlink" title="7.4 Creation"></a>7.4 Creation</h2><p>\1. copy_image</p><p> 功能：复制一个图像并为它分配新内存。</p><p>\2. gen_image1</p><p> 功能：从像素的一个指针创建一个图像。</p><p>\3. gen_image1_extern</p><p>功能：从带存储管理的像素的一个指针创建一个图像。</p><p>\4. gen_image1_rect</p><p> 功能：从像素（带存储管理）的指针创建一个矩形区域的图像。</p><p>\5. gen_image3</p><p> 功能：从像素（红、绿、蓝）的三个指针创建一个图像。</p><p>\6. gen_image_const</p><p> 功能：创建一个固定灰度值的图像。</p><p>\7. gen_image_gray_ramp</p><p> 功能：创建一个灰度值阶梯。</p><p>\8. gen_image_interleaved</p><p> 功能：从交叉像素的一个指针创建一个三通道图像。</p><p>\9. gen_image_proto</p><p> 功能：创建一个指定的固定灰度值的图像。</p><p>\10. gen_image_surface_first_order</p><p>  功能：创建一阶多项式的一个弯曲灰度表面。</p><p>\11. gen_image_surface_second_order</p><p>  功能：创建二阶多项式的一个弯曲灰度表面。</p><p>\12. region_to_bin</p><p>  功能：把一个区域转变为一个二进制字节图像。</p><p>\13. region_to_label</p><p>  功能：把区域转变为一个标签图像。</p><p>\14. region_to_mean</p><p>  功能：用它们的平均灰度值绘制区域。</p><h2 id="7-5-Domain"><a href="#7-5-Domain" class="headerlink" title="7.5 Domain"></a>7.5 Domain</h2><p>\1. add_channels</p><p> 功能：把两个灰度值添加到区域中。</p><p>\2. change_domain</p><p> 功能：改变一个图像的定义区间。</p><p>\3. full_domain</p><p> 功能：把一个图像的区域扩大到最大值。</p><p>\4. get_domain</p><p> 功能：获取一个图像的区域。</p><p>\5. rectangle1_domain</p><p> 功能：把一个图像的区域缩小到一个矩形。</p><p>\6. reduce_domain</p><p> 功能：缩小一个图像的区域。</p><h2 id="7-6-Features"><a href="#7-6-Features" class="headerlink" title="7.6 Features"></a>7.6 Features</h2><p>\1. area_center_gray</p><p> 功能：计算一个灰度值图像的区域面积和重心。</p><p>\2. cooc_feature_image</p><p> 功能：计算一个同时出现的矩阵并得出相关灰度值特征。</p><p>\3. cooc_feature_matrix</p><p> 功能：从一个同时出现的矩阵计算灰度值特征。</p><p>\4. elliptic_axis_gray</p><p> 功能：在一个灰度值图像中计算一个区域的方位和主轴。</p><p>\5. entropy_gray</p><p> 功能：确定一个图像的熵和各向异性。</p><p>\6. estimate_noise</p><p> 功能：从一个单一图像估计图像噪声。</p><p>\7. fit_surface_first_order</p><p> 功能：通过一个一阶表面（平面）计算灰度值力矩和近似值。</p><p>\8. fit_surface_second_order</p><p> 功能：通过一个二阶表面（平面）计算灰度值力矩和近似值。</p><p>\9. fuzzy_entropy</p><p> 功能：确定区域的模糊熵。</p><p>\10. fuzzy_perimeter</p><p>  功能：计算一个区域的模糊周长。</p><p>\11. gen_cooc_matrix</p><p>  功能：在一个图像中计算一个区域中同时出现的矩阵。</p><p>\12. gray_histo</p><p>  功能：计算灰度值分布。</p><p>\13. gray_histo_abs</p><p>  功能：计算灰度值分布。</p><p>\14. gray_projections</p><p>  功能：计算水平和垂直灰度值预测。</p><p>\15. histo_2dim</p><p>  功能：计算两通道灰度值图像的直方图。</p><p>\16. intensity</p><p>  功能：计算灰度值的平均值和偏差。</p><p>\17. min_max_gray</p><p>  功能：计算区域内的最大和最小灰度值。</p><p>\18. moments_gray_plane</p><p>  功能：通过一个平面计算灰度值力矩和近似值。</p><p>\19. plane_deviation</p><p>  功能：从近似像平面计算灰度值的偏差。</p><p>\20. select_gray</p><p>  功能：选择基于灰度值特征的区域。</p><p>\21. shape_histo_all</p><p>  功能：用极限值确定特征的一个直方图。</p><p>\22. shape_histo_point</p><p>  功能：用极限值确定特征的一个直方图。</p><h2 id="7-7-Format"><a href="#7-7-Format" class="headerlink" title="7.7 Format"></a>7.7 Format</h2><p>\1. change_format</p><p> 功能：改变图像大小。</p><p>\2. crop_domain</p><p> 功能：去掉确定的灰度值。</p><p>\3. crop_domain_rel</p><p> 功能：去掉和定义域有关的图像区域。</p><p>\4. crop_part</p><p> 功能：去掉一个矩形图像区域。</p><p>\5. crop_rectangle1</p><p> 功能：去掉一个矩形图像区域。</p><p>\6. tile_channels</p><p> 功能：把多重图像拼成一个大图像。</p><p>\7. tile_images</p><p> 功能：把多重图像目标拼成一个大图像。</p><p>\8. tile_images_offset</p><p> 功能：把多重图像目标拼成一个有确定的位置信息的大图像。</p><h2 id="7-8-Manipulation"><a href="#7-8-Manipulation" class="headerlink" title="7.8 Manipulation"></a>7.8 Manipulation</h2><p>\1. overpaint_gray</p><p> 功能：重新绘制一个图像的灰度值。</p><p>\2. overpaint_region</p><p> 功能：重新绘制一个图像的区域。</p><p>\3. paint_gray</p><p> 功能：把一个图像的灰度值画在另一个图像上。</p><p>\4. paint_region</p><p> 功能：把区域画在一个图像中。</p><p>\5. paint_xld</p><p> 功能：把XLD目标画在一个图像中。</p><p>6.set_grayval</p><p> 功能：在一个图像中设置单灰度值。</p><h2 id="7-9-Type-Conversion"><a href="#7-9-Type-Conversion" class="headerlink" title="7.9 Type-Conversion"></a>7.9 Type-Conversion</h2><p>\1. complex_to_real</p><p> 功能：把一个复杂图像转变为两个实际图像。</p><p>\2. convert_image_type</p><p> 功能：转变一个图像的类型。</p><p>\3. real_to_complex</p><p> 功能：把两个实际图像转变为一个复杂图像。</p><p>\4. real_to_vector_field</p><p> 功能：把两个实值图像转变为一个矢量域图像。</p><p>\5. vector_field_to_real</p><p> 功能：把一个矢量域图像转变为两个实值图像。</p><h1 id="Chapter-8-Lines"><a href="#Chapter-8-Lines" class="headerlink" title="Chapter_8_:Lines"></a>Chapter_8_:Lines</h1><h2 id="8-1-Access"><a href="#8-1-Access" class="headerlink" title="8.1 Access"></a>8.1 Access</h2><p>\1. approx_chain</p><p> 功能：通过弧和线近似一个轮廓。</p><p>\2. approx_chain_simple</p><p> 功能：通过弧和线近似一个轮廓。</p><h2 id="8-2-Features"><a href="#8-2-Features" class="headerlink" title="8.2 Features"></a>8.2 Features</h2><p>\1. line_orientation</p><p> 功能：计算线的方位。</p><p>\2. line_position</p><p> 功能：计算一条线的重心、长度和方位。</p><p>\3. partition_lines</p><p> 功能：通过各种标准区分线。</p><p>\4. select_lines</p><p>功能：通过各种标准选择线。</p><p>\5. select_lines_longest</p><p> 功能：选择最长输入线。</p><h1 id="Chapter-9-Matching"><a href="#Chapter-9-Matching" class="headerlink" title="Chapter_9_:Matching"></a>Chapter_9_:Matching</h1><h2 id="9-1-Component-Based"><a href="#9-1-Component-Based" class="headerlink" title="9.1 Component-Based"></a>9.1 Component-Based</h2><p>\1. clear_all_component_models</p><p> 功能：释放所有组件模型的内存。</p><p>\2. clear_all_training_components</p><p> 功能：释放所有组件训练结果的内存。</p><p>\3. clear_component_model</p><p> 功能：释放一个组件模型的内存。</p><p>\4. clear_training_components</p><p> 功能：释放一个组件训练结果的内存。</p><p>\5. cluster_model_components</p><p> 功能：把用于创建模型组件的新参数用于训练结果。</p><p>\6. create_component_model</p><p> 功能：基于确定的指定组件和关系准备一个匹配的组件模型。</p><p>\7. create_trained_component_model</p><p> 功能：基于训练过的组件准备一个匹配的组件模型。</p><p>\8. find_component_model</p><p> 功能：在一个图像中找出一个组件模型的最佳匹配。</p><p>\9. gen_initial_components</p><p> 功能：提取一个组件模型的最初组件。</p><p>\10. get_component_model_params</p><p>  功能：返回一个组件模型的参数。</p><p>\11. get_component_model_tree</p><p>  功能：返回一个组件模型的查找树。</p><p>\12. get_component_relations</p><p>  功能：返回包含在训练结果内的模型组件间的关系。</p><p>\13. get_found_component_model</p><p>  功能：返回一个组件模型的一个创建例子的组件。</p><p>\14. get_training_components</p><p>  功能：在一个特定的图像中返回初始值或者模型组件。</p><p>\15. inspect_clustered_components</p><p>  功能：检查从训练获取的刚性的模型组件。</p><p>\16. modify_component_relations</p><p>  功能：修改一个训练结果中的关系。</p><p>\17. read_component_model</p><p>  功能：从一个文件中读取组件模型。</p><p>\18. read_training_components</p><p>  功能：从一个文件中读取组件训练结果。</p><p>\19. train_model_components</p><p>  功能：为基于组件的匹配训练组件和关系。</p><p>\20. write_component_model</p><p>  功能：把一个组件模型写入一个文件中。</p><p>\21. write_training_components</p><p>  功能：把一个组件训练结果写入一个文件中。</p><h2 id="9-2-Correlation-Based"><a href="#9-2-Correlation-Based" class="headerlink" title="9.2 Correlation-Based"></a>9.2 Correlation-Based</h2><p>\1. clear_all_ncc_models</p><p> 功能：释放NCC模型的内存。</p><p>\2. clear_ncc_model</p><p> 功能：释放NCC模型的内存。</p><p>\3. create_ncc_model</p><p> 功能：为匹配准备一个NCC模型。</p><p>\4. find_ncc_model</p><p> 功能：找出一个图像中的一个NCC模型的最佳匹配。</p><p>\5. get_ncc_model_origin</p><p> 功能：返回一个NCC模型的原点（参考点）。</p><p>\6. get_ncc_model_params</p><p> 功能：返回一个NCC模型的参数。</p><p>\7. read_ncc_model</p><p> 功能：从一个文件中读取一个NCC模型。</p><p>\8. set_ncc_model_origin</p><p> 功能：设置一个NCC模型的原点（参考点）。</p><p>\9. write_ncc_model</p><p> 功能：向一个文件中写入NCC模型。</p><h2 id="9-3-Gray-Value-Based"><a href="#9-3-Gray-Value-Based" class="headerlink" title="9.3 Gray-Value-Based"></a>9.3 Gray-Value-Based</h2><p>\1. adapt_template</p><p> 功能：把一个模板用于一个图像的大小。</p><p>\2. best_match</p><p> 功能：寻找一个模板和一个图像的最佳匹配。</p><p>\3. best_match_mg</p><p> 功能：在金字塔中寻找最佳灰度值匹配。</p><p>\4. best_match_pre_mg</p><p> 功能：在预生成的金字塔中寻找最佳灰度值匹配。</p><p>\5. best_match_rot</p><p> 功能：寻找一个模板和一个旋转图像的最佳匹配。</p><p>\6. best_match_rot_mg</p><p> 功能：寻找一个模板和一个旋转金字塔的最佳匹配。</p><p>\7. clear_all_templates</p><p> 功能：所有模板的内存分配。</p><p>\9. clear_template</p><p>功能：一个模板的内存分配。</p><p>\10. create_template</p><p>  功能：为模板匹配准备一个格式。</p><p>\11. create_template_rot</p><p>  功能：为旋转模板匹配准备一个格式。</p><p>\12. fast_match</p><p>  功能：寻找一个模板和一个图像的所有好的匹配。</p><p>\13. fast_match_mg</p><p>  功能：在金字塔中寻找所有好的灰度值匹配。</p><p>\14. read_template</p><p>  功能：从一个文件中读取一个模板。</p><p>\15. set_offset_template</p><p>  功能：模板的灰度值偏差。</p><p>\16. set_reference_template</p><p>  功能：为一个匹配模板定义参考位置。</p><p>\17. write_template</p><p>  功能：向一个文件中写入模板。</p><h2 id="9-4-Shape-Based"><a href="#9-4-Shape-Based" class="headerlink" title="9.4 Shape-Based"></a>9.4 Shape-Based</h2><p>\1. clear_all_shape_models</p><p> 功能：释放所有轮廓模型的内存。</p><p>\2. clear_shape_model</p><p> 功能：释放一个轮廓模型的内存。</p><p>\3. create_aniso_shape_model</p><p> 功能：为各向异性尺度不变匹配准备一个轮廓模型。</p><p>\4. create_scaled_shape_model</p><p> 功能：为尺度不变匹配准备一个轮廓模型。</p><p>\5. create_shape_model</p><p> 功能：为匹配准备一个轮廓模型。</p><p>\6. determine_shape_model_params</p><p> 功能：确定一个轮廓模型的参数。</p><p>\7. find_aniso_shape_model</p><p> 功能：在一个图像中找出一个各向异性尺度不变轮廓的最佳匹配。</p><p>\8. find_aniso_shape_models</p><p> 功能：找出多重各向异性尺度不变轮廓模型的最佳匹配。</p><p>\9. find_scaled_shape_model</p><p> 功能：在一个图像中找出一个尺度不变轮廓模型的最佳匹配。</p><p>\10. find_scaled_shape_models</p><p>  功能：找出多重尺度不变轮廓模型的最佳匹配。</p><p>\11. find_shape_model</p><p>  功能：在一个图像中找出一个轮廓模型的最佳匹配。</p><p>\12. find_shape_models</p><p>  功能：找出多重轮廓模型的最佳匹配。</p><p>\13. get_shape_model_contours</p><p>  功能：返回一个轮廓模型的轮廓表示。</p><p>\14. get_shape_model_origin</p><p>  功能：返回一个轮廓模型的原点（参考点）。</p><p>\15. get_shape_model_params</p><p>  功能：返回一个轮廓模型的参数。</p><p>\16. inspect_shape_model</p><p>  功能：创建一个轮廓模型的表示。</p><p>\17. read_shape_model</p><p>  功能：从一个文件中读取一个轮廓模型。</p><p>\18. set_shape_model_origin</p><p>  功能：设置一个轮廓模型的原点（参考点）。</p><p>\19. write_shape_model</p><p>  功能：向一个文件中写入一个轮廓模型。</p><h1 id="Chapter-10-Matching-3D"><a href="#Chapter-10-Matching-3D" class="headerlink" title="Chapter_10_:Matching-3D"></a>Chapter_10_:Matching-3D</h1><p>\1. affine_trans_object_model_3d</p><p>功能：把一个任意有限3D变换用于一个3D目标模型。</p><p>\2. clear_all_object_model_3d</p><p> 功能：释放所有3D目标模型的内存。</p><p>\3. clear_all_shape_model_3d</p><p> 功能：释放所有3D轮廓模型的内存。</p><p>\4. clear_object_model_3d</p><p> 功能：释放一个3D目标模型的内存。</p><p>\5. clear_shape_model_3d_</p><p> 功能：释放一个3D轮廓模型的内存。</p><p>\6. convert_point_3d_cart_to_spher</p><p> 功能：把直角坐标系中的一个3D点转变为极坐标。</p><p>\7. convert_point_3d_spher_to_cart</p><p> 功能：把极坐标中的一个3D点转变为直角坐标。</p><p>\8. create_cam_pose_look_at_point</p><p> 功能：从摄像机中心和观察方向创建一个3D摄像机位置。</p><p>\9. create_shape_model_3d</p><p> 功能：为匹配准备一个3D目标模型。</p><p>\10. find_shape_model_3d</p><p>  功能：在一个图像中找出一个3D模型的最佳匹配。</p><p>\11. get_object_model_3d_params</p><p> 功能：返回一个3D目标模型的参数。</p><p>\12. get_shape_model_3d_contours</p><p>  功能：返回一个3D轮廓模型视图的轮廓表示。</p><p>\13. get_shape_model_3d_params</p><p> 功能：返回一个3D轮廓模型的参数。</p><p>\14. project_object_model_3d</p><p>  功能：把一个3D目标模型的边缘投影到图像坐标中。</p><p>\15. project_shape_model_3d</p><p>  功能：把一个3D轮廓模型的边缘投影到图像坐标中。</p><p>\16. read_object_model_3d_dxf</p><p>  功能：从一个DXF文件中读取一个3D目标模型。</p><p>\17. read_shape_model_3d</p><p> 功能：从一个文件中读取一个3D轮廓模型。</p><p>\18. trans_pose_shape_model_3d</p><p>  功能：把一个3D目标模型的坐标系中的位置转变为一个3D轮廓模型的参考坐标系中的位置，反之亦然。</p><p>\19. write_shape_model_3d</p><p>  功能：向一个文件写入一个3D轮廓模型。</p><h1 id="Chapter-11-Morphology"><a href="#Chapter-11-Morphology" class="headerlink" title="Chapter_11_:Morphology"></a>Chapter_11_:Morphology</h1><h2 id="11-1-Gray-Values"><a href="#11-1-Gray-Values" class="headerlink" title="11.1 Gray-Values"></a>11.1 Gray-Values</h2><p>\1. dual_rank</p><p> 功能：打开、取中值和关闭圆和矩形掩码。</p><p>\2. gen_disc_se</p><p> 功能：为灰度形态学生成椭圆结构基础。</p><p>\3. gray_bothat</p><p> 功能：执行一个图像的一个灰度值bottom_hat变换（原图像和它的闭之间的差）。</p><p>\4. gray_closing</p><p> 功能：关闭一个图像的一个灰度值。</p><p>\5. gray_closing_rect</p><p> 功能：关闭带矩形掩码的灰度值。</p><p>\6. gray_cl_osing_shape</p><p> 功能：关闭带选择掩码的灰度值。</p><p>\7. gray_dilation</p><p> 功能：扩大一个图像上的灰度值。</p><p>\8. gray_dilation_rect</p><p> 功能：确定一个矩形的最小灰度值。</p><p>\9. gray_dilation_shape</p><p> 功能：确定一个选择的掩码的最大灰度值。</p><p>\10. gray_erosion</p><p>  功能：腐蚀一个图像的灰度值。</p><p>\11. gray_erosion_rect</p><p>  功能：确定一个矩形的最小灰度值。</p><p>\12. gray_erosion_shape</p><p>  功能：确定一个选择的掩码的最小灰度值。</p><p>\13. gray_opening</p><p>  功能：打开一个图像的灰度值。</p><p>\14. gray_opening_rect</p><p>  功能：打开一个矩形掩码的灰度值。</p><p>\15. gray_openin_g_shape</p><p>  功能：打开一个选择的掩码的灰度值。</p><p>\16. gray_range_rect</p><p>  功能：确定一个矩形的灰度值范围。</p><p>\17. gray_tophat</p><p>  功能：执行一个图像的一个灰度值top_hat变换（原图像和它的开之间的差）。</p><p>\18. read_gray_se</p><p>  功能：为灰度形态学下载一个结构基础。</p><h2 id="11-2-Region"><a href="#11-2-Region" class="headerlink" title="11.2 Region"></a>11.2 Region</h2><p>\1. bottom_hat</p><p> 功能：计算区域的bottom_hat（原图像和它的闭之间的差）。</p><p>\2. boundary</p><p> 功能：把一个区域减小到它的边界。</p><p>\3. closing</p><p> 功能：关闭一个区域。</p><p>\4. closing_circle</p><p> 功能：关闭一个圆形结构基础的一个区域。</p><p>\5. closing_golay</p><p> 功能：关闭格雷字母表中的元素的一个区域。</p><p>\6. closing_rectangle1</p><p> 功能：关闭一个矩形结构基础的一个区域。</p><p>\7. dilation1</p><p> 功能：扩大一个区域。</p><p>\8. dilation2</p><p> 功能：扩大一个区域（使用一个参考点）。</p><p>\9. dilation_circle</p><p> 功能：扩大一个圆形结构基础的一个区域。</p><p>\10. dilation_golay</p><p>  功能：扩大格雷字母表的元素的一个区域。</p><p>\11. dilation_rectangle1</p><p>  功能：扩大一个矩形结构基础的一个区域。</p><p>\12. dilation_seq</p><p>  功能：顺序地扩大一个区域。</p><p>\13. erosion1</p><p>  功能：腐蚀一个区域。</p><p>\14. erosion2</p><p>  功能：腐蚀一个区域（使用参考点）。</p><p>\15. erosion_circle</p><p>  功能：腐蚀一个圆形结构基础的一个区域。</p><p>\16. erosion_golay</p><p>  功能：腐蚀格雷字母表的一个元素的一个区域。</p><p>\17. erosion_rectangle1</p><p>  功能：腐蚀一个矩形结构基础的一个区域。</p><p>\18. erosion_seq</p><p>  功能：按顺序腐蚀一个区域。</p><p>\19. fitting</p><p>  功能：执行多重结构基础的打开后关闭。</p><p>\20. gen_struct_elements</p><p>  功能：生成一个标准结构基础。</p><p>\21. golay_elements</p><p>  功能：生成格雷字母表的结构基础。</p><p>\22. hit_or_miss</p><p>  功能：区域的Hit-or-miss运行。</p><p>\23. hit_or_miss_golay</p><p>  功能：使用格雷字母表的区域的Hit-or-miss运行。</p><p>\24. hit_or_miss_seq</p><p>  功能：使用格雷字母表的区域的Hit-or-miss运行（按顺序）。</p><p>\25. minkowski_add1</p><p>  功能：执行一个区域的Minkowski添加。</p><p>\26. minkowski_add2</p><p>  功能：扩大一个区域（使用参考点）。</p><p>\27. minkowski_sub1</p><p>  功能：腐蚀一个区域。</p><p>\28. minkowski_sub2</p><p>  功能：腐蚀一个区域（使用参考点）。</p><p>\29. morph_hat</p><p>  功能：计算bottom_hat_和top_hat的联合。</p><p>\30. morph_skeleton</p><p>  功能：计算一个区域的形态学框架。</p><p>\31. morph_skiz</p><p>  功能：缩小一个区域。</p><p>\32. opening</p><p>  功能：打开一个区域。</p><p>\33. opening_circle</p><p>  功能：打开一个圆形结构基础的一个区域。</p><p>\34. opening_golay</p><p>  功能：打开格雷字母表的一个元素的一个区域。</p><p>\35. opening_rectangle1</p><p>  功能：打开一个矩形结构基础的一个区域。</p><p>\36. opening_seg</p><p>  功能：分离重叠区域。</p><p>\37. pruning</p><p>  功能：去掉一个区域的分支。</p><p>\38. thickening</p><p>  功能：把一个Hit-or-miss运行的结果添加到一个区域。</p><p>\39. thickening_golay</p><p>  功能：把一个Hit-or-miss运行的结果添加到一个区域中（使用一个Golay结构基础）。</p><p>\40. thickening_seq</p><p>  功能：把一个Hit-or-miss运行的结果添加到一个区域中（按顺序）。</p><p>\41. thinning</p><p>  功能：从一个区域移去一个Hit-or-miss运行的结果。</p><p>\42. thinning_golay</p><p>  功能：从一个区域移去一个Hit-or-miss运行的结果（使用一个Golay结构基础）。</p><p>\43. thinning_seq</p><p>  功能：从一个区域移去一个Hit-or-miss运行的结果（按顺序）。</p><p>\44. top_hat</p><p>  功能：计算区域的top_hat（原图像和它的开之间的差）。</p><h1 id="Chapter-12-OCR（光字符识别）"><a href="#Chapter-12-OCR（光字符识别）" class="headerlink" title="Chapter_12:OCR（光字符识别）"></a>Chapter_12:OCR（光字符识别）</h1><h2 id="12-1-Hyperboxes"><a href="#12-1-Hyperboxes" class="headerlink" title="12.1 Hyperboxes"></a>12.1 Hyperboxes</h2><p>\1. close_all_ocrs</p><p> 功能：删除所有光字符，释放存储空间，但会丢失所有的测试数据。</p><p>\2. close_ocr_</p><p> 功能：重新分配拥有OcrHandle数目的分级器的存储，但所有相应的数据会丢失，不过这些数据可由write ocr事先保存。</p><p>\3. create_ocr_class_box</p><p> 功能：创建新的OCR分级器。</p><p>\4. do_ocr_multi</p><p> 功能：给每一个Character（字符）分配一个类。</p><p>\5. do_ocr_single</p><p> 功能：给一些Character（字符）分配一些类。</p><p>\6. info_ocr_class_box</p><p> 功能：反馈ocr的有关信息。</p><p>\7. ocr_change_char</p><p> 功能：为字符建立新的查阅表。</p><p>\8. ocr_get_features</p><p> 功能：计算给定Character（字符）的特征参数。</p><p>\9. read_ocr</p><p> 功能：从文件的FileName（文件名）读取OCR分级器。</p><p>\10. testd_ocr_class_box</p><p> 功能：测试给定类中字符的置信度。</p><p>\11. traind_ocr_class_box</p><p> 功能：通过一幅图像的特定区域直接测试分级器。</p><p>\12. trainf_ocr_class_box</p><p> 功能：根据指定测试文件测试分级器的OCRHandle。</p><p>\13. write_ocr</p><p>  功能：将OCR分级器的OCRHandle写入文件的FileName（文件名）。</p><h2 id="12-2-Lexica"><a href="#12-2-Lexica" class="headerlink" title="12.2 Lexica"></a>12.2 Lexica</h2><p>1.clear_all_lexica</p><p>  功能：清除所有的词汇（词典），释放它们的资源。</p><p>\2. clear_lexicon</p><p>  功能：清除一个词汇（词典），释放相应的资源。</p><p>\3. create_lexicon</p><p>  功能：根据一些Words(单词)的元组创建一个新的词汇（词典）。</p><p>4．Import_lexicon</p><p>  功能：通过FileName(文件名)选定的文件中的一系列单词创建一个新的词典。</p><p>\5. inspect_lexicon</p><p>  功能：返回Words参数的词典中所有单词的元组。</p><p>\6. lookup_lexicon</p><p>  功能：检查Word（单词）是否在词典的LexiconHandle中，若在返回1否则返回0。</p><p>\7. suggest_lexicon</p><p>  功能：将Word（单词）与词典中所有词汇相比较，计算出将Word从词典中导入单词中所需的足校的编辑操作符NUMcorrections。</p><h2 id="12-3-Neural-Nets（神经网络）"><a href="#12-3-Neural-Nets（神经网络）" class="headerlink" title="12.3 Neural-Nets（神经网络）"></a>12.3 Neural-Nets（神经网络）</h2><p>\1. clear_all_ocr_class_mlp</p><p>  功能：清除所有的create ocr class mlp创建的OCR分级器，释放分级器占据的存储空间。</p><p>\2. clear_ocr_class_mlp</p><p>  功能：清除所有的由OCRHandle给定的且由create ocr class mlp创建的OCR分级器，释放所有的分级器占据的存储空间。</p><p>\3. create_ocr_class_mlp</p><p>  功能：利用MLP（多层感知器）创建一个新的OCR分级器。</p><p>\4. do_ocr_multi_class_mlp</p><p>  功能：为根据给定区域字符和OCR分级器OCRHandle的灰度图像值而给定的每个字符计算出最好的类，将类返回到Class中，且将类的置信度返回到Confidence中。</p><p>\5. do_ocr_single_class_mlp</p><p>  功能：为根据给定区域字符和OCR分级器OCRHandle的灰度图像值而给定的字符计算出最好的Num类，将类返回到Class中，且将类的置信度返回到Confidence中。</p><p>\6. do_ocr_word_mlp</p><p>  功能：功能与do ocr multi class mlp相同，只是do_ocr_word_mlp将字符组作为一个实体。</p><p>7.get_features_ocr_class_mlp</p><p>  功能：为根据OCR分级器OCRHandle确定的字符计算其特征参数，并将它们返回到Features。</p><p>\8. get_params_ocr_class_mlp</p><p>  功能：返回一个OCR分级器的参数只有当分级器由do_ocr_multi_class_mlp创建时。</p><p>\9. get_prep_info_ocr_class_mlp</p><p>  功能：计算OCR分级器预设定矢量特性的信息。</p><p>\10. read_ocr_class_mlp</p><p>  功能：从一个文件中读取OCR分级器。</p><p>\11. trainf_ocr_class_mlp</p><p>  功能：测试OCR分级器的OCRHandle，根据存储在OCR文件中的测试特性。</p><p>\12. write_ocr_class_mlp</p><p>  功能：将OCR分级器的OCRHandle写入由文件名确定的文件中。</p><h2 id="12-4-Support-Vector-Machines-（支持矢量机）"><a href="#12-4-Support-Vector-Machines-（支持矢量机）" class="headerlink" title="12.4 Support-Vector-Machines_（支持矢量机）"></a>12.4 Support-Vector-Machines_（支持矢量机）</h2><p>\1. clear_all_ocr_class_svm</p><p>  功能：清除所有的基于OCR分级器的SVM，释放相应的存储空间。</p><p>\2. clear_ocr_class_svm</p><p>  功能：清除基于OCR分级器的一个SVM，释放相应的存储空间。</p><p>\3. create_ocr_class_svm</p><p>  功能：利用支持向量机创建一个OCR分级器。</p><p>\4. do_ocr_multi_class_svm</p><p> 功能：根据基于OCR分级器的SVM将大量字符分类。</p><p>\5. do_ocr_single_class_svm</p><p> 功能：根据基于OCR分级器的SVM将单个字符分类。</p><p>\6. do_ocr_word_svm</p><p> 功能：利用OCR分级器将一系列相关字符分类。</p><p>\7. get_features_ocr_class_svm</p><p> 功能：计算一个字符的特征。</p><p>\8. get_params_ocr_class_svm</p><p>_功能：返回一个OCR分级器的参数。</p><p>\9. get_prep_info_ocr_class_svm</p><p> 功能：计算基于OCR分级器的SVM的预定义特征矢量的信息内容。</p><p>\10. get_support_vector_num_ocr_class_svm</p><p>  功能：返回OCR分级器支持的矢量的数目。</p><p>\11. get_support_vector_ocr_class_svm</p><p>  功能：返回基于支持向量机的已测试OCR分级器中支持向量的索引。</p><p>\12. read_ocr_class_svm</p><p>  功能：从文件中读取基于OCR分级器的SVM。</p><p>\13. reduce_ocr_class_svm</p><p>  功能：根据一个减小的SVM来接近一个基于OCR分级器的SVM。</p><p>14．Trainf_ocr_class_svm</p><p>功能：测试一个OCR分级器。</p><p>\15. write_ocr_class_svm</p><p>  功能：将一个OCR分级器写入文件。</p><h2 id="12-5-Tools"><a href="#12-5-Tools" class="headerlink" title="12.5 Tools"></a>12.5 Tools</h2><p>1．Segment_characters</p><p> 功能：将一副图像给定区域的字符分割。</p><p>\2. select_characters</p><p> 功能：从一个给定区域中选择字符。</p><p>3．text_line_orientation</p><p>  功能：决定一个文本行或段落的定向（定位）。</p><p>4．text_line_slant</p><p> 功能：决定一个文本行或段落的字符的倾斜。</p><h2 id="12-6-Training-Files"><a href="#12-6-Training-Files" class="headerlink" title="12.6 Training-Files"></a>12.6 Training-Files</h2><p>\1. append_ocr_trainf</p><p> 功能：将字符添加到一个测试文件中。</p><p>\2. concat_ocr_trainf</p><p> 功能：合并测试文件。</p><p>3．read_ocr_trainf</p><p>  功能：从文件中读取字符，将其转换到图像中。</p><p>\4. read_ocr_trainf_names</p><p> 功能：查询哪些字符存储在测试文件中。</p><p>5．read_ocr_trainf_select</p><p>  功能：从文件中读取测试特定字符，将其转换到图像中。</p><p>\6. write_ocr_trainf</p><p> 功能：将已测试的字符存储到文件中。</p><p>\7. write_ocr_trainf_image</p><p> 功能：将字符写入正在测试的文件中。</p><h1 id="Chapter-13-Object"><a href="#Chapter-13-Object" class="headerlink" title="Chapter_13:Object"></a>Chapter_13:Object</h1><h2 id="13-1-Information"><a href="#13-1-Information" class="headerlink" title="13.1 Information"></a>13.1 Information</h2><p>\1. count_obj</p><p> 功能：统计一个元组中的对象。</p><p>\2. get_channel_info</p><p> 功能：一幅目标图像组成部分的信息。</p><p>\3. get_obj_class</p><p> 功能：一副目标图像类的名称。</p><p>4．test_equal_obj</p><p>  功能：比较目标图像的平等性。</p><p>\5. test_obj_def</p><p> 功能：测试目标是否被删除。</p><h2 id="13-2-Manipulation"><a href="#13-2-Manipulation" class="headerlink" title="13.2 Manipulation"></a>13.2 Manipulation</h2><p>\1. clear_obj</p><p> 功能：将一个对象的图标从HALCON数据库中删除。</p><p>\2. concat_obj</p><p> 功能：连接两个目标元组的图标。</p><p>\3. copy_obj</p><p> 功能：复制一个HALCON数据库中对象的图标_。</p><p>\4. gen_empty_obj</p><p> 功能：创建一个空的目标元组。</p><p>5．integer_to_obj</p><p>  功能：将一个整型数转换为一个图标。</p><p>\6. obj_to_integer</p><p> 功能：将一个图标转换为一个整型数。</p><p>\7. select_obj</p><p> 功能：从一个目标元组中选择目标。</p><h1 id="Chapter-14-Regions"><a href="#Chapter-14-Regions" class="headerlink" title="Chapter_14:Regions"></a>Chapter_14:Regions</h1><h2 id="14-1-Access"><a href="#14-1-Access" class="headerlink" title="14.1 Access"></a>14.1 Access</h2><p>\1. get_region_chain</p><p> 功能：一个对象的轮廓(contour)作为链式码。</p><p>\2. get_region_contour</p><p> 功能：查询一个目标的轮廓(contour)。</p><p>\3. get_region_convex</p><p> 功能：查询突起的外表作为轮廓(contour)。</p><p>\4. get_region_points</p><p> 功能：查询一个区域的像素数。</p><p>\5. get_region_polygon</p><p> 功能：用一个多边形近似获取区域。</p><p>\6. get_region_runs</p><p> 功能：查询一个区域的扫描宽度编码。</p><h2 id="14-2-Creation"><a href="#14-2-Creation" class="headerlink" title="14.2 Creation"></a>14.2 Creation</h2><p>\1. gen_checker_region</p><p> 功能：创建一个方格式区域。</p><p>\2. gen_circle</p><p> 功能：创建一个圆周。</p><p>\3. gen_ellipse</p><p> 功能：创建一个椭圆。</p><p>\4. gen_empty_region</p><p> 功能：创建一个空的区域。</p><p>\5. gen_grid_region</p><p> 功能：根据行或像素数创建一个区域_。</p><p>\6. gen_random_region</p><p> 功能:创建一个随机区域。</p><p>\7. gen_random_regions</p><p> 功能：创建随机区域如圆周，矩形和椭圆。</p><p>\8. gen_rectangle1</p><p> 功能：创建一个与坐标轴平行的长方形。</p><p>\9. gen_rectangle2</p><p> 功能：创建任意方向的矩形。</p><p>\10. gen_region_contour_xld</p><p>  功能：从XLD元组中创建一个区域。</p><p>\11. gen_region_histo</p><p>  功能：将一个直方图转换为一个区域。</p><p>\12. gen_region_hline</p><p>  功能：将Hesse正规形状中描述的输入线存储为区域。</p><p>\13. gen_region_line</p><p>  功能：将输入线以区域形式存储。</p><p>\14. gen_region_points</p><p>  功能：将个别的像素存储为图像区域。</p><p>\15. gen_region_polygon</p><p>  功能：将一个多边形存储为一个目标图像。</p><p>\16. gen_region_polygon_filled</p><p>  功能：将一个多边形存储为一个已填充区域。</p><p>\17. gen_region_polygon_xld</p><p>  功能：创建一个XLD多边形中的区域。</p><p>\18. gen_region_runs</p><p>  功能：创建一个扫描宽度编码中的图像区域。</p><p>\19. label_to_region</p><p>  功能：提取一幅图像中灰度值相同的区域。</p><h2 id="14-3-Features-形状特征"><a href="#14-3-Features-形状特征" class="headerlink" title="14.3 Features 形状特征"></a>14.3 Features 形状特征</h2><p>\1. area_center</p><p> 功能：一个区域的面积（大小）和中心。</p><p>\2. circularity</p><p> 功能：影响一个区域与圆的相似度的形状系数。</p><p>\3. compactness</p><p> 功能：影响一个区域致密度的形状系数。</p><p>\4. connect_and_holes</p><p> 功能：连接部分和中断的数目。</p><p>\5. contlength</p><p> 功能：描述一个区域轮廓(contour)的长度。</p><p>\6. convexity</p><p> 功能：影响一个区域凸性的形状系数。</p><p>\7. diameter_region</p><p> 功能：一个区域两个边界点的最大距离。</p><p>\8. eccentricity</p><p> 功能：来源于椭圆参数的形状系数。</p><p>\9. elliptic_axis</p><p> 功能：相似椭圆的参数。</p><p>10．euler_number</p><p>功能：计算Euler数目。</p><p>\11. find_neighbors</p><p>  功能：搜寻直接邻域。</p><p>\12. get_region_index</p><p>  功能：包括给定像素在内的所有的区域的索引。</p><p>\13. get_region_thickness</p><p>  功能：查询主轴附近区域的宽度（厚度）。</p><p>\14. hamming_distance</p><p>  功能：两个区域间的汉明距离。</p><p>\15. hamming_distance_norm</p><p>  功能：两个区域间的归一化汉明距离。</p><p>\16. inner_circle</p><p>  功能：一个区域内部最大的圆周。</p><p>\17. inner_rectangle1</p><p>  功能：一个区域内部最大的矩形。</p><p>\18. moments_region_2nd</p><p>  功能：区域的某时刻几何特性，。</p><p>\19. moments_region_2nd_invar</p><p>  功能：区域的某时刻几何特性。</p><p>\20. moments_region_2nd_rel_invar</p><p>  功能：计算相关时刻参数。</p><p>\21. moments_region_3rd</p><p>  功能：区域的某时刻几何特性。</p><p>\22. moments_region_3rd_invar</p><p>  功能：区域的某时刻几何特性。</p><p>\23. moments_region_central</p><p>  功能：区域的某时刻几何特性。</p><p>\24. moments_region_central_invar</p><p>  功能：区域的某时刻几何特性。</p><p>\25. orientation_region</p><p>  功能：一个区域的定向。</p><p>\26. rectangularity</p><p>  功能：影响一个区域矩形相似度的形状系数。</p><p>\27. roundness</p><p>  功能：轮廓中获取的形状系数。</p><p>28.runlength_distribution</p><p>功能：一个区域扫描宽度编码所需的顺串的分配。</p><p>\29. runlength_features</p><p>  功能：区域扫描宽度编码的特征值。</p><p>\30. select_region_point</p><p> 功能：选择包括给定像素在内的所有区域。</p><p>\31. select_region_spatial</p><p>  功能：讨论区域的关联性。</p><p>\32. select_shape</p><p>  功能：根据图形特征选择区域。</p><p>\33. select_shape_proto</p><p>  功能：选择彼此有某种关系的区域。</p><p>\34. select_shape_std</p><p>  功能：选择给定形状的区域。</p><p>\35. smallest_circle</p><p>  功能：一个区域的最小周长。</p><p>\36. smallest_rectangle1</p><p>  功能：平行于坐标轴的包围某区域的矩形。</p><p>\37. smallest_rectangle2</p><p>  功能：任意方向包围某区域的最小矩形。</p><p>\38. spatial_relation</p><p>  功能：根据坐标轴方向左、右、上、下排列相关区域。</p><h2 id="14-4-Geometric-Transformations"><a href="#14-4-Geometric-Transformations" class="headerlink" title="14.4 Geometric-Transformations"></a>14.4 Geometric-Transformations</h2><p>\1. affine_trans_region</p><p> 功能：对区域进行任意的二维变换。</p><p>\2. mirror_region</p><p> 功能：反馈一个平行于X或Y坐标轴的区域。</p><p>\3. move_region</p><p> 功能：对区域进行变换。</p><p>\4. polar_trans_region</p><p> 功能：将一个环状弧内的区域转换为极坐标。</p><p>\5. polar_trans_region_inv</p><p> 功能：将极坐标中的区域转换为笛卡尔坐标中的区域。</p><p>\6. projective_trans_region</p><p> 功能：对一个区域进行射影变换。</p><p>\7. transpose_region</p><p> 功能：翻译关于一个点的一个区域。</p><p>\8. zoom_region</p><p> 功能：缩放一个区域。</p><h2 id="14-5-Sets"><a href="#14-5-Sets" class="headerlink" title="14.5 Sets"></a>14.5 Sets</h2><p>\1. complement</p><p> 功能：返回一个区域的补码。</p><p>\2. difference</p><p> 功能：计算两个区域的差距（不同）。</p><p>\3. intersection</p><p>  功能：计算两个区域的交集。</p><p>\4. symm_difference</p><p> 功能：计算两个区域对称差异。</p><p>\5. union1</p><p> 功能：返回所有输入区域的并集。</p><p>\6. union2</p><p> 功能：返回两个区域的并集。</p><h2 id="14-6-Tests"><a href="#14-6-Tests" class="headerlink" title="14.6 Tests"></a>14.6 Tests</h2><p>\1. test_equal_region</p><p> 功能：检测两个目标区域是否相同。</p><p>\2. test_subset_region</p><p> 功能：检测一个区域是否包含在另一个区域中。</p><h2 id="14-7-Transformation"><a href="#14-7-Transformation" class="headerlink" title="14.7 Transformation"></a>14.7 Transformation</h2><p>\1. background_seg</p><p> 功能：决定给定区域背景相连的部分。</p><p>\2. clip_region</p><p> 功能：将一个区域修改为矩形。</p><p>\3. clip_region_rel</p><p> 功能：根据大小修改一个区域。</p><p>\4. connection</p><p> 功能：计算一个区域相连接的部分。</p><p>\5. distance_transform</p><p> 功能：计算一个区域的距离变换。</p><p>\6. eliminate_runs</p><p> 功能：消除一个给定宽度的顺串。</p><p>\7. expand_region</p><p> 功能：填充区域间的间隙或分离互相重叠的区域。</p><p>8．fill_up</p><p>  功能：填充区域中的中断（裂缝等）。</p><p>\9. fill_up_shape</p><p> 功能：填充拥有给定图形特征区域的中断。</p><p>\10. hamming_change_region</p><p>  功能：创建一个有给定汉明距离的区域。</p><p>\11. interjacent</p><p>  功能：利用给定区域分割图像。</p><p>\12. junctions_skeleton</p><p>  功能：找到框架中的结点和终点。</p><p>\13. merge_regions_line_scan</p><p>  功能：从行扫描图像合并区域。</p><p>14．partition_dynamic</p><p>  功能：在较小垂直范围的位置水平分割一个区域。</p><p>\15. partition_dynamic</p><p>  功能：将一个区域分割为等大的矩形。</p><p>\16. rank_region</p><p>  功能：给对区域的操作归类。</p><p>\17. remove_noise_region</p><p>  功能：去除一个区域内的噪声。</p><p>\18. shape_trans</p><p>  功能：改变一个区域的形状。</p><p>\19. skeleton</p><p>  功能：计算一个区域的框架。</p><p>\20. sort_region</p><p>  功能：根据相邻位置归类区域。</p><p>\21. split_skeleton_lines</p><p>  功能：用一个像素宽，没有分支的线来分离线。</p><p>\22. split_skeleton_region</p><p>  功能：用一个像素宽，没有分支的区域来分离线。</p><h1 id="Chapter-15-Segmentation"><a href="#Chapter-15-Segmentation" class="headerlink" title="Chapter_15:Segmentation"></a>Chapter_15:Segmentation</h1><h2 id="15-1-Classiﬁcation"><a href="#15-1-Classiﬁcation" class="headerlink" title="15.1 Classiﬁcation"></a>15.1 Classiﬁcation</h2><p>\1. add_samples_image_class_gmm</p><p> 功能：将从图像中获取的测试样本添加到高斯混合模型的测试数据库中。</p><p>2．add_samples_image_class_mlp</p><p>  功能：将从图像中获取的测试样本添加到多层视感控器的测试数据库中。</p><p>\3. add_samples_image_class_svm</p><p> 功能：将从图像中获取的测试样本添加到一个支持向量机的测试数据库中。</p><p>\4. class_2dim_sup</p><p> 功能：采用二维空间像素分类分割图像。</p><p>\5. class_2dim_unsup</p><p> 功能：将两幅图像以聚类分割。</p><p>6.class_ndim_box</p><p>  功能：利用立方体将像素分类。</p><p>\7. class_ndim_norm</p><p> 功能：利用球体或立方体将像素分类。</p><p>\8. classify_image_class_gmm</p><p> 功能：根据高斯混合模式分类图像。</p><p>\9. classify_image_class_mlp</p><p> 功能：根据多层视感控器分类图像_。</p><p>\10. classify_image_class_svm</p><p> 功能：根据支持向量机分类图像。</p><p>\11. learn_ndim_box</p><p>  功能：利用多通道图像测试一个分级器。</p><p>\12. learn_ndim_norm</p><p>  功能：为class_ndim_norm构建类。</p><h2 id="15-2-Edges"><a href="#15-2-Edges" class="headerlink" title="15.2 Edges"></a>15.2 Edges</h2><p>\1. detect_edge_segments</p><p> 功能：检测直线边缘分割。</p><p>\2. hysteresis_threshold</p><p> 功能：对一副图像采取磁滞门限操作。</p><p>\3. nonmax_suppression_amp</p><p> 功能：抑制一幅图像上的非最大值点。</p><p>\4. nonmax_suppression_dir</p><p> 功能：利用指定图像抑制一幅图像上的非最大值点。</p><h2 id="15-3-Regiongrowing"><a href="#15-3-Regiongrowing" class="headerlink" title="15.3 Regiongrowing"></a>15.3 Regiongrowing</h2><p>\1. expand_gray</p><p> 功能：依据灰度值或颜色填充两个区域的间隙或分割重叠区域。</p><p>\2. expand_gray_ref</p><p> 功能：依据灰度值或颜色填充两个区域的间隙或分割重叠区域。</p><p>\3. expand_line</p><p> 功能：从给定线开始扩充区域。</p><p>\4. regiongrowing</p><p> 功能：利用区域增长分割图像。</p><p>\5. regiongrowing_mean</p><p> 功能：利用平均灰度值执行区域增长。</p><p>\6. regiongrowing_n</p><p> 功能：利用区域增长为多通道图像分割图像。</p><h2 id="15-4-Threshold"><a href="#15-4-Threshold" class="headerlink" title="15.4 Threshold"></a>15.4 Threshold</h2><p>\1. auto_threshold</p><p> 功能：根据直方图决定的阀值分割图像。</p><p>\2. bin_threshold</p><p> 功能：根据自动产生的阀值分割图像。</p><p>\3. char_threshold</p><p> 功能：为提取的字符产生一个分割阀值。</p><p>\4. check_difference</p><p> 功能：一个像素一个像素的比较两幅图像。</p><p>\5. dual_threshold</p><p> 功能：对标记的图像做门限操作。_</p><p>\6. dyn_threshold</p><p> 功能：利用局域阀值分割图像。</p><p>\7. fast_threshold</p><p> 功能：利用全局阀值快速将图像二值化。</p><p>\8. histo_to_thresh</p><p> 功能：根据直方图决定灰度值门限。</p><p>\9. threshold</p><p> 功能：利用全局阀值分割图像。</p><p>\10. threshold_sub_pix</p><p>  功能：根据子像素的准确性从一副图像中提取水平（平坦）交叉口。</p><p>\11. var_threshold</p><p>  功能：根据局域平均标准偏差分析将图像二值化。</p><p>\12. zero_crossing</p><p>  功能：从一幅图像中提取零相交。</p><p>\13. zero_crossing_sub_pix</p><p>  功能：根据子像素准确性从一幅图像中提取零相交。</p><h2 id="15-5-Topography"><a href="#15-5-Topography" class="headerlink" title="15.5 Topography"></a>15.5 Topography</h2><p>\1. critical_points_sub_pix</p><p> 功能：一幅图像中主要点的子像素精确度检测。</p><p>\2. local_max</p><p> 功能：检测一幅图像中所有的最大数。</p><p>\3. local_max_sub_pix</p><p> 功能：一幅图像中局域最大数的子像素精确度检测。</p><p>4_.local_min</p><p> 功能：检测一幅图像中所有的最小数。</p><p>\5. local_min_sub_pix</p><p> 功能：一幅图像中局域最小数的子像素精确度检测。</p><p>\6. lowlands</p><p> 功能：检测凹地所有灰度值。</p><p>\7. lowlands_center</p><p> 功能：检测凹地所有灰度值的中心。</p><p>\8. plateaus</p><p> 功能：检测所有平稳状态灰度值。</p><p>\9. plateaus_center</p><p> 功能：检测所有平稳状态灰度值的中心。</p><p>\10. pouring</p><p>  功能：根据大于“pouring_water”分割图像。</p><p>\11. saddle_points_sub_pix</p><p>  功能：一幅图像中底部点的子像素精确度检测。</p><p>\12. watersheds</p><p>  功能：从一副图像中提取分界线和“盆地”。</p><p>\13. watersheds_threshold</p><p>  功能：利用阀值从一幅图像中提取“分水岭盆地”。</p><h1 id="Chapter-16-System"><a href="#Chapter-16-System" class="headerlink" title="Chapter_16:System"></a>Chapter_16:System</h1><h2 id="16-1-Database"><a href="#16-1-Database" class="headerlink" title="16.1 Database"></a>16.1 Database</h2><p>\1. count_relation</p><p> 功能：在HALCON数据库中实体的数目。</p><p>\2. get_modules</p><p> 功能：查询已使用模块和模块关键码。</p><p>\3. reset_obj_db</p><p> 功能：HALCON系统的初始化。</p><h2 id="16-2-Error-Handling"><a href="#16-2-Error-Handling" class="headerlink" title="16.2 Error-Handling"></a>16.2 Error-Handling</h2><p>\1. get_check</p><p> 功能：HALCON控制模式的说明。</p><p>\2. get_error_text</p><p> 功能：查询HALCON错误测试后错误数目。</p><p>\3. get_spy</p><p> 功能：HALCON调试工具当前配置。</p><p>\4. query_spy</p><p> 功能：查询HALCON调试工具可能的设置。</p><p>\5. set_check</p><p> 功能：激活和钝化HALCON控制模式。</p><p>\6. set_spy</p><p> 功能：HALCON调试工具的控制。</p><h2 id="16-3-Information"><a href="#16-3-Information" class="headerlink" title="16.3 Information"></a>16.3 Information</h2><p>\1. get_chapter_info</p><p> 功能：获取程序有关章节的信息。</p><p>\2. get_keywords</p><p> 功能：获取指定给程序的关键字。</p><p>\3. get_operator_info</p><p> 功能：获取关于HALCON程序的信息。</p><p>\4. get_operator_name</p><p> 功能：获取由给定字符串作为它们的名字的程序。</p><p>\5. get_param_info</p><p> 功能：获取关于程序参数的信息。</p><p>\6. get_param_names</p><p> 功能：获取一个HALCON程序参数的名字。</p><p>\7. get_param_num</p><p> 功能：获取一个HALCON程序不同参数类的数目。</p><p>\8. get_param_types</p><p> 功能：获取一个HALCON程序控制参数的缺省数据类型。</p><p>\9. query_operator_info</p><p> 功能：联合操作get_operator_info查询空档相关信息。</p><p>\10. query_param_info</p><p>  功能：查询关于操作get_param_info的空档的在线信息。</p><p>\11. search_operator</p><p>  功能：寻找一个关键字所有进程的名字。</p><h2 id="16-4-Operating-System"><a href="#16-4-Operating-System" class="headerlink" title="16.4 Operating-System"></a>16.4 Operating-System</h2><p>\1. count_seconds</p><p> 功能：衡量时间。</p><p>\2. system_call</p><p> 功能：执行系统请求。</p><p>\3. wait_seconds</p><p> 功能：延迟操作的执行。</p><h2 id="16-5-Parallelization"><a href="#16-5-Parallelization" class="headerlink" title="16.5 Parallelization"></a>16.5 Parallelization</h2><p>\1. check_par_hw_potential</p><p> 功能：检测硬件进行并行处理的潜力。</p><p>\2. load_par_knowledge</p><p> 功能：从文件中导入自动平行化信息。</p><p>\3. store_par_knowledge</p><p> 功能：在文件中存储关于自动平行化的信息。</p><h2 id="16-6-Parameters"><a href="#16-6-Parameters" class="headerlink" title="16.6 Parameters"></a>16.6 Parameters</h2><p>\1. get_system_</p><p> 功能：根据HALCON系统参数获取关于当前的信息。</p><p>\2. set_system</p><p> 功能：HALCON系统参数的设置。</p><h2 id="16-7-Serial"><a href="#16-7-Serial" class="headerlink" title="16.7 Serial"></a>16.7 Serial</h2><p>\1. clear_serial</p><p> 功能：清除一个串行连接的缓冲。</p><p>\2. close_all_serials</p><p> 功能：关闭所有的串行设备。</p><p>\3. close_serial</p><p> 功能：关闭一个串行设备。</p><p>\4. get_serial_param</p><p> 功能：获取一个串行设备的参数。</p><p>\5. open_serial</p><p> 功能：打开一个串行设备。</p><p>\6. read_serial</p><p> 功能：读取一个串行设备。</p><p>\7. set_serial_param</p><p> 功能：设置一个串行设备的参数。</p><p>\8. write_serial</p><p> 功能：写入一个串行设备。</p><h2 id="16-8-Sockets"><a href="#16-8-Sockets" class="headerlink" title="16.8 Sockets"></a>16.8 Sockets</h2><p>\1. close_socket</p><p> 功能：关闭一个插口（接口）。</p><p>\2. get_next_socket_data_type</p><p> 功能：决定下一个插口（接口）数据的HALCON数据类型。</p><p>\3. get_socket_timeout</p><p> 功能：获取一个插口（接口）的超时。</p><p>\4. open_socket_accept</p><p> 功能：打开一个接受连接请求的插口（接口）。</p><p>\5. open_socket_connect</p><p> 功能：打开一个插口到一个已存在的插口。</p><p>\6. receive_image</p><p> 功能：通过插口连接接收一副图像。</p><p>\7. receive_region</p><p> 功能：通过插口连接接收区域。</p><p>\8. receive_tuple</p><p> 功能：通过插口连接接收一个元组。</p><p>\9. receive_xld</p><p> 功能：通过插口连接接收一个XLD对象。</p><p>\10. send_image</p><p>  功能：通过插口连接发送一副图像。</p><p>\11. send_region</p><p>  功能：通过插口连接发送区域。</p><p>\12. send_tuple</p><p>  功能：通过插口连接发送一个元组。</p><p>\13. send_xld</p><p>  功能：通过插口连接发送一个XLD对象。</p><p>\14. set_socket_timeout</p><p>  功能：设置一个插口的超时。</p><p>\15. socket_accept_connect</p><p>  功能：接受一个监听插口的连接请求。</p><h1 id="Chapter-17-Tools"><a href="#Chapter-17-Tools" class="headerlink" title="Chapter_17:Tools"></a>Chapter_17:Tools</h1><h2 id="17-1-2D-Transformations"><a href="#17-1-2D-Transformations" class="headerlink" title="17.1 2D-Transformations"></a>17.1 2D-Transformations</h2><p>\1. affine_trans_pixel</p><p> 功能：对像素坐标轴进行任意的仿射二维变换。</p><p>\2. affine_trans_point_2d</p><p> 功能：对点进行任意的最简二维变换</p><p>\3. bundle_adjust_mosaic</p><p> 功能：对一幅图像的嵌合体采取一系列调整。</p><p>\4. hom_mat2d_compose</p><p> 功能：将两种相同类型二维变换矩阵相乘。</p><p>\5. hom_mat2d_determinant</p><p> 功能：计算一个同质的二维变换矩阵的行列式。</p><p>\6. hom_mat2d_identity</p><p> 功能：构建二维变换同样的同质变换矩阵。</p><p>\7. hom_mat2d_invert</p><p> 功能：插入一个同质二维变换矩阵。</p><p>\8. hom_mat2d_rotate</p><p> 功能：为一个同质二维变换矩阵添加一个循环。</p><p>\9. hom_mat2d_rotate_local</p><p> 功能：为一个同质二维变换矩阵添加一个循环。</p><p>\10. hom_mat2d_scale</p><p>  功能：为一个同质二维变换矩阵添加一个缩放。</p><p>\11. hom_mat2d_scale_local</p><p>  功能：为一个同质二维变换矩阵添加一个缩放。</p><p>\12. hom_mat2d_slant</p><p>  功能：为一个同质二维变换矩阵添加一个斜面。</p><p>\13. hom_mat2d_slant_local</p><p>  功能：为一个同质二维变换矩阵添加一个斜面。</p><p>\14. hom_mat2d_to_affine_par</p><p>  功能：计算一个来自一个同质二维变换矩阵的仿射变换参数。</p><p>\15. hom_mat2d_translate</p><p>  功能：为一个同质二维变换矩阵添加一个旋转。</p><p>\16. hom_mat2d_translate_local</p><p>  功能：为一个同质二维变换矩阵添加一个旋转。</p><p>\17. hom_mat2d_transpose</p><p>  功能：将一个同质二维变换矩阵转置。</p><p>\18. hom_mat3d_project</p><p>  功能：给一个二维投影变换矩阵投影一个仿射三维变换矩阵。</p><p>\19. hom_vector_to_proj_hom_mat2d</p><p>  功能：根据给定点的映射计算一个同质变换矩阵。</p><p>\20. proj_match_points_ransack</p><p>  功能：通过找到两副图像中点与点之间的映射计算一个投影变换矩阵。</p><p>\21. projective_trans_pixel</p><p>  功能：利用一个同质投影变换矩阵表示像素坐标轴。</p><p>\22. projective_trans_point_2d</p><p>  功能：利用一个投影变换矩阵表示一个同质二维点。</p><p>\23. vector_angle_to_rigid</p><p>  功能：从点和角度方面计算一个严格的仿射变换。</p><p>\24. vector_field_to_hom_mat2d</p><p>  功能：根据位移矢量字段获取一个最接近的近似图。</p><p>\25. vector_to_hom_mat2d</p><p>  功能：根据点与点间的映射获取一个最接近的近似图</p><p>\26. vector_to_proj_hom_mat2d</p><p>  功能：利用给定点的映射计算一个映射变换矩阵。</p><p>\27. vector_to_rigid</p><p>  功能：根据点的映射获取一个近似严格的仿射变换。</p><p>\28. vector_to_similarity</p><p>  功能：根据点的映射获取一个近似的相似变换。</p><h2 id="17-2-3D-Transformations"><a href="#17-2-3D-Transformations" class="headerlink" title="17.2 3D-Transformations"></a>17.2 3D-Transformations</h2><p>\1. affine_trans_point_3d</p><p> 功能：对点运用一个随即仿射三维变换。</p><p>\2. convert_pose_type</p><p> 功能：改变一个三维模式的表示类型。</p><p>\3. create_pose</p><p> 功能：创建一个三维模式。</p><p>\4. get_pose_type</p><p> 功能：获取一个三维模式的表示类型。</p><p>\5. hom_mat3d_compose</p><p> 功能：将两个同质三维变换矩阵相乘。</p><p>\6. hom_mat3d_identity</p><p> 功能：构建三维变换同样的同质变换矩阵。</p><p>\7. hom_mat3d_invert</p><p> 功能：插入一个同质三维变换矩阵。</p><p>\8. hom_mat3d_rotate</p><p> 功能：为一个同质三维变换矩阵添加一个循环。</p><p>\9. hom_mat3d_rotate_local</p><p> 功能：为一个同质三维变换矩阵添加一个循环。</p><p>\10. hom_mat3d_scale</p><p> 功能：为一个同质三维变换矩阵添加一个缩放。</p><p>\11. hom_mat3d_scale_local</p><p> 功能：为一个同质三维变换矩阵添加一个缩放。</p><p>\12. hom_mat3d_to_pose</p><p>  功能：将一个同质变换矩阵转换为一个三维模式。</p><p>\13. hom_mat3d_translate</p><p>  功能：为一个同质三维变换矩阵添加一个旋转。</p><p>\14. hom_mat3d_translate_local</p><p>  功能：为一个同质三维变换矩阵添加一个旋转。</p><p>15_.pose_to_hom_mat3d</p><p>  功能：将一个三位模式转换为一个同质变换矩阵。</p><p>\16. read_pose</p><p>  功能：从一个文本文件中读取一个三维模式。</p><p>\17. set_origin_pose</p><p>  功能：转换一个三位模式的原点。</p><p>\18. write_pose</p><p>  功能：将一个三维模式写入一个文本文件。</p><h2 id="17-3-Background-Estimator"><a href="#17-3-Background-Estimator" class="headerlink" title="17.3 Background-Estimator"></a>17.3 Background-Estimator</h2><p>\1. close_all_bg_esti</p><p> 功能：清除所有的背景评估数据集。</p><p>\2. close_bg_esti</p><p> 功能：清除背景估测数据集。</p><p>\3. create_bg_esti</p><p> 功能：为背景评估创建和初始化一个数据集。</p><p>\4. get_bg_esti_params</p><p> 功能：返回数据集的参数。</p><p>\5. give_bg_esti</p><p> 功能：返回估测背景图像。</p><p>\6. run_bg_esti</p><p> 功能：评估背景并返回前景区域。</p><p>\7. set_bg_esti_params</p><p> 功能：改变数据集的参数。</p><p>\8. update_bg_esti</p><p> 功能：改变估测背景图像。</p><h2 id="17-4-Barcode"><a href="#17-4-Barcode" class="headerlink" title="17.4 Barcode"></a>17.4 Barcode</h2><p>\1. clear_all_bar_code_models</p><p> 功能：清除所有条形码模型，释放其分配的存储空间。</p><p>\2. clear_bar_code_model</p><p> 功能：清除一个条形码模型，释放相应的存储空间。</p><p>\3. create_bar_code_model</p><p> 功能：创建一个条形码阅读器模型。</p><p>\4. find_bar_code</p><p> 功能：检测和读取一幅图像中条形码符号。</p><p>\5. get_bar_code_object</p><p> 功能：访问创建在搜寻或条形码符号解码过程中的对象图标。</p><p>\6. get_bar_code_param</p><p> 功能：获取一个或多个描述条形码模式的参数。</p><p>\7. get_bar_code_result</p><p> 功能：获取字母数字混合编码的结果，其是在条形码符号解码过程中累计的。</p><p>\8. set_bar_code_param</p><p> 功能：设置条形码模型的选定参数。</p><h2 id="17-5-Calibration"><a href="#17-5-Calibration" class="headerlink" title="17.5 Calibration"></a>17.5 Calibration</h2><p>\1. caltab_points</p><p> 功能：从校准板说明文件中读取标志中心点。</p><p>\2. cam_mat_to_cam_par</p><p> 功能：计算从一个相机矩阵获取的内部相机参数。</p><p>\3. cam_par_to_cam_mat</p><p> 功能：从相机内部参数计算一个相机矩阵。</p><p>\4. camera_calibration</p><p> 功能：决定同时发生的最小化程序的所有相机参数。</p><p>\5. change_radial_distortion_cam_par</p><p> 功能：根据与特殊放射失真相一致决定新的相机参数。</p><p>\6. change_radial_distortion_contours_xld</p><p> 功能：改变了轮廓(contour)的放射失真。</p><p>\7. change_radial_distortion_image</p><p> 功能：改变一幅图像的放射失真。</p><p>\8. contour_to_world_plane_xld</p><p> 功能：将一个XLD轮廓(contour)转换为一个坐标系统中平面Z为零。</p><p>\9. create_caltab</p><p> 功能：创建一个描述文件和附文件的校准板。</p><p>\10. disp_caltab</p><p>  功能：投射和视觉化图像中校准板的三维模型。</p><p>\11. find_caltab</p><p>  功能：分割和标准化图像中的校准板区域。</p><p>\12. find_marks_and_pose</p><p>  功能：从图像中提取二维校准标志和为外部计算机参数计算内部数值。</p><p>\13. gen_caltab</p><p>  功能：创建一个校准板说明文件和相应的附文件。</p><p>\14. gen_image_to_world_plane_map</p><p>  功能：创建一个投射图，其描述图像平面与坐标轴系统中平面Z为零之间的映射。</p><p>\15. gen_radial_distortion_map</p><p> 功能：创建一个投射图，其描述图像与其相应正在改变的放射失真间的映射。</p><p>\16. get_circle_pose</p><p>  功能：从一个圆周相应的二维投射中决定它的三维模式。</p><p>\17. get_line_of_sight</p><p>  功能：计算相应于图像中一个点的视线。</p><p>\18. get_rectangle_pose</p><p>  功能：从一个矩形相应的二维投射中决定它的三维模式。</p><p>\19. hand_eye_calibration</p><p>  功能：执行一个手—眼校准。</p><p>\20. image_points_to_world_plane</p><p>  功能：将图像中的点转换到坐标轴平面Z为零上。</p><p>\21. image_to_world_plane</p><p>  功能：通过将一副图像转换为坐标轴系统中平面Z为零而矫正图像。</p><p>\22. project_3d_point</p><p>  功能：将三维点投射到子像素图像坐标。</p><p>\23. radiometric_self_calibration</p><p>  功能：执行一个相机的辐射测量的自校准。</p><p>\24. read_cam_par</p><p>  功能：从文本文件中读取内部相机参数。</p><p>\25. sim_caltab</p><p>  功能：根据校准板模拟一幅图像。</p><p>\26. stationary_camera_self_calibration</p><p>  功能：投射一个静止投射相机的自校准。</p><p>\27. write_cam_par</p><p>  功能：将内部相机参数写入文本文件中。</p><h2 id="17-6-Datacode"><a href="#17-6-Datacode" class="headerlink" title="17.6 Datacode"></a>17.6 Datacode</h2><p>\1. clear_all_data_code_2d_models</p><p> 功能：清除所有的二维数据模型并释放它们分配的存储空间。</p><p>\2. clear_data_code_2d_model</p><p> 功能：清除一个二维数据模型并释放它分配的存储空间。</p><p>\3. create_data_code_2d_model</p><p> 功能：创建一个二维数据编码类的模式。</p><p>\4. find_data_code_2d</p><p> 功能：检测和读取一副图像或测试的二维数据编码模式中的二维数据编码符号。</p><p>\5. get_data_code_2d_objects</p><p> 功能：查询搜索二维数据编码符号过程中创建的对象的图标。</p><p>\6. get_data_code_2d_param</p><p> 功能：获取一个或多个描述二维数据编码模型的参数。</p><p>\7. get_data_code_2d_results</p><p> 功能：获取字母数字混合编码的结果，其是在搜索二维数据编码符号过程中累计的。</p><p>\8. query_data_code_2d_params</p><p> 功能：为一个给定二维数据编码模型获取通用参数或对象的名字，其也可用于其他的二维数据编码模型中。</p><p>\9. read_data_code_2d_model</p><p> 功能：从一个文件中读取一个二维数据编码模型并新建一个模型。</p><p>\10. set_data_code_2d_param</p><p>  功能：设置二维数据编码模型的选定参数。</p><p>\11. write_data_code_2d_model</p><p>  功能：将一个二维数据编码模型写入一个文件。</p><h2 id="17-7-Fourier-Descriptor"><a href="#17-7-Fourier-Descriptor" class="headerlink" title="17.7 Fourier-Descriptor"></a>17.7 Fourier-Descriptor</h2><p>\1. abs_invar_fourier_coeff</p><p> 功能：根据起始点的位移标准化傅里叶系数。</p><p>\2. fourier_1dim</p><p> 功能：计算一个参数化的元组的傅里叶系数。</p><p>\3. fourier_1dim_inv</p><p> 功能：空间傅里叶变换（傅里叶逆变换）。</p><p>\4. invar_fourier_coeff</p><p> 功能：傅里叶系数标准化。</p><p>\5. match_fourier_coeff</p><p> 功能：两个元组的相似性。</p><p>\6. move_contour_orig</p><p> 功能：将原点变换到引力的中心。</p><p>\7. prep_contour_fourier</p><p> 功能：参数化传输的元组。</p><h2 id="17-8-Function"><a href="#17-8-Function" class="headerlink" title="17.8 Function"></a>17.8 Function</h2><p>\1. abs_funct_1d</p><p> 功能：Y值的绝对值。</p><p>\2. compose_funct_1d</p><p> 功能：组合两个函数。</p><p>\3. create_funct_1d_array</p><p> 功能：从Y值的序列中创建一个函数。</p><p>\4. create_funct_1d_pairs</p><p> 功能：从（X，Y）集合中创建一个函数。</p><p>\5. derivate_funct_1d</p><p> 功能：计算一个函数的派生物。</p><p>\6. distance_funct_1d</p><p> 功能：计算两个函数的间隔。</p><p>\7. funct_1d_to_pairs</p><p> 功能：查询一个函数的（X，Y）值。</p><p>\8. get_pair_funct_1d</p><p> 功能：根据控制点的索引查询一个函数值。</p><p>\9. get_y_value_funct_1d</p><p> 功能：返回任意位置函数的值。</p><p>\10. integrate_funct_1d</p><p>  功能：计算一个函数的正区域和负区域。</p><p>\11. invert_funct_1d</p><p>  功能：计算一个函数的反转。</p><p>\12. local_min_max_funct_1d</p><p>  功能：计算一个函数的局域最小和最大值点。</p><p>\13. match_funct_1d_trans</p><p>  功能：计算两个函数传递参数。</p><p>\14. negate_funct_1d</p><p>  功能：对Y值取非（反）。</p><p>\15. num_points_funct_1d</p><p>  功能：函数控制点的数目。</p><p>\16. read_funct_1d</p><p>  功能：从文件中读取一个函数。</p><p>\17. sample_funct_1d</p><p>  功能：再间隔区等距取样。</p><p>\18. scale_y_funct_1d</p><p>  功能：将Y值相乘和相加。</p><p>\19. smooth_funct_1d_gauss</p><p>  功能：采用高斯函数平滑一个等距一维函数。</p><p>\20. smooth_funct_1d_mean</p><p>  功能：采用平均值将一个等距一维函数平滑化。</p><p>\21. transform_funct_1d</p><p>  功能：根据给定传递参数变换你一个函数。</p><p>\22. write_funct_1d</p><p>  功能：将一个函数写入一个文件。</p><p>\23. x_range_funct_1d</p><p>  功能：函数的最小和最大X值。</p><p>\24. y_range_funct_1d</p><p>  功能：函数的最小和最大Y值。</p><p>\25. zero_crossings_funct_1d</p><p>  功能：计算一个函数的零点。</p><h2 id="17-9-Geometry"><a href="#17-9-Geometry" class="headerlink" title="17.9 Geometry"></a>17.9 Geometry</h2><p>\1. angle_ll</p><p> 功能：计算两条线的夹角。</p><p>\2. angle_lx</p><p> 功能：计算一条线与垂直轴之间的角度。</p><p>\3. distance_cc</p><p> 功能：计算两个轮廓(contour)间的距离。</p><p>\4. distance_cc_min</p><p> 功能：计算两个轮廓(contour)间的最小距离。</p><p>\5. distance_lc</p><p> 功能：计算一条线和一个轮廓(contour)间的距离。</p><p>\6. distance_lr</p><p> 功能：计算一条线和一个区域间的距离。</p><p>\7. distance_pc</p><p> 功能：计算一个点和一个轮廓(contour)间的距离。</p><p>\8. distance_pl</p><p> 功能：计算一个点和一条线间的距离。</p><p>\9. distance_pp</p><p> 功能：计算两个点之间的距离。</p><p>\10. distance_pr</p><p>  功能：计算一个点和一个区域间的距离。</p><p>\11. distance_ps</p><p>  功能：计算一个点和一条分割线间的距离。</p><p>\12. distance_rr_min</p><p>  功能：两个相邻区域的相同像素间的最小距离。</p><p>\13. distance_rr_min_dil</p><p>  功能：膨胀时两个区域间的最小距离。</p><p>\14. distance_sc</p><p>  功能：计算一条分割线和一个轮廓(contour)间的距离。</p><p>\15. distance_sl</p><p>  功能：计算一条分割线和一条线间的距离。</p><p>\16. distance_sr</p><p>  功能：计算一条分割线和一个区域间的距离。</p><p>\17. distance_ss</p><p>  功能：计算两条分割线间的距离。</p><p>\18. get_points_ellipse</p><p>  功能：计算椭圆上特定角度的一个点。</p><p>\19. intersection_ll</p><p>  功能：计算两条线的交集点（相交点）。</p><p>\20. projection_pl</p><p>  功能：计算一条线上一个点的投影。</p><h2 id="17-10-Grid-Rectiﬁcation"><a href="#17-10-Grid-Rectiﬁcation" class="headerlink" title="17.10 Grid-Rectiﬁcation"></a>17.10 Grid-Rectiﬁcation</h2><p>\1. connect_grid_points</p><p> 功能：建立矫正网格的矫正点间的连接。</p><p>\2. create_rectification_grid</p><p> 功能：建立一个附文件，描述矫正网格。</p><p>\3. find_rectification_grid</p><p> 功能：分割图像中矫正网格区域。</p><p>\4. gen_arbitrary_distortion_map</p><p> 功能：产生一个投射图，其描述随意扭曲图像与正确图像间的映射。</p><p>\5. gen_grid_rectification_map</p><p> 功能：计算扭曲图像与基于规律的网格的正确的图像的映射。</p><h2 id="17-11-Hough"><a href="#17-11-Hough" class="headerlink" title="17.11 Hough"></a>17.11 Hough</h2><p>\1. hough_circle_trans</p><p> 功能：返回指定半径的圆周的Hough变换。</p><p>\2. hough_circles</p><p> 功能：特定半径的圆周的中心。</p><p>\3. hough_line_trans</p><p> 功能：对区域中的线进行Hough变换。</p><p>\4. hough_line_trans_dir</p><p> 功能：利用局部方向梯度对线进行Hough变换。</p><p>\5. hough_lines</p><p> 功能：借助Hough变化查询图像中的线，并将其返回到HNF中。</p><p>\6. hough_lines_dir</p><p> 功能：借助采用局部方向梯度的Hough变换查询图像中的线，并将它们以正常形式返回。</p><p>\7. select_matching_lines</p><p> 功能：选取HNF中线的集合中匹配区域最好的线。</p><h2 id="17-12-Image-Comparison"><a href="#17-12-Image-Comparison" class="headerlink" title="17.12 Image-Comparison"></a>17.12 Image-Comparison</h2><p>\1. clear_all_variation_models</p><p> 功能：释放所有变化模型（variation_model）的存储空间。</p><p>\2. clear_train_data_variation_model</p><p> 功能：释放变化模型（variation_model）的测试数据的存储空间。</p><p>\3. clear_variation_model</p><p> 功能：释放一个变化模型（variation_model）的存储空间。</p><p>\4. compare_ext_variation_model</p><p> 功能：将一副图像与一个变化模型（variation_model）相比较。</p><p>\5. compare_variation_model</p><p> 功能：将一副图像与一个变化模型（variation_model）相比较。</p><p>\6. create_variation_model</p><p> 功能：为图像对比创建一个变化模型。</p><p>\7. get_thresh_images_variation_model</p><p> 功能：返回阀值图像用于图像对比。</p><p>\8. get_variation_model</p><p> 功能：返回图像用于图像对比。</p><p>\9. prepare_direct_variation_model</p><p> 功能：为图像对比准备一个变化模型。</p><p>\10. prepare_variation_model</p><p>  功能：为图像对比准备一个变化模型。</p><p>\11. read_variation_model</p><p>  功能：从一个文件中读取一个变化模型。</p><p>\12. train_variation_model</p><p>  功能：测试一个变化模型。</p><p>\13. write_variation_model</p><p>  功能：将一个变化模型写入文件。</p><h2 id="17-13-Kalman-Filter"><a href="#17-13-Kalman-Filter" class="headerlink" title="17.13 Kalman-Filter"></a>17.13 Kalman-Filter</h2><p>\1. filter_kalman</p><p> 功能：借助Kalman（卡尔曼）滤波器估测系统的当前状态。</p><p>\2. read_kalman</p><p> 功能：读取一个卡尔曼滤波器的说明文件。</p><p>\3. sensor_kalman</p><p> 功能：卡尔曼滤波器测量值的交互式输入。</p><p>\4. update_kalman</p><p> 功能：读取一个卡尔曼滤波器的更新文件。</p><h2 id="17-14-Measure"><a href="#17-14-Measure" class="headerlink" title="17.14 Measure"></a>17.14 Measure</h2><p>\1. close_all_measures</p><p> 功能：清除所有测试对象。</p><p>\2. close_measure</p><p> 功能：清除一个测试对象。</p><p>\3. fuzzy_measure_pairing</p><p> 功能：提取与矩形或环状弧垂直的直线边缘。</p><p>\4. fuzzy_measure_pairs</p><p> 功能：提取与矩形或环状弧垂直的直线边缘。</p><p>\5. fuzzy_measure_pos</p><p> 功能：提取与矩形或环状弧垂直的直线边缘。</p><p>\6. gen_measure_arc</p><p> 功能：垂直与环状弧的直线边缘的提取。</p><p>\7. gen_measure_rectangle2</p><p> 功能：垂直与矩形的直线边缘的提取。</p><p>\8. measure_pairs</p><p> 功能：提取与矩形或环状弧垂直的直线边缘。</p><p>\9. measure_pos</p><p> 功能：提取与矩形或环状弧垂直的直线边缘。</p><p>\10. measure_projection</p><p>  功能：提取垂直于一个矩形或环状弧的灰度值轮廓(contour)。</p><p>\11. measure_thresh</p><p>  功能：提取沿着一个矩形或环状弧，特殊灰度值的点。</p><p>\12. reset_fuzzy_measure</p><p>  功能：重置一个模糊元函数。</p><p>\13. set_fuzzy_measure</p><p>  功能：指定一个模糊元函数。</p><p>\14. set_fuzzy_measure_norm_pair</p><p>  功能：为边缘匹配指定一个规范化模糊元函数。</p><p>\15. translate_measure</p><p>  功能：转化（解释）一个测试对象。</p><h2 id="17-15-OCV（Open-Circuit-Voltage-光学字符校验）"><a href="#17-15-OCV（Open-Circuit-Voltage-光学字符校验）" class="headerlink" title="17.15 OCV（Open_Circuit_Voltage_|_光学字符校验）"></a>17.15 OCV（Open_Circuit_Voltage_|_光学字符校验）</h2><p>\1. close_all_ocvs</p><p> 功能：关闭所有OCV工具。</p><p>\2. close_ocv</p><p> 功能：关闭一个OCV工具。</p><p>\3. create_ocv_proj</p><p> 功能：创建一个基于灰度值突出的新的OCV工具。</p><p>\4. do_ocv_simple</p><p> 功能：利用一个OCV工具查证一个模式。</p><p>\5. read_ocv</p><p> 功能：从文件中读取一个OCV工具。</p><p>\6. traind_ocv_proj</p><p> 功能：测试一个OCV工具。</p><p>\7. write_ocv</p><p> 功能：将一个OCV工具保存到文件。</p><h2 id="17-16-Shape-from"><a href="#17-16-Shape-from" class="headerlink" title="17.16 Shape-from"></a>17.16 Shape-from</h2><p>\1. depth_from_focus</p><p> 功能：利用多倍聚焦灰度级提取高度（厚度）。</p><p>\2. estimate_al_am</p><p> 功能：估测一个平面的反射率和反射光的数目。</p><p>\3. estimate_sl_al_lr</p><p> 功能：估测一个光源的倾斜度和一个平面的反射率。</p><p>\4. estimate_sl_al_zc</p><p> 功能：估测一个光源的倾斜度和一个平面的反射率。</p><p>\5. estimate_tilt_lr</p><p> 功能：估测一个光源的倾斜。</p><p>\6. estimate_tilt_zc</p><p> 功能：估测一个光源的倾斜。</p><p>\7. phot_stereo</p><p> 功能：根据至少三个灰度值的图像来重建一个平面。</p><p>\8. select_grayvalues_from_channels</p><p> 功能：利用索引图像选择一个多通道图像的灰度值。</p><p>\9. sfs_mod_lr</p><p> 功能：从一个灰度值图像重建一个平面。</p><p>\10. sfs_orig_lr</p><p>  功能：从一个灰度值图像重建一个平面。</p><p>\11. sfs_pentland</p><p>  功能：从一个灰度值图像重建一个平面。</p><p>\12. shade_height_field</p><p>  功能：遮蔽一个突起的字段。</p><h2 id="17-17-Stereo"><a href="#17-17-Stereo" class="headerlink" title="17.17 Stereo"></a>17.17 Stereo</h2><p>\1. binocular_calibration</p><p> 功能：决定一个双目视觉立体系统的所有相机参数。</p><p>\2. binocular_disparity</p><p> 功能：计算一个矫正图像对的不均衡。</p><p>\3. binocular_distance</p><p> 功能：计算一个矫正立体图像对的间隔值。</p><p>\4. disparity_to_distance</p><p> 功能：将不均衡值转换为矫正双目视觉立体系统中的间隔值。</p><p>\5. disparity_to_point_3d</p><p> 功能：将一个图像点和它的不均衡值转换为一个矫正立体系统中的三维点。</p><p>6.distance_to_disparity</p><p> 功能：将一个间隔值转换为一个矫正立体系统中的一个不均衡值。</p><p>\7. essential_to_fundamental_matrix</p><p> 功能：计算一个从原始矩阵衍生而来的基本矩阵。</p><p>\8. gen_binocular_proj_rectification</p><p> 功能：计算弱双目视觉立体系统图像的投射矫正值。</p><p>\9. gen_binocular_rectification_map_</p><p> 功能：创建传输图，其描述从一个双目相机到一个普通的矫正图像面的图像的映射。</p><p>\10. gen_binocular_rectification_map</p><p>  功能：从一个双目相机系统视觉中两条线的交点中获取一个三维点。</p><p>\11. match_essential_matrix_ransack</p><p>  功能：通过自动发掘图像点间对应关系来计算立体图像对的原始（本质）矩阵。</p><p>\12. match_fundamental_matrix_ransack</p><p>  功能：通过自动发掘图像点间对应关系来计算立体图像对的基本矩阵。</p><p>\13. match_rel_pose_ransack</p><p>  功能：通过自动发掘图像点间对应关系来计算两个相机间的相对方位。</p><p>\14. reconst3d_from_fundamental_matrix</p><p>  功能：计算基于基本矩阵的点的投影的三维重建。</p><p>\15. rel_pose_to_fundamental_matrix</p><p>  功能：计算两个相机相关方向中获取的基本矩阵。</p><p>\16. vector_to_essential_matrix</p><p>  功能：计算给定图像点间映射和已知相机矩阵的原始矩阵，重建三维点。</p><p>\17. vector_to_fundamental_matrix</p><p> 功能：计算给定图像点间映射的集合的基本矩阵，重建三维点。</p><p>\18. vector_to_fundamental_matrix</p><p>  功能：计算给定图像点间对应关系和已知相机参数的两个相机的相对方位，重建三维点。</p><h2 id="17-18-Tools-Legacy"><a href="#17-18-Tools-Legacy" class="headerlink" title="17.18 Tools-Legacy"></a>17.18 Tools-Legacy</h2><p>\1. decode_1d_bar_code</p><p> 功能：一个条形码的顺序解码。</p><p>\2. decode_2d_bar_code</p><p> 功能：解码二维条形码数据。</p><p>\3. discrete_1d_bar_code</p><p> 功能：从元素宽度创建一个离散条形码。</p><p>\4. find_1d_bar_code</p><p> 功能：搜索一幅图像中的一个条形码。</p><p>\5. find_1d_bar_code_region</p><p> 功能：搜索一幅图像中的多种条形码。</p><p>\6. find_1d_bar_code_scanline</p><p> 功能：搜索一幅图像中的一个条形码。</p><p>\7. find_2d_bar_code</p><p> 功能：搜索可能包括一个二维条形码的区域。</p><p>\8. gen_1d_bar_code_descry</p><p> 功能：创建一个一维条形码的说明。</p><p>\9. gen_1d_bar_code_descr_gen</p><p> 功能：创建一个一维条形码的类属描述。</p><p>\10. gen_2d_bar_code_descry</p><p>  功能：创建一个二维条形码的类属描述。</p><p>\11. get_1d_bar_code</p><p>  功能：提取一个条形码中元素的宽度。</p><p>\12. get_1d_bar_code_scanline</p><p>  功能：提取一个条形码区域中元素的宽度。</p><p>\13. get_2d_bar_code_</p><p>  功能：提取一个条形码区域（“数据矩阵符号”）中数据元素（在ECC200：“模块”中）的值。_</p><p>\14. get_2d_bar_code_pos</p><p>  功能：提取一个条形码区域（“数据矩阵符号”）中数据元素（在ECC200：“模块”中）的数值和它们在图像中的位置。</p><h1 id="Chapter-18-Tuple"><a href="#Chapter-18-Tuple" class="headerlink" title="Chapter_18:Tuple"></a>Chapter_18:Tuple</h1><h2 id="18-1-Arithmetic"><a href="#18-1-Arithmetic" class="headerlink" title="18.1 Arithmetic"></a>18.1 Arithmetic</h2><p>\1. tuple_abs</p><p> 功能：计算一个元组的绝对值。</p><p>\2. tuple_acos</p><p> 功能：计算一个元组的反余弦。</p><p>\3. tuple_add</p><p> 功能：两个元组相加。</p><p>\4. tuple_asin</p><p> 功能：计算一个元组的反余弦。</p><p>\5. tuple_atan</p><p> 功能：计算一个元组的反正切。</p><p>\6. tuple_atan2</p><p> 功能：计算一个元组四个象限的反正切。</p><p>\7. tuple_ceil</p><p> 功能：计算一个元组的上限函数。</p><p>\8. tuple_cos</p><p> 功能：计算一个元组的余弦。</p><p>\9. tuple_cosh</p><p> 功能：计算一个元组的双曲余弦。</p><p>\10. tuple_cumul</p><p>  功能：计算一个元组的累计和。</p><p>\11. tuple_deg</p><p>  功能：将一个元组从弧度转换为角度。</p><p>\12. tuple_div</p><p>  功能：将两个元组相除。</p><p>\13. tuple_exp</p><p>  功能：元组的指数运算。</p><p>\14. tuple_fabs_</p><p>  功能：计算一个元组（例如浮点数）的绝对值。</p><p>\15. tuple_floor</p><p>  功能：计算一个元组的“地板函数”。</p><p>\16. tuple_fmod</p><p>  功能：计算两个元组浮点数相除的余数。</p><p>\17. tuple_ldexp</p><p>  功能：计算两个元组的返回长双精度指数函数。</p><p>\18. tuple_log</p><p>  功能：计算一个元组的自然对数。</p><p>\19. tuple_log10</p><p>  功能：计算一个元组底为10的对数。</p><p>\20. tuple_max2</p><p>  功能：计算两个元组的元素宽度的最大值。</p><p>\21. tuple_min2</p><p>  功能：计算两个元组的元素宽度的最小值。</p><p>\22. tuple_mod</p><p>  功能：计算两个元组整型数相除的余数。</p><p>\23. tuple_mult</p><p>  功能：两个元组相乘。</p><p>\24. tuple_neg</p><p>  功能：将一个元组取反。</p><p>\25. tuple_pow</p><p>  功能：计算两个元组的冥函数。</p><p>\26. tuple_rad</p><p>  功能：将一个元组从角度转换为弧度。</p><p>\27. tuple_sgn</p><p>  功能：计算一个元组的正负。</p><p>\28. tuple_sin</p><p>  功能：计算一个元组的正弦。</p><p>\29. tuple_sinh</p><p>  功能：计算一个元组的双曲正弦。</p><p>\30. tuple_sqrt</p><p>  功能：计算一个元组的平方根（二次方根）。</p><p>\31. tuple_sub</p><p>  功能：两个元组相减。</p><p>\32. tuple_tan</p><p>  功能：计算一个元组的正切。</p><p>\33. tuple_tanh</p><p>  功能：计算一个远足的双曲正切。</p><h2 id="18-2-Bit-Operations"><a href="#18-2-Bit-Operations" class="headerlink" title="18.2 Bit-Operations"></a>18.2 Bit-Operations</h2><p>\1. tuple_band</p><p> 功能：计算两个元组的按位运算。</p><p>\2. tuple_bnot</p><p> 功能：两个元组逐位取逻辑非。</p><p>\3. tuple_bor</p><p> 功能：计算两个元组的按位运算。</p><p>\4. tuple_bxor</p><p> 功能：两个元组逐位进行互斥逻辑或运算。</p><p>\5. tuple_lsh</p><p> 功能：元组逐位左移。</p><p>\6. tuple_rsh</p><p> 功能：元组逐位右移。</p><h2 id="18-3-Comparison"><a href="#18-3-Comparison" class="headerlink" title="18.3 Comparison"></a>18.3 Comparison</h2><p>\1. tuple_equal</p><p> 功能：测试两个元组是否相同。</p><p>\2. tuple_greater</p><p> 功能：测试一个元组是否大于另一个元组。</p><p>\3. tuple_greater_equal</p><p> 功能：测试一个元组是否大于等于另一个。</p><p>\4. tuple_less</p><p> 功能：测试一个元组是否小于另一个元组。</p><p>\5. tuple_less_equal</p><p> 功能：测试一个元组是否小于等于另一个。</p><p>\6. tuple_not_equal</p><p> 功能：测试两个元组是不是不等。</p><h2 id="18-4-Conversion"><a href="#18-4-Conversion" class="headerlink" title="18.4 Conversion"></a>18.4 Conversion</h2><p>\1. tuple_chr</p><p> 功能：根据ASCII码将整型元组转换为字符串。</p><p>\2. tuple_chrt</p><p> 功能：根据ASCII码将整型元组转换为字符串。</p><p>\3. tuple_int</p><p> 功能：讲一个元组转换为一个整型元组。</p><p>\4. tuple_is_number</p><p> 功能：检测一个字符串元组是否表示数字。</p><p>\5. tuple_number</p><p> 功能：将一个字符串元组转换为一个数字元组。</p><p>\6. tuple_ord</p><p> 功能：将长度为1的字符串的元组转换为它们相应的ASCII码元组。</p><p>\7. tuple_ords</p><p> 功能：将一个字符串的元组转换为它们ASCII码的元组。</p><p>\8. tuple_real</p><p> 功能：将一个元组转换为一个浮点数的元组。</p><p>\9. tuple_round</p><p> 功能：将一个元组转换为一个整型数的元组。</p><p>\10. tuple_string</p><p>  功能：将一个元组转换为一个字符串元组。</p><h2 id="18-5-Creation"><a href="#18-5-Creation" class="headerlink" title="18.5 Creation"></a>18.5 Creation</h2><p>\1. tuple_concat</p><p> 功能：合并两个元组为一个新的。</p><p>\2. tuple_gen_const</p><p> 功能：创建一个特殊长度的元组和初始化它的元素。</p><p>\3. tuple_rand</p><p> 功能：返回任意值为0或1的元组。</p><h2 id="18-6-Element-Order"><a href="#18-6-Element-Order" class="headerlink" title="18.6_Element-Order"></a>18.6_Element-Order</h2><p>\1. tuple_inverse</p><p> 功能：将一个元组反置（反转）。</p><p>\2. tuple_sort</p><p> 功能：按照升序分类（排列）元组的元素。</p><p>\3. tuple_sort_index</p><p> 功能：将元组的元素分类并返回分类元组的目录。</p><h2 id="18-7-Features"><a href="#18-7-Features" class="headerlink" title="18.7 Features"></a>18.7 Features</h2><p>\1. tuple_deviation</p><p> 功能：返回一个元组元素的标准差。</p><p>\2. tuple_length</p><p> 功能：返回一个元组元素数目。</p><p>\3. tuple_max</p><p> 功能：返回一个元组的最大元素。</p><p>\4. tuple_mean</p><p> 功能：返回一定数量元组的平均值。</p><p>\5. tuple_median</p><p> 功能：返回一个元组元素的中值。</p><p>\6. tuple_min</p><p> 功能：返回一个元组的最小元素。</p><p>\7. tuple_sum</p><p> 功能：返回一个元组所有元素的和。</p><h2 id="18-8-Logical-Operations"><a href="#18-8-Logical-Operations" class="headerlink" title="18.8 Logical-Operations"></a>18.8 Logical-Operations</h2><p>\1. tuple_and</p><p> 功能：两个元组的逻辑与。</p><p>\2. tuple_not</p><p> 功能：两个元组的逻辑非。</p><p>\3. tuple_or</p><p> 功能：两个元组的逻辑或。</p><p>\4. tuple_xor</p><p> 功能：两个元组的逻辑互斥或。</p><h2 id="18-9-Selection"><a href="#18-9-Selection" class="headerlink" title="18.9 Selection"></a>18.9 Selection</h2><p>\1. tuple_find</p><p> 功能：返回一个元组所有出现的符号，同时位于另一个元组内。</p><p>\2. tuple_first_n</p><p> 功能：选取一个元组的第一个元素。</p><p>\3. tuple_last_n</p><p> 功能：选择从符号“n”开始到元组末尾的所有元素。</p><p>\4. tuple_remove</p><p> 功能：从一个元组中移出元素。</p><p>\5. tuple_select</p><p> 功能：选择一个元组中单一元素。</p><p>\6. tuple_select_range</p><p> 功能：选择一个元组中的一些元素。</p><p>\7. tuple_select_rank</p><p> 功能：选择一个元组中序号为n的元素。</p><p>\8. tuple_str_bit_select</p><p> 功能：选择一个元组中单一符号或位。</p><p>\9. tuple_uniq</p><p> 功能：丢弃元组中除成功归类的元素外的所有元素。</p><h2 id="18-10-String-Operators"><a href="#18-10-String-Operators" class="headerlink" title="18.10 String-Operators"></a>18.10 String-Operators</h2><p>\1. tuple_environment</p><p> 功能：读取一个或多个环境变量。</p><p>\2. tuple_regexp_match</p><p> 功能：利用公式提取子链。</p><p>\3. tuple_regexp_replace</p><p> 功能：用有规律的公式代替一个子链。</p><p>\4. tuple_regexp_select</p><p> 功能：选择符合公式的元组元素。</p><p>\5. tuple_regexp_test</p><p> 功能：测试一个字符串是否满足一个规则公式的要求。</p><p>\6. tuple_split</p><p> 功能：在预定义的独立字符间将字符串分离为子链。</p><p>\7. tuple_str_first_n</p><p> 功能：分割从第一个字符直到字符串元组外的位置“n”处。</p><p>\8. tuple_str_last_n</p><p> 功能：从字符串元组外位置“n”处开始分割所有的字符。</p><p>\9. tuple_strchr</p><p> 功能：前向搜索一个位于字符串元组内的字符。</p><p>\10. tuple_strlen</p><p>  功能：字符串元组中每个字符串的长度。</p><p>\11. tuple_strrchr</p><p>  功能：后向搜索一个位于字符串元组内的字符。</p><p>\12. tuple_strrstr</p><p>  功能：后向搜索一个位于字符串元组内的字符串。</p><p>\13. tuple_strstr</p><p>  功能：前向搜索一个位于字符串元组内的字符串。</p><h1 id="Chapter-19-XLD"><a href="#Chapter-19-XLD" class="headerlink" title="Chapter_19:XLD"></a>Chapter_19:XLD</h1><h2 id="19-1-Access"><a href="#19-1-Access" class="headerlink" title="19.1 Access"></a>19.1 Access</h2><p>\1. get_contour_xld</p><p> 功能：返回XLD轮廓(contour)的坐标。</p><p>\2. get_lines_xld</p><p> 功能：返回一个XLD多边形（polygon）数据。</p><p>\3. get_parallels_xld</p><p> 功能：返回一个XLD并行数据。</p><p>\4. get_polygon_xld</p><p> 功能：返回一个XLD多边形（polygon）数据。</p><h2 id="19-2-Creation"><a href="#19-2-Creation" class="headerlink" title="19.2 Creation"></a>19.2 Creation</h2><p>\1. gen_contour_nurbs_xld</p><p> 功能：将一个NURBS曲线转换为一个XLD（密度？）轮廓(contour)。</p><p>\2. gen_contour_polygon_rounded_xld</p><p> 功能：根据一个多边形（polygon）（以元组形式给出）的圆形角点创建一个XLD轮廓(contour)。</p><p>\3. gen_contour_polygon_xld</p><p> 功能：根据一个多边形（polygon）（以元组形式给出）创建一个XLD轮廓(contour)。</p><p>\4. gen_contour_region_xld</p><p> 功能：根据区域创建XLD轮廓(contour)。</p><p>\5. gen_contours_skeleton_xld</p><p> 功能：将框架转换为XLD轮廓(contour)。</p><p>\6. gen_cross_contour_xld</p><p> 功能：根据每个输入点交叉的形状创键一个XLD轮廓(contour)。</p><p>\7. gen_ellipse_contour_xld</p><p> 功能：根据相应的椭圆弧创建一个XLD轮廓(contour)。</p><p>\8. gen_parallels_xld</p><p> 功能：提取并行XLD多边形（polygon）。</p><p>\9. gen_polygons_xld</p><p> 功能：根据多边形近似创建XLD轮廓(contour)。</p><p>\10. gen_rectangle2_contour_xld</p><p>  功能：创建一个矩形XLD轮廓(contour)。</p><p>\11. mod_parallels_xld</p><p>  功能：提取一个包括同质区域的并行XLD多边形（polygon）。</p><h2 id="19-3-Features"><a href="#19-3-Features" class="headerlink" title="19.3 Features"></a>19.3 Features</h2><p>\1. area_center_points_xld</p><p> 功能：被看做点云的轮廓(contour)和多边形（polygon）的面积和重心。</p><p>\2. area_center_xld</p><p> 功能：轮廓(contour)和多边形（polygon）的面积和重心。</p><p>\3. circularity_xld</p><p> 功能：影响轮廓(contour)或多边形（polygon）圆度（与圆相近的程度）的形状系数。</p><p>\4. compactness_xld</p><p> 功能：影响轮廓(contour)或多边形（polygon）致密性的形状系数。</p><p>\5. contour_point_num_xld</p><p> 功能：返回一个XLD轮廓(contour)中点的数目。</p><p>\6. convexity_xld</p><p> 功能：影响轮廓(contour)或多边形（polygon）凹凸性的形状系数。</p><p>\7. diameter_xld</p><p> 功能：两个轮廓(contour)或多边形（polygon）点间的最大距离。</p><p>\8. dist_ellipse_contour_points_xld</p><p> 功能：计算所有轮廓(contour)内的点到一个椭圆的距离。</p><p>\9. dist_ellipse_contour_xld</p><p> 功能：轮廓到一个椭圆的距离。</p><p>\10. dist_rectangle2_contour_points_xld_</p><p>  功能：计算所有轮廓(contour)内的点到一个矩形的距离。</p><p>\11. eccentricity_points_xld_</p><p>  功能：被看做点云的轮廓(contour)或多变形（polygon）的Anisometry。</p><p>\12. eccentricity_xld</p><p>  功能：源自轮廓(contour)或多边形（polygon）的椭圆参数的形状系数。</p><p>\13. elliptic_axis_points_xld</p><p>  功能：被看做点云的轮廓(contour)或多边形（polygon）的等价椭圆参数。</p><p>\14. elliptic_axis_xld</p><p>  功能：轮廓(contour)或多变形（polygon）的等价椭圆参数。</p><p>\15. fit_circle_contour_xld</p><p>  功能：根据圆周近似获取XLD轮廓(contour)。</p><p>\16. fit_ellipse_contour_xld</p><p>  功能：根据椭圆或椭圆弧近似获取XLD轮廓(contour)。</p><p>\17. fit_line_contour_xld</p><p>  功能：根据分割线近似获取XLD轮廓(contour)。</p><p>\18. fit_rectangle2_contour_xld</p><p>  功能：用矩形来匹配XLD轮廓(contour)。</p><p>\19. get_contour_angle_xld</p><p>  功能：为每个轮廓(contour)点计算一个XLD轮廓(contour)方向。</p><p>\20. get_contour_attrib_xld</p><p>  功能：返回一个XLD轮廓(contour)的点的特征值。</p><p>\21. get_contour_global_attrib_xld</p><p>  功能：返回一个XLD轮廓(contour)的全局特征值。</p><p>\22. get_regress_params_xld</p><p>  功能：返回XLD轮廓(contour)参数。</p><p>\23. info_parallels_xld</p><p>  功能：返回被XLD多边形（polygon）包围的区域的灰度值的信息。</p><p>\24. length_xld</p><p>  功能：轮廓(contour)或多边形（polygon）的长度。</p><p>\25. local_max_contours_xld</p><p>  功能：选择局域最大灰度值的XLD轮廓(contour)。</p><p>\26. max_parallels_xld</p><p>  功能：合并具有相同多边形（polygon）的重建XLD并行。</p><p>\27. moments_any_points_xld</p><p>  功能：被看做点云的轮廓(contour)或多变形（polygon）的任意几何时刻（moments）。</p><p>\28. moments_any_xld</p><p>  功能：轮廓(contour)或多变形（polygon）的任意集合时刻（moments）。</p><p>\29. moments_points_xld</p><p>  功能：被看做点云的轮廓(contour)或多变形（polygon）的几何时刻（moments）M20,_M02,<em>和</em>M11。</p><p>\30. moments_xld</p><p>  功能：轮廓(contour)或多变形的几何时刻（moments）M20,_M02,_and_M11。</p><p>\31. orientation_points_xld</p><p>  功能：被看做点云的轮廓(contour)或多变形（polygon）的方向。</p><p>\32. orientation_xld</p><p>  功能：轮廓(contour)或多变形（polygon）的方向。</p><p>\33. query_contour_attribs_xld</p><p>  功能：返回一个XLD轮廓(contour)定义的属性的名字。</p><p>\34. query_contour_global_attribs_xld</p><p>  功能：返回一个XLD轮廓(contour)定义的全局属性的名字。</p><p>\35. select_contours_xld</p><p>  功能：根据一些特征选择XLD轮廓(contour)。</p><p>\36. select_shape_xld</p><p>  功能：根据形状特征选择轮廓(contour)或多边形（polygon）。</p><p>\37. select_xld_point</p><p>  功能：选择包括给定点在内的所有的轮廓(contour)或多边形（polygon）。</p><p>\38. smallest_circle_xld</p><p>  功能：轮廓(contour)或多边形（polygon）的最小封闭圆。</p><p>\39. smallest_rectangle1_xld</p><p>  功能：平行与轮廓(contour)或多边形（polygon）的坐标轴的封闭矩形。</p><p>\40. smallest_rectangle2_xld</p><p>  功能：轮廓(contour)或多边形（polygon）任意方向的最小封闭矩形。</p><p>\41. test_self_intersection_xld</p><p>  功能：测试轮廓(contour)或多边形（polygon）自身相交性。</p><p>\42. test_xld_point</p><p>  功能：测试一个或多个包括给定点在内的轮廓(contour)或多边形（polygon）。</p><h2 id="19-4-Geometric-Transformations"><a href="#19-4-Geometric-Transformations" class="headerlink" title="19.4 Geometric-Transformations"></a>19.4 Geometric-Transformations</h2><p>\1. affine_trans_contour_xld</p><p> 功能：对XLD轮廓(contour)进行一个任意二维仿射变换。</p><p>\2. affine_trans_polygon_xld</p><p> 功能：对XLD多边形（polygon）进行一个任意仿射变换。</p><p>\3. gen_parallel_contour_xld</p><p> 功能：计算一个XLD轮廓(contour)的平行轮廓(contour)。</p><p>\4. polar_trans_contour_xld</p><p> 功能：将一个环状弧中的轮廓(contour)转换为极坐标形式。</p><p>\5. polar_trans_contour_xld_inv</p><p> 功能：将极坐标下的轮廓(contour)转换为笛卡尔坐标下的形式。</p><p>\6. projective_trans_ontour_xld</p><p> 功能：对一个XLD轮廓(contour)进行射影变换。</p><h2 id="19-5-Sets"><a href="#19-5-Sets" class="headerlink" title="19.5 Sets"></a>19.5 Sets</h2><p>\1. difference_closed_contours_xld</p><p> 功能：闭合轮廓(contour)的差异。</p><p>\2. difference_closed_polygons_xld_</p><p> 功能：闭合多边形（polygon）的差异。</p><p>\3. intersection_closed_contours_xld</p><p> 功能：闭合轮廓(contour)的交集。</p><p>\4. intersection_closed_polygons_xld</p><p> 功能：闭合多边形（polygon）的交集。</p><p>\5. symm_difference_closed_contours_xld</p><p> 功能：闭合轮廓(contour)的对称差异。</p><p>\6. symm_difference_closed_polygons_xld</p><p> 功能：闭合多边形（polygon）的对称差异。</p><p>\7. union2_closed_contours_xld</p><p> 功能：闭合轮廓(contour)的并集。</p><p>\8. union2_closed_polygons_xld</p><p> 功能：闭合多边形（polygon）的并集。</p><h2 id="19-6-Transformation"><a href="#19-6-Transformation" class="headerlink" title="19.6 Transformation"></a>19.6 Transformation</h2><p>\1. add_noise_white_contour_xld</p><p> 功能：向XLD轮廓(contour)中加入噪声。</p><p>\2. clip_contours_xld</p><p> 功能：修剪一个XLD轮廓(contour)。</p><p>\3. close_contours_xld</p><p> 功能：关闭一个XLD轮廓(contour)。</p><p>\4. combine_roads_xld</p><p> 功能：合并两个等级分辨率中的路（road）。</p><p>\5. crop_contours_xld</p><p> 功能：切割一个XLD轮廓(contour)。</p><p>\6. merge_cont_line_scan_xld</p><p> 功能：合并连续线扫描图像中的XLD轮廓(contour)。</p><p>\7. regress_contours_xld</p><p> 功能：计算一个XLD轮廓(contour)回归线的参数。</p><p>\8. segment_contours_xld</p><p> 功能：将XLD轮廓(contour)分割为分割线和圆周或椭圆弧。</p><p>\9. shape_trans_xld</p><p> 功能：改变轮廓(contour)或多边形（polygon）的形状。</p><p>\10. smooth_contours_xld</p><p>  功能：XLD轮廓(contour)的平滑。</p><p>\11. sort_contours_xld</p><p>  功能：根据相关位置分类轮廓(contour)。</p><p>\12. split_contours_xld</p><p>  功能：在主要点分割XLD轮廓(contour)。</p><p>\13. union_adjacent_contours_xld</p><p>  功能：合并终点连接在一起的轮廓(contour)。</p><p>\14. union_cocircular_contours_xld</p><p>  功能：合并属于同一个圆周的轮廓(contour)。</p><p>\15. union_collinear_contours_ext_xld</p><p>  功能：合并位于同一条直线上的轮廓(contour)（由附加函数操作）。</p><p>\16. union_collinear_contours_xld</p><p>  功能：合并位于同一条直线上的轮廓(contour)。</p><p>\17. union_straight_contours_histo_xld</p><p>  功能：合并到给定线有相似距离的相邻直线轮廓(contour)。</p><p>\18. union_straight_contours_xld</p><p>  功能：合并具有相似方向的相邻直线轮廓(contour)。</p>]]></content>
      
      
      <categories>
          
          <category> 视觉 </category>
          
          <category> halcon </category>
          
      </categories>
      
      
        <tags>
            
            <tag> halcon </tag>
            
            <tag> 视觉 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>halcon封装C#</title>
      <link href="/2020/08/23/halcon%E5%B0%81%E8%A3%85C/"/>
      <url>/2020/08/23/halcon%E5%B0%81%E8%A3%85C/</url>
      
        <content type="html"><![CDATA[<h1 id="halcon封装"><a href="#halcon封装" class="headerlink" title="halcon封装"></a>halcon封装</h1><h3 id="halcon导出"><a href="#halcon导出" class="headerlink" title="halcon导出"></a>halcon导出</h3><p>首先，在halcon里选择 <strong>文件 –&gt; 导出</strong> ， 在导出菜单中选择C#，窗口导出选择<strong>使用导出模板</strong>。点击导出后会<strong>获得cs后缀名的文件</strong>。</p><p>建议：最好把halcon的代码先封装成函数，这样在导出为C#的类中也存在相应的函数(例如把读取图片，处理图片等步骤封装成一个个函数)</p><h3 id="C-项目使用halcon导出的文件"><a href="#C-项目使用halcon导出的文件" class="headerlink" title="C#项目使用halcon导出的文件"></a>C#项目使用halcon导出的文件</h3><p>在Visual Studio 中新建<strong>C#的windows 窗体应用</strong>，在引用中<strong>添加引用halcondotnet.dll</strong>（halcondotnet.dll在halcon安装目录的bin-&gt;dotnet35目录下），在<strong>工具-&gt;选择工具箱项</strong>，在.NET Framework组件中点击浏览，选择halcondotnet.dll，这时可看见已添加<strong>HsmarkWindowControl和HWindowControl</strong>（这是图片的显示控件），然后在项目添加现有项，选择halcon导出的cs文件。</p><p>这时，便可在Form1.cs[设计] 中点击工具箱，添加<strong>HsmarkWindowControl或HWindowControl</strong>到窗口，并添加button来控制图片的显示和处理。</p><p><strong>Form1.cs</strong>中先引用halcon</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">using HalconDotNet;</span><br></pre></td></tr></table></figure><h3 id="Form1-cs中使用halcon导出的类"><a href="#Form1-cs中使用halcon导出的类" class="headerlink" title="Form1.cs中使用halcon导出的类"></a><strong>Form1.cs</strong>中使用halcon导出的类</h3><p>先在Form1的类中定义halcon导出的类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HDevelopExport hd &#x3D; new HDevelopExport();</span><br><span class="line">HWindow hwindow; &#x2F;&#x2F; 窗口</span><br></pre></td></tr></table></figure><p>在Form1的创建函数(public Form1)中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hwindow &#x3D; hSmartWindowControl1.HalconWindow;</span><br><span class="line">hd.InitHalcon();</span><br></pre></td></tr></table></figure><p>然后button的点击函数中使用hancon类的处理函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hd.RunHalcon(hwindow);</span><br></pre></td></tr></table></figure><p>这时，最简单的halcon导出便完成了。</p><h1 id="图片的缩放功能"><a href="#图片的缩放功能" class="headerlink" title="图片的缩放功能"></a>图片的缩放功能</h1><p>在Form1的类中先创建my_MouseWheel函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">private void my_MouseWheel(object sender, MouseEventArgs e)</span><br><span class="line"> &#123;</span><br><span class="line">     System.Drawing.Point pt &#x3D; this.Location;</span><br><span class="line">     int leftBorder &#x3D; hSmartWindowControl1.Location.X;</span><br><span class="line">     int rightBorder &#x3D; hSmartWindowControl1.Location.X + hSmartWindowControl1.Size.Width;</span><br><span class="line">     int topBorder &#x3D; hSmartWindowControl1.Location.Y;</span><br><span class="line">     int bottomBorder &#x3D; hSmartWindowControl1.Location.Y + hSmartWindowControl1.Size.Height;</span><br><span class="line">    &#x2F;&#x2F;先判断鼠标位置在hSmartWindowControl窗口里</span><br><span class="line">     if(e.X &gt; leftBorder &amp;&amp; e.X&lt;rightBorder &amp;&amp; e.Y&gt; topBorder &amp;&amp; e.Y&lt;bottomBorder)</span><br><span class="line">     &#123;</span><br><span class="line">         MouseEventArgs newe &#x3D; new MouseEventArgs(e.Button, e.Clicks,</span><br><span class="line">                                              e.X - pt.X, e.Y - pt.Y, e.Delta);</span><br><span class="line">         hSmartWindowControl1.HSmartWindowControl_MouseWheel(sender, newe);</span><br><span class="line">     &#125;           </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>在Form1的创建函数(public Form1)中监听</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this.MouseWheel +&#x3D; new System.Windows.Forms.MouseEventHandler(this.my_MouseWheel);</span><br></pre></td></tr></table></figure><h1 id="读取任意图片-打开资源管理器选择"><a href="#读取任意图片-打开资源管理器选择" class="headerlink" title="读取任意图片(打开资源管理器选择)"></a>读取任意图片(打开资源管理器选择)</h1><p>打开资源管理器选择图片获取图片的地址</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">OpenFileDialog ofd &#x3D; new OpenFileDialog();</span><br><span class="line">if (ofd.ShowDialog() !&#x3D; DialogResult.OK)</span><br><span class="line">              return;</span><br><span class="line">string fileName &#x3D; ofd.FileName;</span><br></pre></td></tr></table></figure><p>图片显示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HObject ho_image &#x3D; new HObject();</span><br><span class="line">HOperatorSet.ReadImage(out ho_image, fileName);</span><br><span class="line">HTuple hv_width, hv_height;</span><br><span class="line">HOperatorSet.GetImageSize(ho_image, out hv_width, out hv_height);</span><br><span class="line"></span><br><span class="line">HOperatorSet.DispObj(ho_image, hwindow);</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public void readImage (out HObject ho_Image, HTuple hv_address)</span><br><span class="line">  &#123;</span><br><span class="line">    HTuple hv_Width &#x3D; new HTuple(), hv_Height &#x3D; new HTuple();</span><br><span class="line">    HTuple hv_WindowID &#x3D; new HTuple();</span><br><span class="line">    HOperatorSet.GenEmptyObj(out ho_Image);</span><br><span class="line">    ho_Image.Dispose();</span><br><span class="line">    HOperatorSet.ReadImage(out ho_Image, hv_address);</span><br><span class="line">    hv_Width.Dispose();hv_Height.Dispose();</span><br><span class="line">    HOperatorSet.GetImageSize(ho_Image, out hv_Width, out hv_Height);</span><br><span class="line">    using (HDevDisposeHelper dh &#x3D; new HDevDisposeHelper())</span><br><span class="line">    &#123;</span><br><span class="line">    hv_WindowID.Dispose();</span><br><span class="line">    dev_open_window_fit_image(ho_Image, 0, 0, hv_Width&#x2F;10, hv_Height&#x2F;10, out hv_WindowID);</span><br><span class="line">    &#125;</span><br><span class="line">    HOperatorSet.DispObj(ho_Image, hv_ExpDefaultWinHandle);</span><br><span class="line">    hv_Width.Dispose();</span><br><span class="line">    hv_Height.Dispose();</span><br><span class="line">    hv_WindowID.Dispose();</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 视觉 </category>
          
          <category> halcon </category>
          
      </categories>
      
      
        <tags>
            
            <tag> halcon </tag>
            
            <tag> 视觉 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>halcon仿射变化</title>
      <link href="/2020/08/11/halcon%E4%BB%BF%E5%B0%84%E5%8F%98%E5%8C%96/"/>
      <url>/2020/08/11/halcon%E4%BB%BF%E5%B0%84%E5%8F%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h1 id="仿射变换"><a href="#仿射变换" class="headerlink" title="仿射变换"></a>仿射变换</h1><h2 id="算子："><a href="#算子：" class="headerlink" title="算子："></a>算子：</h2><h3 id="orientation-region"><a href="#orientation-region" class="headerlink" title="orientation_region"></a>orientation_region</h3><p>​    求区域的角度（配合 <strong>area_center</strong> 使用）</p><h3 id="vector-angle-to-rigid"><a href="#vector-angle-to-rigid" class="headerlink" title="vector_angle_to_rigid"></a>vector_angle_to_rigid</h3><p>​    <strong>求取仿射变换的矩阵</strong>（只能旋转和平移）</p><h3 id="affine-trans-image"><a href="#affine-trans-image" class="headerlink" title="affine_trans_image"></a>affine_trans_image</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector_angle_to_rigid</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 视觉 </category>
          
          <category> halcon </category>
          
      </categories>
      
      
        <tags>
            
            <tag> halcon </tag>
            
            <tag> 视觉 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lua元表</title>
      <link href="/2020/07/17/Lua%E5%85%83%E8%A1%A8/"/>
      <url>/2020/07/17/Lua%E5%85%83%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="lua元表详解"><a href="#lua元表详解" class="headerlink" title="lua元表详解"></a><a href="https://www.cnblogs.com/blueberryzzz/p/8947446.html" target="_blank" rel="noopener">lua元表详解</a></h1><h3 id="元表的作用"><a href="#元表的作用" class="headerlink" title="元表的作用"></a>元表的作用</h3><p><strong>元表是用来定义对table或userdata操作方式的表</strong></p><p>举个例子</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> t1 = &#123;<span class="number">1</span>&#125;</span><br><span class="line"><span class="keyword">local</span> t2 = &#123;<span class="number">2</span>&#125;</span><br><span class="line"><span class="keyword">local</span> t3 = t1 + t2</span><br></pre></td></tr></table></figure><p>我们直接对两个table执行＋运算，会报错</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lua: /usercode/file.lua:<span class="number">3</span>: attempt to perform arithmetic on <span class="keyword">local</span> <span class="string">'t1'</span> (a <span class="built_in">table</span> value)</span><br></pre></td></tr></table></figure><p>因为程序不知道如何对两个表执行+运行，这时候就需要通过元表来定义如何执行t1的+运算，有点类似于c语言中的运算符重载。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> mt = &#123;&#125;</span><br><span class="line"><span class="comment">--定义mt.__add元方法（其实就是元表中一个特殊的索引值）为将两个表的元素合并后返回一个新表</span></span><br><span class="line">mt.<span class="built_in">__add</span> = <span class="function"><span class="keyword">function</span><span class="params">(t1,t2)</span></span></span><br><span class="line"><span class="keyword">local</span> temp = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> _,v <span class="keyword">in</span> <span class="built_in">pairs</span>(t1) <span class="keyword">do</span></span><br><span class="line"><span class="built_in">table</span>.<span class="built_in">insert</span>(temp,v)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">for</span> _,v <span class="keyword">in</span> <span class="built_in">pairs</span>(t2) <span class="keyword">do</span></span><br><span class="line"><span class="built_in">table</span>.<span class="built_in">insert</span>(temp,v)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">return</span> temp</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">local</span> t1 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line"><span class="keyword">local</span> t2 = &#123;<span class="number">2</span>&#125;</span><br><span class="line"><span class="comment">--设置t1的元表为mt</span></span><br><span class="line"><span class="built_in">setmetatable</span>(t1,mt)</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> t3 = t1 + t2</span><br><span class="line"><span class="comment">--输出t3</span></span><br><span class="line"><span class="keyword">local</span> st = <span class="string">"&#123;"</span></span><br><span class="line"><span class="keyword">for</span> _,v <span class="keyword">in</span> <span class="built_in">pairs</span>(t3) <span class="keyword">do</span></span><br><span class="line">st = st..v..<span class="string">", "</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">st = st..<span class="string">"&#125;"</span></span><br><span class="line"><span class="built_in">print</span>(st)</span><br></pre></td></tr></table></figure><p>结果为：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, &#125;</span><br></pre></td></tr></table></figure><p>因为程序在执行t1+t2的时候，会去调用t1的元表mt的<strong>add元方法进行计算。<br><strong>具体的过程是：</strong><br>1.查看t1是否有元表，若有，则查看t1的元表是否有</strong>add元方法，若有则调用。<br>2.查看t2是否有元表，若有，则查看t2的元表是否有<strong>add元方法，若有则调用。<br>3.若都没有则会报错。<br>**所以说，我们通过定义了t1元表的</strong>add元方法，达到了让两个表通过+号来相加的效果**</p><h1 id="元表的元方法"><a href="#元表的元方法" class="headerlink" title="元表的元方法"></a>元表的元方法</h1><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td>__add</td><td>运算符 +</td></tr><tr><td>__sub</td><td>运算符 -</td></tr><tr><td>__mul</td><td>运算符 *</td></tr><tr><td>__ div</td><td>运算符 /</td></tr><tr><td>__mod</td><td>运算符 %</td></tr><tr><td>__unm</td><td>运算符 -（取反）</td></tr><tr><td>__concat</td><td>运算符 ..</td></tr><tr><td>__eq</td><td>运算符 ==</td></tr><tr><td>__lt</td><td>运算符 &lt;</td></tr><tr><td>__le</td><td>运算符 &lt;=</td></tr><tr><td>__call</td><td>当函数调用</td></tr><tr><td>__tostring</td><td>转化为字符串</td></tr><tr><td>__index</td><td>调用一个索引</td></tr><tr><td>__newindex</td><td>给一个索引赋值</td></tr></tbody></table><h2 id="add"><a href="#add" class="headerlink" title="__add"></a>__add</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">local metaTable &#x3D; &#123;&#125;</span><br><span class="line">-- 表合并</span><br><span class="line">metaTable.__add &#x3D; function (t1, t2)</span><br><span class="line">    local temp &#x3D; &#123;&#125;</span><br><span class="line">    for i, v in pairs(t1) do</span><br><span class="line">        table.insert(temp, v)</span><br><span class="line">    end</span><br><span class="line">    for i, v in pairs(t2) do</span><br><span class="line">        table.insert(temp, v)</span><br><span class="line">    end</span><br><span class="line">    return temp</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h2 id="tostring"><a href="#tostring" class="headerlink" title="__tostring"></a>__tostring</h2><p>__tostring可以修改table转化为字符串的行为</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> metaTable = &#123;&#125;</span><br><span class="line"><span class="comment">-- 打印方法（可以直接打印表）</span></span><br><span class="line">metaTable.<span class="built_in">__tostring</span> = <span class="function"><span class="keyword">function</span> <span class="params">(t)</span></span></span><br><span class="line">    <span class="keyword">local</span> s = <span class="string">"&#123;"</span></span><br><span class="line">    <span class="keyword">for</span> i, v <span class="keyword">in</span> <span class="built_in">ipairs</span>(t)  <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">if</span> i &gt; <span class="number">1</span> <span class="keyword">then</span></span><br><span class="line">            s = s..<span class="string">", "</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        s = s..v</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    s = s..<span class="string">"&#125;"</span></span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">-- 测试</span></span><br><span class="line"><span class="keyword">local</span> t = &#123;<span class="string">"ab"</span>, <span class="string">"cd"</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(a)  </span><br><span class="line"><span class="built_in">setmetatable</span>(t,metaTable)  <span class="built_in">print</span>(a)</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">table</span>: <span class="number">0x14e2050</span></span><br><span class="line">&#123;ab, cd&#125;</span><br></pre></td></tr></table></figure><h2 id="call"><a href="#call" class="headerlink" title="__call"></a>__call</h2><p>__call可以让table当做一个函数来使用。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> mt = &#123;&#125;</span><br><span class="line"><span class="comment">--__call的第一参数是表自己</span></span><br><span class="line">mt.<span class="built_in">__call</span> = <span class="function"><span class="keyword">function</span><span class="params">(mytable,...)</span></span></span><br><span class="line">    <span class="comment">--输出所有参数</span></span><br><span class="line">    <span class="keyword">for</span> _,v <span class="keyword">in</span> <span class="built_in">ipairs</span>&#123;...&#125; <span class="keyword">do</span></span><br><span class="line">        <span class="built_in">print</span>(v)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">t = &#123;&#125;</span><br><span class="line"><span class="built_in">setmetatable</span>(t,mt)</span><br><span class="line"><span class="comment">--将t当作一个函数调用</span></span><br><span class="line">t(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><h2 id="index"><a href="#index" class="headerlink" title="__index"></a>__index</h2><p>调用table的一个不存在的索引时，会使用到元表的<strong>index元方法，和前几个元方法不同，</strong>index可以是一个函数也可是一个table。<br><strong>作为函数：</strong><br>将表和索引作为参数传入__index元方法，return一个返回值</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> mt = &#123;&#125;</span><br><span class="line"><span class="comment">--第一个参数是表自己，第二个参数是调用的索引</span></span><br><span class="line">mt.<span class="built_in">__index</span> = <span class="function"><span class="keyword">function</span><span class="params">(t,key)</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"it is "</span>..key</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">t = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line"><span class="comment">--输出未定义的key索引，输出为nil</span></span><br><span class="line"><span class="built_in">print</span>(t.key)</span><br><span class="line"><span class="built_in">setmetatable</span>(t,mt)</span><br><span class="line"><span class="comment">--设置元表后输出未定义的key索引，调用元表的__index函数，返回"it is key"输出</span></span><br><span class="line"><span class="built_in">print</span>(t.key)</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">nil</span></span><br><span class="line">it is key</span><br></pre></td></tr></table></figure><p><strong>作为table：</strong><br>查找__index元方法表，若有该索引，则返回该索引对应的值，否则返回nil</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> mt = &#123;&#125;</span><br><span class="line">mt.<span class="built_in">__index</span> = &#123;key = <span class="string">"it is key"</span>&#125;</span><br><span class="line"></span><br><span class="line">t = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line"><span class="comment">--输出未定义的key索引，输出为nil</span></span><br><span class="line"><span class="built_in">print</span>(t.key)</span><br><span class="line"><span class="built_in">setmetatable</span>(t,mt)</span><br><span class="line"><span class="comment">--输出表中未定义，但元表的__index中定义的key索引时，输出__index中的key索引值"it is key"</span></span><br><span class="line"><span class="built_in">print</span>(t.key)</span><br><span class="line"><span class="comment">--输出表中未定义，但元表的__index中也未定义的值时，输出为nil</span></span><br><span class="line"><span class="built_in">print</span>(t.key2)</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">nil</span></span><br><span class="line">it is key</span><br><span class="line"><span class="literal">nil</span></span><br></pre></td></tr></table></figure><h2 id="newindex"><a href="#newindex" class="headerlink" title="__newindex"></a>__newindex</h2><p>当为table中一个不存在的索引赋值时，会去调用元表中的__newindex元方法<br><strong>作为函数</strong><br>__newindex是一个函数时会将赋值语句中的表、索引、赋的值当作参数去调用。不对表进行改变</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> mt = &#123;&#125;</span><br><span class="line"><span class="comment">--第一个参数时表自己，第二个参数是索引，第三个参数是赋的值</span></span><br><span class="line">mt.<span class="built_in">__newindex</span> = <span class="function"><span class="keyword">function</span><span class="params">(t,index,value)</span></span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"index is "</span>..index)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"value is "</span>..value)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">t = &#123;key = <span class="string">"it is key"</span>&#125;</span><br><span class="line"><span class="built_in">setmetatable</span>(t,mt)</span><br><span class="line"><span class="comment">--输出表中已有索引key的值</span></span><br><span class="line"><span class="built_in">print</span>(t.key)</span><br><span class="line"><span class="comment">--为表中不存在的newKey索引赋值，调用了元表的__newIndex元方法，输出了参数信息</span></span><br><span class="line">t.newKey = <span class="number">10</span></span><br><span class="line"><span class="comment">--表中的newKey索引值还是空，上面看着是一个赋值操作，其实只是调用了__newIndex元方法，并没有对t中的元素进行改动</span></span><br><span class="line"><span class="built_in">print</span>(t.newKey)</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">it is key</span><br><span class="line">index is newKey</span><br><span class="line">value is <span class="number">10</span></span><br><span class="line"><span class="literal">nil</span></span><br></pre></td></tr></table></figure><p><strong>作为table</strong><br><strong>newindex是一个table时，为t中不存在的索引赋值会将该索引和值赋到</strong>newindex所指向的表中，不对原来的表进行改变。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> mt = &#123;&#125;</span><br><span class="line"><span class="comment">--将__newindex元方法设置为一个空表newTable</span></span><br><span class="line"><span class="keyword">local</span> newTable = &#123;&#125;</span><br><span class="line">mt.<span class="built_in">__newindex</span> = newTable</span><br><span class="line">t = &#123;&#125;</span><br><span class="line"><span class="built_in">setmetatable</span>(t,mt)</span><br><span class="line"><span class="built_in">print</span>(t.newKey,newTable.newKey)</span><br><span class="line"><span class="comment">--对t中不存在的索引进行负值时，由于t的元表中的__newindex元方法指向了一个表，所以并没有对t中的索引进行赋值操作将，而是将__newindex所指向的newTable的newKey索引赋值为了"it is newKey"</span></span><br><span class="line">t.newKey = <span class="string">"it is newKey"</span></span><br><span class="line"><span class="built_in">print</span>(t.newKey,newTable.newKey)</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">nil</span><span class="literal">nil</span></span><br><span class="line"><span class="literal">nil</span>it is newKey</span><br></pre></td></tr></table></figure><h2 id="rawget-和-rawset"><a href="#rawget-和-rawset" class="headerlink" title="rawget 和 rawset"></a>rawget 和 rawset</h2><p>有时候我们希望直接改动或获取表中的值时，就需要rawget和rawset方法了。<br><strong>rawget可以让你直接获取到表中索引的实际值，而不通过元表的__index元方法。</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> mt = &#123;&#125;</span><br><span class="line">mt.<span class="built_in">__index</span> = &#123;key = <span class="string">"it is key"</span>&#125;</span><br><span class="line">t = &#123;&#125;</span><br><span class="line"><span class="built_in">setmetatable</span>(t,mt)</span><br><span class="line"><span class="built_in">print</span>(t.key)</span><br><span class="line"><span class="comment">--通过rawget直接获取t中的key索引</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">rawget</span>(t,<span class="string">"key"</span>))</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">it is key</span><br><span class="line"><span class="literal">nil</span></span><br></pre></td></tr></table></figure><p><strong>rawset可以让你直接为表中索引的赋值，而不通过元表的__newindex元方法。</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> mt = &#123;&#125;</span><br><span class="line"><span class="keyword">local</span> newTable = &#123;&#125;</span><br><span class="line">mt.<span class="built_in">__newindex</span> = newTable</span><br><span class="line">t = &#123;&#125;</span><br><span class="line"><span class="built_in">setmetatable</span>(t,mt)</span><br><span class="line"><span class="built_in">print</span>(t.newKey,newTable.newKey)</span><br><span class="line"><span class="comment">--通过rawset直接向t的newKey索引赋值</span></span><br><span class="line"><span class="built_in">rawset</span>(t,<span class="string">"newKey"</span>,<span class="string">"it is newKey"</span>)</span><br><span class="line"><span class="built_in">print</span>(t.newKey,newTable.newKey)</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">nil</span><span class="literal">nil</span></span><br><span class="line">it is newKey<span class="literal">nil</span></span><br></pre></td></tr></table></figure><h1 id="元表的使用场景"><a href="#元表的使用场景" class="headerlink" title="元表的使用场景"></a>元表的使用场景</h1><h3 id="作为table的元表"><a href="#作为table的元表" class="headerlink" title="作为table的元表"></a>作为table的元表</h3><p>通过为table设置元表可以在lua中实现面向对象编程。</p><h3 id="作为userdata的元表"><a href="#作为userdata的元表" class="headerlink" title="作为userdata的元表"></a>作为userdata的元表</h3><p>通过对userdata和元表可以实现在lua中对c中的结构进行面向对象式的访问。</p><p><font size=5 color=blue >标注：引用自 <a href="https://www.cnblogs.com/blueberryzzz/p/8947446.html" target="_blank" rel="noopener">blueberryzzz博客</a>  </font></p>]]></content>
      
      
      <categories>
          
          <category> lua </category>
          
          <category> lua元表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> lua </tag>
            
            <tag> lua元表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>lua学习</title>
      <link href="/2020/07/16/lua%E5%AD%A6%E4%B9%A0/"/>
      <url>/2020/07/16/lua%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="lua"><a href="#lua" class="headerlink" title="lua"></a>lua</h1><h3 id="函数可变参数"><a href="#函数可变参数" class="headerlink" title="函数可变参数"></a>函数可变参数</h3><p>Lua 函数可以接受可变数目的参数，和 C 语言类似，在函数参数列表中<strong>使用三点 … 表示函数有可变的参数</strong>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function add(...)  </span><br><span class="line">  local s &#x3D; 0  </span><br><span class="line">  local arg &#x3D; &#123;...&#125;--&gt; arg 为一个表，局部变量</span><br><span class="line">  for i, v in ipairs(arg) do   --&gt; &#123;...&#125; 表示一个由所有变长参数构成的数组  </span><br><span class="line">    s &#x3D; s + v  </span><br><span class="line">  end  </span><br><span class="line">  return s  </span><br><span class="line">end  </span><br><span class="line">print(add(3,4,5,6,7))  ---&gt;25</span><br></pre></td></tr></table></figure><h2 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h2><h3 id="链接两个字符串-str1-str2"><a href="#链接两个字符串-str1-str2" class="headerlink" title="链接两个字符串    str1..str2"></a>链接两个字符串    str1..str2</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(&quot;www.runoob.&quot;..&quot;com&quot;)</span><br><span class="line">&#x3D;&gt;  www.runoob.com</span><br></pre></td></tr></table></figure><h3 id="字符串替换-string-gsub"><a href="#字符串替换-string-gsub" class="headerlink" title="字符串替换 string.gsub"></a>字符串替换 string.gsub</h3><p><strong>string.gsub(mainString,findString,replaceString,num)</strong></p><p>在字符串中替换。mainString 为要操作的字符串， findString 为被替换的字符，replaceString 要替换的字符，num 替换次数（可以忽略，则全部替换），如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string.gsub(&quot;aaaa&quot;,&quot;a&quot;,&quot;z&quot;,3);</span><br><span class="line">&#x3D;&gt;  zzza    3(3为替换的次数)</span><br></pre></td></tr></table></figure><h3 id="截取字符串-string-sub"><a href="#截取字符串-string-sub" class="headerlink" title="截取字符串  string.sub"></a>截取字符串  string.sub</h3><p>string.sub() 用于截取字符串，原型为：<code>string.sub(s, i [, j])</code>  截取字符串s的从第i个字符到第j个字符之间的串,j默认为-1,最后一个</p><h3 id="字符串查找-string-find"><a href="#字符串查找-string-find" class="headerlink" title="字符串查找  string.find"></a>字符串查找  <strong>string.find</strong></h3><p><strong>string.find (str, substr, [init, [end]])</strong>   若存在，<strong>则返回2个值</strong>：匹配串开始索引和结束索引。若不存在，返回nil。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">local a, b &#x3D; string.find(&quot;Hello Lua user&quot;, &quot;Lua&quot;, 1)</span><br><span class="line">print(a, b)</span><br><span class="line">&#x3D;&gt; 7  9</span><br></pre></td></tr></table></figure><h3 id="字符串匹对-string-match"><a href="#字符串匹对-string-match" class="headerlink" title="字符串匹对  string.match"></a>字符串匹对  string.match</h3><p><strong>string.match(str, pattern, init)</strong></p><p>string.match()只寻找源字串str中的第一个配对. 参数init可选, 指定搜寻过程的起点, 默认为1。<br>在成功配对时, 函数将返回配对表达式中的所有捕获结果; 如果没有设置捕获标记, 则返回整个配对字符串. 当没有成功的配对时, 返回nil。</p><p>pattern没有指定captures,那么将返回整个匹配内容。<strong>capture是指pattern中用小括号括起来的内容</strong>。<strong>比如print(string.match(“hello world”, “h(ell)o wor”)),这将打印ell</strong>，如果没有这个小括号呢，比如print(string.match(“hello world”, “hello”)),这将打印hello.这就是与“hello”整个相匹配的内容都返回了。</p><p><strong>pattern 要了解lua的正则表达式</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">local str &#x3D; &quot;ACK(22,33,55)&quot;</span><br><span class="line">local res &#x3D; string.match(str, &quot;ACK%((.-)%)$&quot;)  --&gt;  22,33,55</span><br><span class="line">local n1, n2, n3 &#x3D; string.match(s, &quot;(%d+),(%d+),(%d+),&quot;)  --&gt;  22   33  55</span><br></pre></td></tr></table></figure><h3 id="string-gmatch-str-pattern"><a href="#string-gmatch-str-pattern" class="headerlink" title="string.gmatch(str, pattern)"></a>string.gmatch(str, pattern)</h3><p><strong>返回一个迭代器函数</strong>，<strong>每一次调用这个函数，返回一个在字符串 str 找到的下一个符合 pattern 描述的子串</strong>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">local str &#x3D; &quot;Hello Lua user&quot;</span><br><span class="line">local fun &#x3D; string.gmatch(str, &quot;%a+&quot;)</span><br><span class="line">print(fun(),fun(),fun())</span><br><span class="line">&#x3D;&gt;  Hello  Lua  user</span><br></pre></td></tr></table></figure><h3 id="字符串反转-string-reverse-arg"><a href="#字符串反转-string-reverse-arg" class="headerlink" title="字符串反转   string.reverse(arg)"></a>字符串反转   string.reverse(arg)</h3><h3 id="字符串长度-string-len-arg"><a href="#字符串长度-string-len-arg" class="headerlink" title="字符串长度    string.len(arg)"></a>字符串长度    string.len(arg)</h3><h3 id="格式化字符串-string-format"><a href="#格式化字符串-string-format" class="headerlink" title="格式化字符串   string.format"></a>格式化字符串   string.format</h3><p>生成具有特定格式的字符串,第一个参数为格式化串：由指示符和控制格式的字符组成。参数如同C语言的print语法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">local y &#x3D; &#39;2019&#39;; local m &#x3D; &#39;12&#39;; local d &#x3D; &#39;15&#39;;</span><br><span class="line">print(string.format(&quot;%2d&#x2F;%2d&#x2F;%2d&quot;,m, d, y))  &#x3D;&gt;  12&#x2F;15&#x2F;2019</span><br></pre></td></tr></table></figure><h3 id="字符串大小写转换-string-upper-string-lower"><a href="#字符串大小写转换-string-upper-string-lower" class="headerlink" title="字符串大小写转换  string.upper  string.lower"></a>字符串大小写转换  string.upper  string.lower</h3><h3 id="字符串拷贝-string-rep-string-n"><a href="#字符串拷贝-string-rep-string-n" class="headerlink" title="字符串拷贝   string.rep(string, n)"></a>字符串拷贝   string.rep(string, n)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string.rep(&quot;abcd&quot;,2)   &#x3D;&gt;  abcdabcd注意：不改变字符串本身</span><br></pre></td></tr></table></figure><h2 id="Lua-数组"><a href="#Lua-数组" class="headerlink" title="Lua 数组"></a>Lua 数组</h2><p><strong>定义    array = {item1, item2}</strong></p><h3 id="数组的遍历"><a href="#数组的遍历" class="headerlink" title="数组的遍历"></a>数组的遍历</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for key,value in ipairs(array) </span><br><span class="line">do</span><br><span class="line">   print(key, value)</span><br><span class="line">end</span><br><span class="line"> &#x3D;&#x3D;&gt; key 为1，2  value为值， 数组for...in 循环第一个参数也是key</span><br></pre></td></tr></table></figure><h2 id="Lua-表"><a href="#Lua-表" class="headerlink" title="Lua 表"></a>Lua 表</h2><p><strong>定义   mytable = {}</strong></p><h3 id="table-方法"><a href="#table-方法" class="headerlink" title="table 方法"></a>table 方法</h3><h4 id="插入-table-insert-table-pos-value"><a href="#插入-table-insert-table-pos-value" class="headerlink" title="插入  table.insert (table, [pos,] value)"></a>插入  <strong>table.insert</strong> (table, [pos,] value)</h4><p>在table的数组部分指定位置(pos)插入值为value的一个元素. pos参数可选, <strong>默认为数组部分末尾</strong></p><h4 id="移除-table-remove-table-pos"><a href="#移除-table-remove-table-pos" class="headerlink" title="移除  table.remove (table [, pos])"></a>移除  table.remove (table [, pos])</h4><p>返回table数组部分位于pos位置的元素. 其后的元素会被前移. pos参数可选, 默认为table长度, 即从<strong>最后一个元素删起</strong>。</p><h4 id="排序-table-sort-table-comp"><a href="#排序-table-sort-table-comp" class="headerlink" title="排序  table.sort (table [, comp])"></a>排序  table.sort (table [, comp])</h4><p>对给定的table进行升序排序。</p><h4 id="长度-table"><a href="#长度-table" class="headerlink" title="长度   #table"></a>长度   #table</h4><p>也可以自定义方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function table_leng(t)</span><br><span class="line">  local leng&#x3D;0</span><br><span class="line">  for k, v in pairs(t) do</span><br><span class="line">    leng&#x3D;leng+1</span><br><span class="line">  end</span><br><span class="line">  return leng;</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h4 id="Table-连接成字符串-table-concat-table-sep-start-end"><a href="#Table-连接成字符串-table-concat-table-sep-start-end" class="headerlink" title="Table 连接成字符串  table.concat (table [, sep [, start [, end]]])"></a>Table 连接成字符串  table.concat (table [, sep [, start [, end]]])</h4><p>concat是concatenate(连锁, 连接)的缩写. table.concat()函数列出参数中指定table的数组部分从start位置到end位置的所有元素, <strong>元素间以指定的分隔符(sep)隔开</strong>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">local arr &#x3D; &#123;&quot;as&quot;, &quot;bs&quot;, &quot;cs&quot;, &quot;ds&quot;&#125;</span><br><span class="line">print(table.concat(arr))    &#x3D;&gt;   asbscsds</span><br><span class="line">print(table.concat(arr, &quot; &quot;, 2, 3))&#x3D;&gt; bs cs</span><br></pre></td></tr></table></figure><h2 id="Lua-迭代器"><a href="#Lua-迭代器" class="headerlink" title="Lua 迭代器"></a>Lua 迭代器</h2><p>迭代器（iterator）是一种对象，它能够用来遍历标准模板库容器中的部分或全部元素，每个迭代器对象代表容器中的确定的地址。 <strong>Lua 默认提供的迭代函数 ipairs</strong></p><p>在 Lua 中迭代器是一种支持指针类型的结构，它可以遍历集合的每一个元素。</p><h3 id="泛型-for-迭代器"><a href="#泛型-for-迭代器" class="headerlink" title="泛型 for 迭代器"></a>泛型 for 迭代器</h3><p>泛型 for 在自己内部保存迭代函数，实际上它保存三个值：迭代函数、状态常量、控制变量。</p><p>泛型 for 迭代器提供了集合的 <strong>key/value 对</strong>，语法格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">array &#x3D; &#123;&quot;Google&quot;, &quot;Runoob&quot;&#125;</span><br><span class="line">for key,value in ipairs(array) </span><br><span class="line">do</span><br><span class="line">   print(key, value)</span><br><span class="line">end</span><br><span class="line"> &#x3D;&#x3D;&gt; key 为1，2  value为值， 数组for...in 循环第一个参数也是key</span><br></pre></td></tr></table></figure><h3 id="无状态的迭代器"><a href="#无状态的迭代器" class="headerlink" title="无状态的迭代器"></a>无状态的迭代器</h3><p>无状态的迭代器是指不保留任何状态的迭代器，因此在循环中我们可以利用无状态迭代器避免创建闭包花费额外的代价。</p><p>每一次迭代，迭代函数都是用两个变量（状态常量和控制变量）的值作为参数被调用，一个无状态的迭代器只利用这两个值可以获取下一个元素。</p><p>这种无状态迭代器的典型的简单的例子是 ipairs，它遍历数组的每一个元素。</p><h2 id="Lua的模块和包-module"><a href="#Lua的模块和包-module" class="headerlink" title="Lua的模块和包 module"></a>Lua的模块和包 module</h2><p>创建一个模块很简单，就是<strong>创建一个 table，然后把需要导出的常量、函数放入其中，最后返回这个 table</strong> 就行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">-- 文件名为 module.lua</span><br><span class="line">-- 定义一个名为 module 的模块</span><br><span class="line">module &#x3D; &#123;&#125;</span><br><span class="line"> </span><br><span class="line">-- 定义一个常量</span><br><span class="line">module.constant &#x3D; &quot;这是一个常量&quot;</span><br><span class="line"> </span><br><span class="line">-- 定义一个函数</span><br><span class="line">function module.func1()</span><br><span class="line">    io.write(&quot;这是一个公有函数！\n&quot;)</span><br><span class="line">end</span><br><span class="line"> </span><br><span class="line">local function func2()</span><br><span class="line">    print(&quot;这是一个私有函数！&quot;)</span><br><span class="line">end</span><br><span class="line"> </span><br><span class="line">function module.func3()</span><br><span class="line">    func2()</span><br><span class="line">end</span><br><span class="line"> </span><br><span class="line">return module</span><br></pre></td></tr></table></figure><h3 id="加载模块"><a href="#加载模块" class="headerlink" title="加载模块"></a>加载模块</h3><p>Lua提供了一个名为require的函数用来加载模块。要加载一个模块，只需要简单地调用就可以了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">require(&quot;&lt;模块名&gt;&quot;)   如require(&quot;module&quot;) 要求路径时如 require(&quot;&#x2F;module&#x2F;module&quot;)</span><br></pre></td></tr></table></figure><h2 id="Lua的正则表达式"><a href="#Lua的正则表达式" class="headerlink" title="Lua的正则表达式"></a>Lua的正则表达式</h2><p>​    网页跳转到：    <a href="https://blog.csdn.net/xiejunna/article/details/52161097" target="_blank" rel="noopener">Lua的正则表达式</a>    查看详细</p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/lanning5/blogCDN/img/md%E6%88%AA%E5%9B%BE/lua/lua%E6%AD%A3%E5%88%99.png" alt="正则表达式"></p>]]></content>
      
      
      <categories>
          
          <category> lua </category>
          
      </categories>
      
      
        <tags>
            
            <tag> lua </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++学习</title>
      <link href="/2020/07/16/C++%E5%AD%A6%E4%B9%A0/"/>
      <url>/2020/07/16/C++%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="枚举："><a href="#枚举：" class="headerlink" title="枚举："></a>枚举：</h3><p>枚举类型(enumeration)是C++中的一种派生数据类型，它是由用户定义的若干枚举常量的集合。</p><p>如果一个变量只有几种可能的值，可以定义为枚举(enumeration)类型。所谓”枚举”是指将变量的值一一列举出来，变量的值只能在列举出来的值的范围内。</p><h4 id="一般形式"><a href="#一般形式" class="headerlink" title="一般形式"></a>一般形式</h4><p>创建枚举，需要使用关键字 <strong>enum</strong>。枚举类型的一般形式为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">enum 枚举名&#123; </span><br><span class="line">     标识符[&#x3D;整型常数], </span><br><span class="line">     标识符[&#x3D;整型常数], </span><br><span class="line">... </span><br><span class="line">    标识符[&#x3D;整型常数]</span><br><span class="line">&#125; 枚举变量;</span><br></pre></td></tr></table></figure><p>如果枚举没有初始化, 即<strong>省掉”=整型常数”</strong>时, 则从第一个标识符开始。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">例如：</span><br><span class="line">enum color &#123; red, green, blue &#125; c;</span><br><span class="line">c &#x3D; blue;</span><br></pre></td></tr></table></figure><h4 id="枚举类型与基础类型的转换"><a href="#枚举类型与基础类型的转换" class="headerlink" title="枚举类型与基础类型的转换"></a><strong>枚举类型与基础类型的转换</strong></h4><p><strong>基础类型不能隐式转换为枚举类型； 枚举类型也不能隐式转换为基础类型。</strong></p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/lanning5/blogCDN/img/md%E6%88%AA%E5%9B%BE/C++/%E6%9E%9A%E4%B8%BE%E4%B8%8E%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2.png" alt="枚举类型与基础类型的转换"></p><h3 id="存储类"><a href="#存储类" class="headerlink" title="存储类"></a>存储类</h3><p>存储类定义 C++ 程序中变量/函数的范围（可见性）和生命周期。这些说明符放置在它们所修饰的类型之前。下面列出 C++ 程序中可用的存储类：</p><ul><li>auto</li><li>register</li><li>static</li><li>extern</li><li>mutable</li><li>thread_local (C++11)</li></ul><p>从 C++ 17 开始，auto 关键字不再是 C++ 存储类说明符，且 register 关键字被弃用。</p><h4 id="static-存储类"><a href="#static-存储类" class="headerlink" title="static 存储类"></a>static 存储类</h4><p><strong>static</strong> 存储类指示编译器在程序的生命周期内保持局部变量的存在，而不需要在每次它进入和离开作用域时进行创建和销毁。因此，<strong>使用 static 修饰局部变量可以在函数调用之间保持局部变量的值</strong>。</p><p>static 修饰符也可以应用于全局变量。当 static 修饰全局变量时，会使变量的作用域限制在声明它的文件内。</p><p>在 C++ 中，当 static 用在类数据成员上时，会导致仅有一个该成员的副本被类的所有对象共享。</p><center>实例：</center><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt; </span><br><span class="line">&#x2F;&#x2F; 函数声明 </span><br><span class="line">void func(void);</span><br><span class="line"> </span><br><span class="line">static int count &#x3D; 10; &#x2F;* 全局变量 *&#x2F;</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    while(count--)</span><br><span class="line">    &#123;</span><br><span class="line">       func();</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 函数定义</span><br><span class="line">void func( void )</span><br><span class="line">&#123;</span><br><span class="line">    static int i &#x3D; 5; &#x2F;&#x2F; 局部静态变量</span><br><span class="line">    i++;</span><br><span class="line">    std::cout &lt;&lt; &quot;变量 i 为 &quot; &lt;&lt; i ;</span><br><span class="line">    std::cout &lt;&lt; &quot; , 变量 count 为 &quot; &lt;&lt; count &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><center>结果</center><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">变量 i 为 6 , 变量 count 为 9</span><br><span class="line">变量 i 为 7 , 变量 count 为 8</span><br><span class="line">变量 i 为 8 , 变量 count 为 7</span><br><span class="line">变量 i 为 9 , 变量 count 为 6</span><br><span class="line">变量 i 为 10 , 变量 count 为 5</span><br><span class="line">变量 i 为 11 , 变量 count 为 4</span><br><span class="line">变量 i 为 12 , 变量 count 为 3</span><br><span class="line">变量 i 为 13 , 变量 count 为 2</span><br><span class="line">变量 i 为 14 , 变量 count 为 1</span><br><span class="line">变量 i 为 15 , 变量 count 为 0</span><br></pre></td></tr></table></figure><h4 id="extern-存储类"><a href="#extern-存储类" class="headerlink" title="extern 存储类"></a>extern 存储类</h4><p><strong>extern</strong> 存储类用于提供一个全局变量的引用，全局变量对所有的程序文件都是可见的。当您使用 ‘extern’ 时，对于无法初始化的变量，会把变量名指向一个之前定义过的存储位置。</p><p>当您有多个文件且定义了一个可以在其他文件中使用的全局变量或函数时，可以在其他文件中使用 <em>extern</em> 来得到已定义的变量或函数的引用。可以这么理解，<strong><em>extern</em> 是用来在另一个文件中声明一个全局变量或函数</strong>。</p><p>extern 修饰符通常用于当有两个或多个文件共享相同的全局变量或函数的时候，如下所示：</p><center>第一个文件：main.cpp</center><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int count ;</span><br><span class="line">extern void write_extern();</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">   count &#x3D; 5;</span><br><span class="line">   write_extern();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><center>第二个文件：support.cpp</center><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">extern int count;</span><br><span class="line"> </span><br><span class="line">void write_extern(void)</span><br><span class="line">&#123;</span><br><span class="line">   std::cout &lt;&lt; &quot;Count is &quot; &lt;&lt; count &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h3><p>位运算符作用于位，并逐位执行操作。</p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/lanning5/blogCDN/img/md%E6%88%AA%E5%9B%BE/C++/%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6.png" alt="位运算符"></p><h3 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h3><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/lanning5/blogCDN/img/md%E6%88%AA%E5%9B%BE/C++/%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7.png" alt="位运算符"></p><h3 id="解引用"><a href="#解引用" class="headerlink" title="解引用  *"></a>解引用  *</h3><p>指针前加 * 代表解引用， 找到指针指向的内存的数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int a &#x3D; 10; int *p; p &#x3D; &amp;a;</span><br></pre></td></tr></table></figure><h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><h3 id="常量指针"><a href="#常量指针" class="headerlink" title="常量指针"></a>常量指针</h3><p><strong>const int * p</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int a &#x3D; 10, b &#x3D; 20;</span><br><span class="line">const int * p &#x3D; &amp;a;</span><br><span class="line">p &#x3D; &amp;b &#x2F;&#x2F; 可以修改指针的指向</span><br></pre></td></tr></table></figure><p><font color=orange><strong>特点</strong>：<strong>指针的指向可以修改，但是指针指向的值不可以修改</strong></font></p><h3 id="指针常量"><a href="#指针常量" class="headerlink" title="指针常量"></a>指针常量</h3><p><strong>int * const p</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int a &#x3D; 10, b &#x3D; 20;</span><br><span class="line">const int * p &#x3D; &amp;a;</span><br><span class="line">*p &#x3D; 20 &#x2F;&#x2F; 可以修改指针指向的值</span><br></pre></td></tr></table></figure><p><font color=orange><strong>特点</strong>：<strong>指针的指向不可以修改，但是指针指向的值可以修改</strong></font></p><h3 id="const-既修饰指针，又修饰常量"><a href="#const-既修饰指针，又修饰常量" class="headerlink" title="const 既修饰指针，又修饰常量"></a>const 既修饰指针，又修饰常量</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int a &#x3D; 10, b &#x3D; 20;</span><br><span class="line">const int * const p &#x3D; &amp;a;</span><br></pre></td></tr></table></figure><p><font color=orange><strong>特点</strong>：<strong>既不可以修改指针的指向，又不可修改指针指向的值</strong></font></p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="值传递"><a href="#值传递" class="headerlink" title="值传递"></a>值传递</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void swap(a, b)&#123;</span><br><span class="line">int temp &#x3D; a;</span><br><span class="line">a &#x3D; b;</span><br><span class="line">b &#x3D; temp;</span><br><span class="line">&#125;</span><br><span class="line">swap(a,b)</span><br></pre></td></tr></table></figure><p><strong>值传递不会改变原有的数据</strong></p><h3 id="地址传递"><a href="#地址传递" class="headerlink" title="地址传递"></a>地址传递</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void swap(*a, *b)&#123;</span><br><span class="line">int temp &#x3D; *a;</span><br><span class="line">*a &#x3D; *b;</span><br><span class="line">*b &#x3D; temp;</span><br><span class="line">&#125;</span><br><span class="line">swap(&amp;a, &amp;b)</span><br></pre></td></tr></table></figure><p><strong>地址传递</strong></p><p><strong>jizhuomi.com</strong></p><p><strong>51halcon.com</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vs常用快捷键</title>
      <link href="/2020/07/15/vs%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
      <url>/2020/07/15/vs%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="vs"><a href="#vs" class="headerlink" title="vs"></a>vs</h1><h2 id="在vs中设置或查看快捷键"><a href="#在vs中设置或查看快捷键" class="headerlink" title="在vs中设置或查看快捷键"></a>在vs中设置或查看快捷键</h2><p>在工具栏    <font color=red>工具 =&gt; 选项 =&gt; 环境 =&gt; 键盘  </font>  中查看或修改快捷键</p><h2 id="常用快捷键"><a href="#常用快捷键" class="headerlink" title="常用快捷键"></a>常用快捷键</h2><p>智能提示：ctrl + J<br>CTRL + SHIFT + B 生成解决方案<br>F4 显示属性窗口<br>F5 运行调试<br>F10 跨过程序执行<br>F11 单步逐句执行<br>F7: 查看代码<br>Shift+F7: 查看窗体设计器<br>Ctrl+F: 查找<br>F3: 查找下一个<br>Ctrl+H: 替换<br>Ctrl+F5: 开始执行(不调试)<br>F9: 切换断点<br>Ctrl+Shift+F9: 删除全部断点<br>Ctrl+Shift+F: 在文件中查找<br>Ctrl+K,S: 插入外侧代码</p><p><font color=red>代码格式化：ctrl+E+F</font></p><p><font color=red>删除当前行      Ctrl+Shift+L</font>  </p><p><font color=red>注释    Ctrl + K + C    取消注释 Ctrl + K + U</font>  </p><p><font color=red>折叠代码  </font>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Ctrl + M + O: 折叠所有方法</span><br><span class="line"></span><br><span class="line">Ctrl + M + M: 折叠或者展开当前方法</span><br><span class="line"></span><br><span class="line">Ctrl + M + S: 折叠当前区域</span><br><span class="line"></span><br><span class="line">Ctrl + M + L: 展开所有方法</span><br></pre></td></tr></table></figure><p><font color=red>代码排版 ：</font>  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">格式化cs(选中)代码：Ctrl+k+f</span><br><span class="line"></span><br><span class="line">格式化aspx(文档)代码：Ctrl+k+d</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> vs </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>halcon基础学习</title>
      <link href="/2020/07/14/halcon%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
      <url>/2020/07/14/halcon%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="halcon"><a href="#halcon" class="headerlink" title="halcon"></a>halcon</h1><h2 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">控制变量</span><br><span class="line">arr :&#x3D; [1, 2, 3, 4, 5] &#x2F;&#x2F;数组</span><br><span class="line">num :&#x3D; |arr|&#x2F;&#x2F;num&#x3D;5 求模（注意：不是求绝对值）</span><br><span class="line">SingerElenment :&#x3D; arr[3]  &#x2F;&#x2F;SingerElenment&#x3D;4，取数组下标为3的值</span><br><span class="line">Part :&#x3D; arr[1:3] &#x2F;&#x2F;Part&#x3D;[2,3,4] 取下标从1到3的值</span><br><span class="line">Copy :&#x3D; arr[0: |arr|-1]&#x2F;&#x2F;Copy&#x3D;arr, 相当于复杂arr</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">简单的示例</span><br><span class="line">read_image(Image, &#39;filePath&#39;)&#x2F;&#x2F;读取图形， 第二个参数为图片的地址(路径)</span><br><span class="line">regiongrowing(Image, Regions, 3, 3, 6, 100)&#x2F;&#x2F;图像分割，区域增长，把整个图像分成各个区域</span><br><span class="line">count_obj(Regions, Number)&#x2F;&#x2F;统计区域的个数， 第二个参数为变量</span><br><span class="line">open_file(&#39;fileName&#39;, &#39;output&#39;, FileHandle)&#x2F;&#x2F;FileHandle 文件句柄</span><br><span class="line">for i :&#x3D; 1 to Number by 1</span><br><span class="line">select_obj (Regions, Selected, i)</span><br><span class="line">area_center (Selected, Area, Row, Column)</span><br><span class="line">fwrite_string (FileHandle, i + &#39; &#39; + Area)</span><br><span class="line">fnew_line(FileHandle)</span><br><span class="line">endfor</span><br><span class="line">close_file(FileHandle)</span><br></pre></td></tr></table></figure><h2 id="算子"><a href="#算子" class="headerlink" title="算子"></a>算子</h2><h3 id="图像滤波"><a href="#图像滤波" class="headerlink" title="图像滤波"></a>图像滤波</h3><p>图像增强：对比度增强，亮度校正，直方图归一化，直方图均衡化<br>平滑滤波：边缘保护和增强平滑，各向非同性滤波，高斯平滑，二项式滤波，<br>均值<br>滤波，阶梯滤波器（中值，分离系数中值滤波，加权中值等），中度滤波，Sigma滤波，切尾均值，椒盐噪声去除，递归平滑滤波<br>边缘滤波：Canny,Deriche,Lanser,Shen,Frei,Kirsch,Roberts,Prewitt,Roberts,Prewitt,Robinson,Sobel,<br>Laplace算子，高斯差分，高斯导数，边缘闭合<br>点滤波：Foerstner,Harris,Sojka亚像素精度点提取滤波器<br>纹理：Laws滤波（3×3，5×5，7×7），离差，熵<br>算术运算：比例缩放，加，减，乘，绝对值，最大值，最小值，翻转，平方根<br>颜色变换：CIElab,hsv,his,yiq,yuv,CIExyz,hls,his等<br>傅立叶变换：高速FFT；高斯，导数计算，Gabor滤波器，带通，高通，低通滤<br>波，能量，相位，权值计算<br>霍夫变换：线，圆检测。<br>其他类型滤波器：自定义滤波器，点滤波器，灰度骨架抽取，主成分分析，拓<br>扑骨架抽取，高斯金字塔变换，类型转换</p><h3 id="亚像素边缘及线提取"><a href="#亚像素边缘及线提取" class="headerlink" title="亚像素边缘及线提取"></a>亚像素边缘及线提取</h3><p>Canny,Deriche,Lanser和Sobel边缘检测算子；Facet模型及Steger线提取（精度高于1/50像素）；亚像素彩色边缘，线提取；亚像素阈值</p><h3 id="亚像素轮廓处理"><a href="#亚像素轮廓处理" class="headerlink" title="亚像素轮廓处理"></a>亚像素轮廓处理</h3><p>轮廓处理：仿射和投影变换；线，圆，椭圆和矩形的分割<br>提取及拟合：平行轮廓合并；集合算法（交集，并集，差集）；不同标准形状<br>生成<br>形状特征：面积，中心点，方向，圆度，紧密度，周长，椭圆轴，力矩，凸度，离心率，闭合区域（凸，圆，矩形）；基于形状特征的轮廓选择</p><h3 id="边缘位置测量"><a href="#边缘位置测量" class="headerlink" title="边缘位置测量"></a>边缘位置测量</h3><p>沿直线和圆弧的亚像素边缘提取；自动选择边缘（起点，终点，所有点，上<br>升，下降，边缘点对）；边界及边界对寻找评价函数</p><h3 id="Blob分析"><a href="#Blob分析" class="headerlink" title="Blob分析"></a>Blob分析</h3><p>阈值：全局，局部，自动<br>区域处理：连通域分析，骨架，连接点，终点，集合算法（交集，并集，差<br>集，补集）；闭合区域（矩形，圆，椭圆形，凸）；空洞填充，区域生成（矩<br>形，圆形，椭圆形，多边形，方格，网格，任意形状），访问（行程编码，链<br>码，轮廓，多边形）<br>灰度值特征：最小值，最大值，均值，方差，共生距阵，直方图，熵，模糊特<br>征，灰度距<br>形状特征：面积，中点，方向，圆度，直角度，紧密度，空洞数，周长，凸度，椭圆轴，2阶距，3阶距，离心率，Hamming距离，闭合区域（圆，矩形），距离<br>，空间关系，Euler数</p><h3 id="图像分割"><a href="#图像分割" class="headerlink" title="图像分割"></a>图像分割</h3><p>阈值：彩色，后验证分割<br>区域生长：梯度，均值，彩色，纹理<br>分类：基于多层神经网络，支持向量机或n维线性平面或曲面的分类器<br>可变化模型：基于参考图像和经过训练的在一定误差范围内的标准样本的分割</p><h3 id="形态学"><a href="#形态学" class="headerlink" title="形态学"></a>形态学</h3><p>二值形态学：明可夫斯基加减，膨胀，腐蚀，开运算，闭运算，击中击不中变<br>换，边界，修剪，加粗，细化，距离变换<br>灰度形态学：分水岭算法：膨胀，腐蚀，开运算，闭运算</p><h3 id="分类器"><a href="#分类器" class="headerlink" title="分类器"></a>分类器</h3><p>多层感知神经网络分类器：支持向量机分类器：非一致分布n维线平面或曲面的<br>数据集聚类算法</p><h3 id="几何变换"><a href="#几何变换" class="headerlink" title="几何变换"></a>几何变换</h3><p>旋转，比例缩放，平移，镜像，剪切，仿射，透视，极化变换：从点对应<br>到角的近似变换；含自动点匹配的图像融合图像；变形校正；拼图；线扫描图<br>像区域与边界融合</p><h3 id="模式匹配"><a href="#模式匹配" class="headerlink" title="模式匹配"></a>模式匹配</h3><p>基于灰度值，相关性，形状，任意大小和形状的多模板匹配；鲁棒性极佳<br>的识别算法，对于旋转，比例缩放，混乱及部分被遮挡物体和照明变化都能准<br>确识别；彩色及多通道图像的匹配；只需调用一次识别函数，即可识别不同目<br>标及之间有相对位置变化的目标；可以产生综合模型，比如从多边形的图像数<br>据中；自动判断原型</p><h3 id="3D匹配"><a href="#3D匹配" class="headerlink" title="3D匹配"></a>3D匹配</h3><p>从DXF CAD文件建立3维模型；通过三维空间内任意6自由度姿态进行基于<br>形状的匹配；对于混乱或部分被遮挡的物体和照明变化都能够准确识别</p><h3 id="条码及二维码识别"><a href="#条码及二维码识别" class="headerlink" title="条码及二维码识别"></a>条码及二维码识别</h3><p>1维条码识别：EAN13，EAN8，UPC-A，UPC-E，2/5工业，2/5插入式，Codabar,Code39,Code93,Code128,PharmaCode<br>2维码识别：ECC200，QR码，PDF417码；二维码印刷质量检测</p><p>光学字符识别（OCR）<br>基于字符的识别，特殊分割算法，旋转校正，训练字体，可选特征；为多种应<br>用进行字体训练</p><h3 id="光学字符验证（OCV）"><a href="#光学字符验证（OCV）" class="headerlink" title="光学字符验证（OCV）"></a>光学字符验证（OCV）</h3><p>基于灰度值的模板对比算法，对于亮度，位置以及大小变换均能得出一致性结<br>果。</p><h3 id="灰度校正"><a href="#灰度校正" class="headerlink" title="灰度校正"></a>灰度校正</h3><p>为了提供亚像素测量的精确度，对图像采集设备的响应曲线进行校正</p><h3 id="3D定标"><a href="#3D定标" class="headerlink" title="3D定标"></a>3D定标</h3><p>用多幅图像为针孔和远心面阵摄像机或线阵摄像机的内部及外部参数定标；自<br>动校正摄像机旋转；图像和点的变形校正</p><p>3D视觉<br>双目立体视觉：双摄像机标定；自动判断摄像机相对位置；图像校正；亚像素<br>精度的深度及差度计算<br>其它方法：基于聚焦变化的深度图像获取；基于双目视觉的测量</p><p>图像序列<br>背景估计；光流分析</p><p>Sockets的网络传输<br>在HALCON处理器之间变换图像，区域，XLD（轮廓数据）及控制参数</p><p>串口<br>读取或写入数据。</p>]]></content>
      
      
      <categories>
          
          <category> 视觉 </category>
          
          <category> halcon </category>
          
      </categories>
      
      
        <tags>
            
            <tag> halcon </tag>
            
            <tag> 视觉 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>markdown的一些语法</title>
      <link href="/2020/07/10/markdown%E7%9A%84%E4%B8%80%E4%BA%9B%E8%AF%AD%E6%B3%95/"/>
      <url>/2020/07/10/markdown%E7%9A%84%E4%B8%80%E4%BA%9B%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="markdown"><a href="#markdown" class="headerlink" title="markdown"></a>markdown</h1><p>Markdown是一种可以使用普通文本编辑器编写的<a href="https://baike.baidu.com/item/标记语言/5964436" target="_blank" rel="noopener"><strong>标记语言</strong></a>，通过简单的标记语法，它可以使普通文本内容具有一定的格式。blog文章的编写就需要掌握一些markdown的语法。</p><p>推荐使用的md编辑器：<a href="https://www.typora.io/" target="_blank" rel="noopener"><strong>typora</strong></a></p><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><h3 id="入门语法"><a href="#入门语法" class="headerlink" title="入门语法"></a>入门语法</h3><p><strong>标题</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 一级标题</span><br><span class="line">## 二级标题</span><br></pre></td></tr></table></figure><p><strong>加粗斜体</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">** 加粗的字体 **</span><br></pre></td></tr></table></figure><p><strong>分割线</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一行，连续输入三个星号 ***</span><br></pre></td></tr></table></figure><p><strong>表格插入</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">书籍名称|书籍编号|学时</span><br><span class="line">---|---|---</span><br><span class="line">计算机网络|002|48</span><br></pre></td></tr></table></figure><p><strong>引用</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;  引用文字</span><br></pre></td></tr></table></figure><p>这些都是很基本的入门语法，还有许多为列出，但是使用 <strong>typora</strong> 等编辑器这些基本语法都无需记牢，编辑器里功能都有，可以快速通过快捷键来写出格式，但是其它的一些格式编写编辑器里不提供，要自己掌握它们的语法去编写，例如居中，文字大小颜色等。</p><h2 id="常用语法"><a href="#常用语法" class="headerlink" title="常用语法"></a>常用语法</h2><h3 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h3><h4 id="颜色"><a href="#颜色" class="headerlink" title="颜色"></a>颜色</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">浅红色文字：&lt;font color&#x3D;&quot;#dd0000&quot;&gt;浅红色文字：&lt;&#x2F;font&gt;</span><br></pre></td></tr></table></figure><p><strong>效果</strong>：<img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/lanning5/blogCDN/img/md%E6%88%AA%E5%9B%BE/md%E8%AF%AD%E6%B3%95/fontcolor.png" alt="浅红色文字效果"></p><h4 id="字体大小"><a href="#字体大小" class="headerlink" title="字体大小"></a>字体大小</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">size为1：&lt;font size&#x3D;&quot;1&quot;&gt;size为1&lt;&#x2F;font&gt;</span><br></pre></td></tr></table></figure><p><strong>size 为1~7， 浏览器默认为3</strong></p><h4 id="标准字体"><a href="#标准字体" class="headerlink" title="标准字体"></a>标准字体</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;font face&#x3D;&quot;黑体&quot;&gt;我是黑体字&lt;&#x2F;font&gt;</span><br><span class="line"></span><br><span class="line">&lt;font face&#x3D;&quot;微软雅黑&quot;&gt;我是微软雅黑&lt;&#x2F;font&gt;</span><br><span class="line"></span><br><span class="line">&lt;font face&#x3D;&quot;STCAIYUN&quot;&gt;我是华文彩云</span><br></pre></td></tr></table></figure><h3 id="背景色"><a href="#背景色" class="headerlink" title="背景色"></a>背景色</h3><p><strong>bgcolor=颜色</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;table&gt;&lt;tr&gt;&lt;td bgcolor&#x3D;#FF00FF&gt;背景色的设置是按照十六进制颜色值：#7FFFD4&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;table&gt;</span><br></pre></td></tr></table></figure><p>效果：<img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/lanning5/blogCDN/img/md%E6%88%AA%E5%9B%BE/md%E8%AF%AD%E6%B3%95/bgcolor.png" alt="背景色展示"></p><h3 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h3><p><strong>基本形式</strong>是：<code>![]()</code> <code>![这里放图片描述](这里放图片链接)</code> 例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![背景色展示](https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;lanning5&#x2F;blogCDN&#x2F;img&#x2F;md截图&#x2F;md语法&#x2F;bgcolor.png)</span><br></pre></td></tr></table></figure><p>也可以用类 <strong>html5</strong>  标签语法格式</p><p><strong>定义尺寸</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img width &#x3D; &#39;550&#39; height &#x3D;&#39;50&#39; src &#x3D;&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;lanning5&#x2F;blogCDN&#x2F;img&#x2F;md截图&#x2F;md语法&#x2F;bgcolor.png&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure><h3 id="对齐方式"><a href="#对齐方式" class="headerlink" title="对齐方式"></a>对齐方式</h3><h4 id="居中"><a href="#居中" class="headerlink" title="居中"></a>居中</h4><h5 id="文字居中："><a href="#文字居中：" class="headerlink" title="文字居中："></a>文字居中：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;center&gt;诶嘿&lt;&#x2F;center&gt;</span><br></pre></td></tr></table></figure><h5 id="图片等居中"><a href="#图片等居中" class="headerlink" title="图片等居中"></a>图片等居中</h5><p><strong>align = center</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;div align&#x3D;center&gt;  &lt;img width &#x3D; &#39;550&#39; height &#x3D;&#39;50&#39; src &#x3D;&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;lanning5&#x2F;blogCDN&#x2F;img&#x2F;md截图&#x2F;md语法&#x2F;bgcolor.png&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><h4 id="左右对齐"><a href="#左右对齐" class="headerlink" title="左右对齐"></a>左右对齐</h4><p><strong>align = left</strong></p><h3 id="换行"><a href="#换行" class="headerlink" title="换行"></a>换行</h3><p><strong>连续两个以上空格+回车</strong>  or <code>&lt;br/&gt;</code></p><h3 id="特殊符号"><a href="#特殊符号" class="headerlink" title="特殊符号"></a>特殊符号</h3><p>利用 <strong>转义字符\</strong> 可输出符号本身 <code>\* 输出*字符</code></p><h4 id="其它特殊字符"><a href="#其它特殊字符" class="headerlink" title="其它特殊字符"></a>其它特殊字符</h4><p>使用 <strong>Unicode码</strong>  示例如下：</p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/lanning5/blogCDN/img/md%E6%88%AA%E5%9B%BE/md%E8%AF%AD%E6%B3%95/%E7%89%B9%E6%AE%8A%E5%AD%97%E7%AC%A6.png" alt="特殊字符"></p><p>字符对应的Unicode码，可以看这个网站：<a href="https://unicode-table.com/cn/" target="_blank" rel="noopener">https://unicode-table.com/cn/</a></p><h3 id="锚点"><a href="#锚点" class="headerlink" title="锚点"></a>锚点</h3><p>在预定的跳转到的位置添加 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">## 目录&#123;#index&#125;</span><br><span class="line">跳转到[目录](</span><br></pre></td></tr></table></figure><p> 然后在文档的其它地方写上连接到锚点的链接。</p><h2 id="高级用法"><a href="#高级用法" class="headerlink" title="高级用法"></a>高级用法</h2><h3 id="Todo-列表"><a href="#Todo-列表" class="headerlink" title="Todo 列表"></a>Todo 列表</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-[] 已处理的事情</span><br><span class="line"></span><br><span class="line">-[x] 未处理的事情</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/lanning5/blogCDN/img/md%E6%88%AA%E5%9B%BE/md%E8%AF%AD%E6%B3%95/todo.png" alt="Todo 列表展示"></p><h3 id="流程图-数学公式-序列图"><a href="#流程图-数学公式-序列图" class="headerlink" title="流程图 数学公式 序列图"></a>流程图 数学公式 序列图</h3><p>请参考CSDN 的一篇文章： <a href="https://blog.csdn.net/u014061630/article/details/81359144?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-9.nonecase&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-9.nonecase#4%E9%94%9A%E7%82%B9" target="_blank" rel="noopener">跳转</a></p>]]></content>
      
      
      <categories>
          
          <category> markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何用hexo建立自己的blog并部署到github中</title>
      <link href="/2020/07/07/%E5%A6%82%E4%BD%95%E7%94%A8hexo%E5%BB%BA%E7%AB%8B%E8%87%AA%E5%B7%B1%E7%9A%84blog%E5%B9%B6%E9%83%A8%E7%BD%B2%E5%88%B0github%E4%B8%AD/"/>
      <url>/2020/07/07/%E5%A6%82%E4%BD%95%E7%94%A8hexo%E5%BB%BA%E7%AB%8B%E8%87%AA%E5%B7%B1%E7%9A%84blog%E5%B9%B6%E9%83%A8%E7%BD%B2%E5%88%B0github%E4%B8%AD/</url>
      
        <content type="html"><![CDATA[<h1 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h1><p>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 <a href="http://daringfireball.net/projects/markdown/" target="_blank" rel="noopener">Markdown</a>（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p><p>hexo的网站：<a href="https://hexo.io/zh-cn" target="_blank" rel="noopener">hexo</a></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h3><ul><li><p><a href="http://nodejs.org/" target="_blank" rel="noopener">Node.js</a> (Node.js 版本需不低于 8.10，建议使用 Node.js 10.0 及以上版本)</p></li><li><p><a href="http://git-scm.com/" target="_blank" rel="noopener">Git</a></p><p>先安装这两个环境才能架设blog。</p></li></ul><h3 id="安装-Hexo"><a href="#安装-Hexo" class="headerlink" title="安装 Hexo"></a>安装 Hexo</h3><p>全局安装：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g hexo-cli</span><br></pre></td></tr></table></figure><h2 id="建站"><a href="#建站" class="headerlink" title="建站"></a>建站</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#&#x2F;&#x2F; &lt;folder&gt;是你的文件名  如 hexo init blog</span><br><span class="line">$ hexo init &lt;folder&gt;</span><br><span class="line">$ cd &lt;folder&gt;</span><br><span class="line">$ npm install</span><br></pre></td></tr></table></figure><p>建好后，可以运行<code>$ hexo server</code>查看你的本地博客</p><h2 id="部署到github中"><a href="#部署到github中" class="headerlink" title="部署到github中"></a>部署到github中</h2><ol><li><p>安装 <a href="https://github.com/hexojs/hexo-deployer-git" target="_blank" rel="noopener">hexo-deployer-git</a>.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i --save hexo-deployer-git</span><br></pre></td></tr></table></figure></li><li><p>在github创建一个新的repository，命名为<code>&lt;username&gt;.github.io</code></p></li><li><p>在 <strong>_config.yml</strong>（如果有已存在的请删除）添加如下配置：</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: https:&#x2F;&#x2F;github.com&#x2F;&lt;username&gt;&#x2F;&lt;project&gt;</span><br><span class="line">  #repo是github创建的地址 example, https:&#x2F;&#x2F;github.com&#x2F;hexojs&#x2F;hexojs.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><ol start="4"><li>运行<code>hexo g</code> and <code>hexo deploy</code>推送到github仓库</li></ol><h1 id="hexo-的指令"><a href="#hexo-的指令" class="headerlink" title="hexo 的指令"></a>hexo 的指令</h1><h2 id="官网网址"><a href="#官网网址" class="headerlink" title="官网网址"></a>官网网址</h2><p>hexo指令官网的网址： <a href="https://hexo.io/zh-cn/docs/commands" target="_blank" rel="noopener">网址</a></p><h2 id="常用的指令"><a href="#常用的指令" class="headerlink" title="常用的指令"></a>常用的指令</h2><h3 id="new"><a href="#new" class="headerlink" title="new"></a>new</h3><p>new指令是用来<strong>新建一篇文章</strong>，格式<code>hexo new [layout] &lt;title&gt;</code>  ，例如我要在blog新发布一篇文章，就可以</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new &quot;新建文章名&quot;</span><br></pre></td></tr></table></figure><p>这样，可以在source/_posts/ 文件夹中找到这个文件，直接编写即可。</p><p>要<strong>建立独立的页面</strong>，格式为<code>hexo new page &lt;title&gt;</code>或者<code>hexo new page --path &lt;path&gt; &lt;title&gt;</code> , 例如我要在blog 建立一个图片集页面，就可以 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new page photo</span><br></pre></td></tr></table></figure><p>我的photo页面下有壁纸子页面，壁纸的地址为photo/wallpaper/，则可以</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new page --path photo&#x2F;wallpaper&#x2F;index.md &quot;壁纸&quot;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> butterfly </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redux and react-redux</title>
      <link href="/2020/07/05/redux/"/>
      <url>/2020/07/05/redux/</url>
      
        <content type="html"><![CDATA[<h1 id="redux"><a href="#redux" class="headerlink" title="redux"></a>redux</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>React有props和state:</p><ol><li>props意味着父级分发下来的属性</li><li>state意味着组件内部可以自行管理的状态，并且整个React没有数据向上回溯的能力，这就是react的单向数据流</li></ol><p>这就意味着如果是一个数据状态非常复杂的应用，更多的时候发现<strong>React根本无法让两个组件互相交流</strong>，使用对方的数据，react的通过层级传递数据的这种方法是非常难受的，这个时候，迫切需要一个机制，<strong>把所有的state集中到组件顶部，能够灵活的将所有state各取所需的分发给所有的组件</strong>，是的，这就是redux</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ol><li>redux是的诞生是为了给 React 应用提供「可预测化的状态管理」机制。</li><li>Redux会将整个应用状态(其实也就是数据)存储到到一个地方，称为store</li><li>这个store里面保存一棵状态树(state tree)</li><li>组件改变state的唯一方法是通过调用store的dispatch方法，触发一个action，这个action被对应的reducer处理，于是state完成更新</li><li>组件可以派发(dispatch)行为(action)给store,而不是直接通知其它组件</li><li>其它组件可以通过订阅store中的状态(state)来刷新自己的视图</li></ol><h2 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h2><ol><li>创建reducer<ul><li>可以使用单独的一个reducer,也可以将多个reducer合并为一个reducer，即：<code>combineReducers()</code></li><li>action发出命令后将state放入reucer加工函数中，返回新的state,对state进行加工处理</li></ul></li><li>创建action<ul><li>用户是接触不到state的，只能有view触发，所以，这个action可以理解为指令，需要发出多少动作就有多少指令</li><li>action是一个对象，必须有一个叫type的参数，定义action类型</li></ul></li><li>创建的store，使用createStore方法<ul><li>store 可以理解为有多个加工机器的总工厂</li><li>提供subscribe，dispatch，getState这些方法。</li></ul></li></ol><h2 id="按步骤手把手实战。"><a href="#按步骤手把手实战。" class="headerlink" title="按步骤手把手实战。"></a>按步骤手把手实战。</h2><p>上述步骤，对应的序号，我会在相关代码标出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">npm install redux -S &#x2F;&#x2F; 安装</span><br><span class="line"></span><br><span class="line">import &#123; createStore &#125; from &#39;redux&#39; &#x2F;&#x2F; 引入</span><br><span class="line"></span><br><span class="line">const reducer &#x3D; (state &#x3D; &#123;count: 0&#125;, action) &#x3D;&gt; &#123;----------&gt; ⑴</span><br><span class="line">  switch (action.type)&#123;</span><br><span class="line">    case &#39;INCREASE&#39;: return &#123;count: state.count + 1&#125;;</span><br><span class="line">    case &#39;DECREASE&#39;: return &#123;count: state.count - 1&#125;;</span><br><span class="line">    default: return state;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const actions &#x3D; &#123;----------&gt;⑵</span><br><span class="line">  increase: () &#x3D;&gt; (&#123;type: &#39;INCREASE&#39;&#125;),</span><br><span class="line">  decrease: () &#x3D;&gt; (&#123;type: &#39;DECREASE&#39;&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const store &#x3D; createStore(reducer);----------&gt;⑶</span><br><span class="line"></span><br><span class="line">store.subscribe(() &#x3D;&gt;</span><br><span class="line">  console.log(store.getState())</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">store.dispatch(actions.increase()) &#x2F;&#x2F; &#123;count: 1&#125;</span><br><span class="line">store.dispatch(actions.increase()) &#x2F;&#x2F; &#123;count: 2&#125;</span><br><span class="line">store.dispatch(actions.increase()) &#x2F;&#x2F; &#123;count: 3&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>自己画了一张非常简陋的流程图，方便理解redux的工作流程</p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/lanning5/blogCDN/img/20200709000020.png" alt="img"></p><h1 id="react-redux"><a href="#react-redux" class="headerlink" title="react-redux"></a>react-redux</h1><p>刚开始就说了，如果把store直接集成到React应用的顶层props里面，只要各个子组件能访问到顶层props就行了，比如这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;顶层组件 store&#x3D;&#123;store&#125;&gt;</span><br><span class="line">  &lt;App &#x2F;&gt;</span><br><span class="line">&lt;&#x2F;顶层组件&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>不就ok了吗？这就是 react-redux。Redux 官方提供的 React 绑定库。 具有高效且灵活的特性。</p><h2 id="React-Redux-将组件区分为-容器组件-和-UI-组件"><a href="#React-Redux-将组件区分为-容器组件-和-UI-组件" class="headerlink" title="React Redux 将组件区分为 容器组件 和 UI 组件"></a><strong>React Redux 将组件区分为 容器组件 和 UI 组件</strong></h2><ol><li>前者会处理逻辑</li><li>后者只负责显示和交互，内部不处理逻辑，状态完全由外部掌控</li></ol><h2 id="两个核心"><a href="#两个核心" class="headerlink" title="两个核心"></a>两个核心</h2><h3 id="Provider"><a href="#Provider" class="headerlink" title="Provider"></a>Provider</h3><p>看我上边那个代码的<strong>顶层组件</strong>4个字。对，你没有猜错。这个顶级组件就是Provider,一般我们都将顶层组件包裹在Provider组件之中，这样的话，所有组件就都可以在react-redux的控制之下了,<strong>但是store必须作为参数放到Provider组件中去</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;Provider store &#x3D; &#123;store&#125;&gt;</span><br><span class="line">    &lt;App &#x2F;&gt;</span><br><span class="line">&lt;Provider&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">这个组件的目的是让所有组件都能够访问到Redux中的数据。 </span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="connect"><a href="#connect" class="headerlink" title="connect"></a>connect</h3><p>这个才是react-redux中比较难的部分，我们详细解释一下</p><p>首先，先记住下边的这行代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">connect(mapStateToProps, mapDispatchToProps)(MyComponent)</span><br></pre></td></tr></table></figure><h4 id="mapStateToProps"><a href="#mapStateToProps" class="headerlink" title="mapStateToProps"></a>mapStateToProps</h4><p>这个单词翻译过来就是<strong>把state映射到props中去</strong> ,其实也就是<strong>把Redux中的数据映射到React中的props中去。</strong></p><p>举个栗子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    const mapStateToProps &#x3D; (state) &#x3D;&gt; &#123;</span><br><span class="line">      return &#123;</span><br><span class="line">      &#x2F;&#x2F; prop : state.xxx  | 意思是将state中的某个数据映射到props中</span><br><span class="line">        foo: state.bar</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>然后渲染的时候就可以使用this.props.foo</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Foo extends Component &#123;</span><br><span class="line">    constructor(props)&#123;</span><br><span class="line">        super(props);</span><br><span class="line">    &#125;</span><br><span class="line">    render()&#123;</span><br><span class="line">        return(</span><br><span class="line">        &#x2F;&#x2F; 这样子渲染的其实就是state.bar的数据了</span><br><span class="line">            &lt;div&gt;this.props.foo&lt;&#x2F;div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Foo &#x3D; connect()(Foo);</span><br><span class="line">export default Foo;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>然后这样就可以完成渲染了</p><h4 id="mapDispatchToProps"><a href="#mapDispatchToProps" class="headerlink" title="mapDispatchToProps"></a>mapDispatchToProps</h4><p>这个单词翻译过来就是就是<strong>把各种dispatch也变成了props让你可以直接使用</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">const mapDispatchToProps &#x3D; (dispatch) &#x3D;&gt; &#123; &#x2F;&#x2F; 默认传递参数就是dispatch</span><br><span class="line">  return &#123;</span><br><span class="line">    onClick: () &#x3D;&gt; &#123;</span><br><span class="line">      dispatch(&#123;</span><br><span class="line">        type: &#39;increatment&#39;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br><span class="line">class Foo extends Component &#123;</span><br><span class="line">    constructor(props)&#123;</span><br><span class="line">        super(props);</span><br><span class="line">    &#125;</span><br><span class="line">    render()&#123;</span><br><span class="line">        return(</span><br><span class="line">        </span><br><span class="line">             &lt;button onClick &#x3D; &#123;this.props.onClick&#125;&gt;点击increase&lt;&#x2F;button&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Foo &#x3D; connect()(Foo);</span><br><span class="line">export default Foo;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>组件也就改成了上边这样，可以直接通过this.props.onClick，来调用dispatch,这样子就不需要在代码中来进行store.dispatch了</p><h4 id="mapDispatchToProps多种写法"><a href="#mapDispatchToProps多种写法" class="headerlink" title="mapDispatchToProps多种写法"></a>mapDispatchToProps多种写法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">传统写法：</span><br><span class="line">const mapDispatchToProps &#x3D; (dispatch)&#x3D;&gt;&#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    abc:(aaa)&#x3D;&gt;</span><br><span class="line">      dispatch(&#123;</span><br><span class="line">        type:&#39;ADD&#39;,</span><br><span class="line">        id:num++,</span><br><span class="line">        text:aaa,</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">      qqw:(aaa)&#x3D;&gt;&#123;</span><br><span class="line">          dispatch(&#123;</span><br><span class="line">              type:&#39;TYY&#39;,</span><br><span class="line">              id:num++,</span><br><span class="line">              text:aaa,</span><br><span class="line">          &#125;)</span><br><span class="line">      &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">或者：</span><br><span class="line">function mapDispatchToProps(dispatch) &#123;</span><br><span class="line">   return &#123;</span><br><span class="line">         onIncrement: (...args) &#x3D;&gt; dispatch(actions.onIncrement(...args)),</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">第二种写法：</span><br><span class="line">const ActionCreators &#x3D; &#123;</span><br><span class="line"> abc:aaa&#x3D;&gt;&#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            type:&#39;ADD&#39;,</span><br><span class="line">            id:num++,</span><br><span class="line">            text:aaa,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    qqw:aaa&#x3D;&gt;(&#123;</span><br><span class="line">        type:&#39;TYY&#39;,</span><br><span class="line">        id:num++,</span><br><span class="line">        text:aaa,</span><br><span class="line">    &#125;),</span><br><span class="line">&#125;</span><br><span class="line">const mapDispatchToProps &#x3D; ActionCreators</span><br><span class="line">实例：</span><br><span class="line">import &#123; creament, decreament, setcount &#125; from &#39;..&#x2F;redux&#x2F;actions.js&#39;</span><br><span class="line">import ReduxTest from &#39;..&#x2F;views&#x2F;reduxTest.jsx&#39;</span><br><span class="line"></span><br><span class="line">export default connect((state) &#x3D;&gt; (&#123;count: state.count &#125;), &#123;</span><br><span class="line">  creament,</span><br><span class="line">  decreament,</span><br><span class="line">  setcount,</span><br><span class="line">&#125;)(ReduxTest)</span><br><span class="line"></span><br><span class="line">方法三：</span><br><span class="line">const mapDispatchToProps &#x3D; (dispatch) &#x3D;&gt; &#123;</span><br><span class="line">return bindActionCreators(ActionCreators, dispatch)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>react-redux的基本介绍就到这里了</p><h1 id="Redux-DevTool"><a href="#Redux-DevTool" class="headerlink" title="Redux DevTool"></a>Redux DevTool</h1><p><code>npm i --save--dev redux-devtools-extension</code></p><h1 id="redux-saga"><a href="#redux-saga" class="headerlink" title="redux-saga"></a>redux-saga</h1><p>如果按照原始的redux工作流程，当组件中产生一个action后会直接触发reducer修改state，reducer又是一个纯函数，也就是不能再reducer中进行异步操作；</p><p><strong>而往往实际中，组件中发生的action后，在进入reducer之前需要完成一个异步任务,比如发送ajax请求后拿到数据后，再进入reducer,显然原生的redux是不支持这种操作的</strong></p><p>这个时候急需一个中间件来处理这种业务场景，目前最优雅的处理方式自然就是redux-saga</p><h2 id="核心讲解"><a href="#核心讲解" class="headerlink" title="核心讲解"></a>核心讲解</h2><h3 id="1、Saga-辅助函数"><a href="#1、Saga-辅助函数" class="headerlink" title="1、Saga 辅助函数"></a><strong>1、Saga 辅助函数</strong></h3><p>redux-saga提供了一些辅助函数，用来在一些特定的action 被发起到Store时派生任务，下面我先来讲解两个辅助函数：<code>takeEvery</code> 和 <code>takeLatest</code></p><ul><li><h4 id="takeEvery"><a href="#takeEvery" class="headerlink" title="takeEvery"></a>takeEvery</h4></li></ul><p><strong>takeEvery就像一个流水线的洗碗工，过来一个脏盘子就直接执行后面的洗碗函数，一旦你请了这个洗碗工他会一直执行这个工作，绝对不会停止接盘子的监听过程和触发洗盘子函数</strong></p><p>例如：每次点击 按钮去Fetch获取数据时时，我们发起一个 FETCH_REQUESTED 的 action。 我们想通过启动一个任务从服务器获取一些数据，来处理这个action，类似于</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">window.addEventLister(&#39;xxx&#39;,fn)</span><br></pre></td></tr></table></figure><p>当dispatch xxx的时候，就会执行fn方法，</p><p>首先我们创建一个将执行异步 action 的任务(也就是上边的fn)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; put：你就认为put就等于 dispatch就可以了；</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; call：可以理解为实行一个异步函数,是阻塞型的，只有运行完后面的函数，才会继续往下；</span><br><span class="line">&#x2F;&#x2F; 在这里可以片面的理解为async中的await！但写法直观多了！</span><br><span class="line">import &#123; call, put &#125; from &#39;redux-saga&#x2F;effects&#39;</span><br><span class="line"></span><br><span class="line">export function* fetchData(action) &#123;</span><br><span class="line">   try &#123;</span><br><span class="line">      const apiAjax &#x3D; (params) &#x3D;&gt; fetch(url, params);</span><br><span class="line">      const data &#x3D; yield call(apiAjax);</span><br><span class="line">      yield put(&#123;type: &quot;FETCH_SUCCEEDED&quot;, data&#125;);</span><br><span class="line">   &#125; catch (error) &#123;</span><br><span class="line">      yield put(&#123;type: &quot;FETCH_FAILED&quot;, error&#125;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>然后在每次 FETCH_REQUESTED action 被发起时启动上面的任务,也就<strong>相当于每次触发一个名字为 FETCH_REQUESTED 的action就会执行上边的任务</strong>,代码如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import &#123; takeEvery &#125; from &#39;redux-saga&#39;</span><br><span class="line"></span><br><span class="line">function* watchFetchData() &#123;</span><br><span class="line"></span><br><span class="line">  yield* takeEvery(&quot;FETCH_REQUESTED&quot;, fetchData)</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：上面的 takeEvery 函数可以使用下面的写法替换</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function* watchFetchData() &#123;</span><br><span class="line">  </span><br><span class="line">   while(true)&#123;</span><br><span class="line">     yield take(&#39;FETCH_REQUESTED&#39;);</span><br><span class="line">     yield fork(fetchData);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><ul><li><h4 id="takeLatest"><a href="#takeLatest" class="headerlink" title="takeLatest"></a>takeLatest</h4></li></ul><p>在上面的例子中，takeEvery <strong>允许多个 fetchData 实例同时启动</strong>，在某个特定时刻，我们可以启动一个新的 fetchData 任务， 尽管之前还有一个或多个 fetchData 尚未结束</p><p>如果我们<strong>只想得到最新那个请求的响应</strong>（例如，始终显示最新版本的数据），我们可以使用 takeLatest 辅助函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import &#123; takeLatest &#125; from &#39;redux-saga&#39;</span><br><span class="line"></span><br><span class="line">function* watchFetchData() &#123;</span><br><span class="line">  yield* takeLatest(&#39;FETCH_REQUESTED&#39;, fetchData)</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><strong>和takeEvery不同，在任何时刻 takeLatest 只允许执行一个 fetchData 任务，并且这个任务是最后被启动的那个，如果之前已经有一个任务在执行，那之前的这个任务会自动被取消</strong></p><h3 id="2、Effect-Creators"><a href="#2、Effect-Creators" class="headerlink" title="2、Effect Creators"></a><strong>2、Effect Creators</strong></h3><p>redux-saga框架提供了很多创建effect的函数，下面我们就来简单的介绍下开发中最常用的几种</p><ul><li>take(pattern)</li><li>put(action)</li><li>call(fn, …args)</li><li>fork(fn, …args)</li><li>select(selector, …args)</li></ul><h4 id="take-pattern"><a href="#take-pattern" class="headerlink" title="take(pattern)"></a><strong>take(pattern)</strong></h4><p>take函数可以理解为监听未来的action，它创建了一个命令对象，告诉middleware等待一个特定的action， Generator会暂停，直到一个与pattern匹配的action被发起，才会继续执行下面的语句，也就是说，take是一个阻塞的 effect</p><p>用法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function* watchFetchData() &#123;</span><br><span class="line">   while(true) &#123;</span><br><span class="line">   &#x2F;&#x2F; 监听一个type为 &#39;FETCH_REQUESTED&#39; 的action的执行，直到等到这个Action被触发，才会接着执行下面的 yield fork(fetchData)  语句</span><br><span class="line">     yield take(&#39;FETCH_REQUESTED&#39;);</span><br><span class="line">     yield fork(fetchData);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="put-action"><a href="#put-action" class="headerlink" title="put(action)"></a><strong>put(action)</strong></h4><p>put函数是用来发送action的 effect，你可以简单的<strong>把它理解成为redux框架中的dispatch函数</strong>，当put一个action后，reducer中就会计算新的state并返回，<strong>注意：</strong> <strong>put 也是阻塞 effect</strong></p><p>用法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">export function* toggleItemFlow() &#123;</span><br><span class="line">    let list &#x3D; []</span><br><span class="line">    &#x2F;&#x2F; 发送一个type为 &#39;UPDATE_DATA&#39; 的Action，用来更新数据，参数为 &#96;data：list&#96;</span><br><span class="line">    yield put(&#123;</span><br><span class="line">      type: actionTypes.UPDATE_DATA,</span><br><span class="line">      data: list</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="call-fn-…args"><a href="#call-fn-…args" class="headerlink" title="call(fn, …args)"></a><strong>call(fn, …args)</strong></h4><p><strong>call函数你可以把它简单的理解为就是可以调用其他函数的函数</strong>，它命令 middleware 来调用fn 函数， args为函数的参数，<strong>注意：</strong> <strong>fn 函数可以是一个 Generator 函数，也可以是一个返回 Promise 的普通函数</strong>，call 函数也是<strong>阻塞 effect</strong></p><p>用法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">export const delay &#x3D; ms &#x3D;&gt; new Promise(resolve &#x3D;&gt; setTimeout(resolve, ms))</span><br><span class="line"></span><br><span class="line">export function* removeItem() &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    &#x2F;&#x2F; 这里call 函数就调用了 delay 函数，delay 函数为一个返回promise 的函数</span><br><span class="line">    return yield call(delay, 500)</span><br><span class="line">  &#125; catch (err) &#123;</span><br><span class="line">    yield put(&#123;type: actionTypes.ERROR&#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="fork-fn-…args"><a href="#fork-fn-…args" class="headerlink" title="fork(fn, …args)"></a><strong>fork(fn, …args)</strong></h4><p>fork 函数和 call 函数很像，<strong>都是用来调用其他函数的，但是fork函数是非阻塞函数</strong>，也就是说，<strong>程序执行完 <code>yield fork(fn， args)</code> 这一行代码后，会立即接着执行下一行代码语句，而不会等待fn函数返回结果后</strong>，在执行下面的语句</p><p>用法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import &#123; fork &#125; from &#39;redux-saga&#x2F;effects&#39;</span><br><span class="line"></span><br><span class="line">export default function* rootSaga() &#123;</span><br><span class="line">  &#x2F;&#x2F; 下面的四个 Generator 函数会一次执行，不会阻塞执行</span><br><span class="line">  yield fork(addItemFlow)</span><br><span class="line">  yield fork(removeItemFlow)</span><br><span class="line">  yield fork(toggleItemFlow)</span><br><span class="line">  yield fork(modifyItem)</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="select-selector-…args"><a href="#select-selector-…args" class="headerlink" title="select(selector, …args)"></a><strong>select(selector, …args)</strong></h4><p>select 函数是用来指示 middleware调用提供的选择器获取Store上的state数据，你也可以简单的把它理解为<strong>redux框架中获取store上的 state数据一样的功能</strong> ：<code>store.getState()</code></p><p>用法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">export function* toggleItemFlow() &#123;</span><br><span class="line">     &#x2F;&#x2F; 通过 select effect 来获取 全局 state上的 &#96;getTodoList&#96; 中的 list</span><br><span class="line">     let tempList &#x3D; yield select(state &#x3D;&gt; state.getTodoList.list)</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h1 id="一个具体的实例"><a href="#一个具体的实例" class="headerlink" title="一个具体的实例"></a>一个具体的实例</h1><p>*<em>index.js *</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">import React from &#39;react&#39;;</span><br><span class="line">import ReactDOM from &#39;react-dom&#39;;</span><br><span class="line">import &#123;createStore, applyMiddleware&#125; from &#39;redux&#39;</span><br><span class="line">import createSagaMiddleware from &#39;redux-saga&#39;</span><br><span class="line"></span><br><span class="line">import rootSaga from &#39;.&#x2F;sagas&#39;</span><br><span class="line">import Counter from &#39;.&#x2F;Counter&#39;</span><br><span class="line">import rootReducer from &#39;.&#x2F;reducers&#39;</span><br><span class="line"></span><br><span class="line">const sagaMiddleware &#x3D; createSagaMiddleware() &#x2F;&#x2F; 创建了一个saga中间件实例</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 下边这句话和下边的两行代码创建store的方式是一样的</span><br><span class="line">&#x2F;&#x2F; const store &#x3D; createStore(reducers,applyMiddlecare(middlewares))</span><br><span class="line"></span><br><span class="line">const createStoreWithMiddleware &#x3D; applyMiddleware(middlewares)(createStore)</span><br><span class="line">const store &#x3D; createStoreWithMiddleware(rootReducer)</span><br><span class="line"></span><br><span class="line">sagaMiddleware.run(rootSaga)</span><br><span class="line"></span><br><span class="line">const action &#x3D; type &#x3D;&gt; store.dispatch(&#123; type &#125;)</span><br><span class="line"></span><br><span class="line">function render() &#123;</span><br><span class="line">  ReactDOM.render(</span><br><span class="line">    &lt;Counter</span><br><span class="line">      value&#x3D;&#123;store.getState()&#125;</span><br><span class="line">      onIncrement&#x3D;&#123;() &#x3D;&gt; action(&#39;INCREMENT&#39;)&#125;</span><br><span class="line">      onDecrement&#x3D;&#123;() &#x3D;&gt; action(&#39;DECREMENT&#39;)&#125;</span><br><span class="line">      onIncrementAsync&#x3D;&#123;() &#x3D;&gt; action(&#39;INCREMENT_ASYNC&#39;)&#125; &#x2F;&gt;,</span><br><span class="line">    document.getElementById(&#39;root&#39;)</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">render()</span><br><span class="line"></span><br><span class="line">store.subscribe(render)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><strong>sagas.js</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">import &#123; put, call, take,fork &#125; from &#39;redux-saga&#x2F;effects&#39;;</span><br><span class="line">import &#123; takeEvery, takeLatest &#125; from &#39;redux-saga&#39;</span><br><span class="line"></span><br><span class="line">export const delay &#x3D; ms &#x3D;&gt; new Promise(resolve &#x3D;&gt; setTimeout(resolve, ms));</span><br><span class="line"></span><br><span class="line">function* incrementAsync() &#123;</span><br><span class="line">  &#x2F;&#x2F; 延迟 1s 在执行 + 1操作</span><br><span class="line">  yield call(delay, 1000);</span><br><span class="line">  yield put(&#123; type: &#39;INCREMENT&#39; &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default function* rootSaga() &#123;</span><br><span class="line">  &#x2F;&#x2F; while(true)&#123;</span><br><span class="line">  &#x2F;&#x2F;   yield take(&#39;INCREMENT_ASYNC&#39;);</span><br><span class="line">  &#x2F;&#x2F;   yield fork(incrementAsync);</span><br><span class="line">  &#x2F;&#x2F; &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 下面的写法与上面的写法上等效</span><br><span class="line">  yield* takeEvery(&quot;INCREMENT_ASYNC&quot;, incrementAsync)</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><strong>reducer.js</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">export default function counter(state &#x3D; 0, action) &#123;</span><br><span class="line">  switch (action.type) &#123;</span><br><span class="line">    case &#39;INCREMENT&#39;:</span><br><span class="line">      return state + 1</span><br><span class="line">    case &#39;DECREMENT&#39;:</span><br><span class="line">      return state - 1</span><br><span class="line">    case &#39;INCREMENT_ASYNC&#39;:</span><br><span class="line">      return state</span><br><span class="line">    default:</span><br><span class="line">      return state</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>从上面的代码结构可以看出，redux-saga的使用方式还是比较简单的，相比较之前的redux框架的CounterApp，多了一个sagas的文件，reducers文件还是之前的使用方式</p><h3 id="redux-saga基本用法总结："><a href="#redux-saga基本用法总结：" class="headerlink" title="redux-saga基本用法总结："></a>redux-saga基本用法总结：</h3><ol><li><strong>使用 createSagaMiddleware 方法创建 saga 的 Middleware ，然后在创建的 redux 的 store 时，使用 applyMiddleware 函数将创建的 saga Middleware 实例绑定到 store 上，最后可以调用 saga Middleware 的 run 函数来执行某个或者某些 Middleware 。</strong></li><li><strong>在 saga 的 Middleware 中，可以使用 takeEvery 或者 takeLatest 等 API 来监听某个 action ，当某个 action 触发后， saga 可以使用 call 发起异步操作，操作完成后使用 put 函数触发 action ，同步更新 state ，从而完成整个 State 的更新。</strong></li></ol><hr><p>ok,故事到这里就接近尾声了，以上主要介绍了redux,react-redux和redux-saga目前redux全家桶主流的一些产品,接下来,主要会产出一下根据源码,<strong>手写一下redux和react-redux的轮子</strong></p>]]></content>
      
      
      <categories>
          
          <category> web前端 </category>
          
          <category> redux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web前端 </tag>
            
            <tag> redux </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
