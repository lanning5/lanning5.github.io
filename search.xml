<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>halcon封装C#</title>
      <link href="/2020/08/23/halcon%E5%B0%81%E8%A3%85C/"/>
      <url>/2020/08/23/halcon%E5%B0%81%E8%A3%85C/</url>
      
        <content type="html"><![CDATA[<h1 id="halcon封装"><a href="#halcon封装" class="headerlink" title="halcon封装"></a>halcon封装</h1><h3 id="halcon导出"><a href="#halcon导出" class="headerlink" title="halcon导出"></a>halcon导出</h3><p>首先，在halcon里选择 <strong>文件 –&gt; 导出</strong> ， 在导出菜单中选择C#，窗口导出选择<strong>使用导出模板</strong>。点击导出后会<strong>获得cs后缀名的文件</strong>。</p><p>建议：最好把halcon的代码先封装成函数，这样在导出为C#的类中也存在相应的函数(例如把读取图片，处理图片等步骤封装成一个个函数)</p><h3 id="C-项目使用halcon导出的文件"><a href="#C-项目使用halcon导出的文件" class="headerlink" title="C#项目使用halcon导出的文件"></a>C#项目使用halcon导出的文件</h3><p>在Visual Studio 中新建<strong>C#的windows 窗体应用</strong>，在引用中<strong>添加引用halcondotnet.dll</strong>（halcondotnet.dll在halcon安装目录的bin-&gt;dotnet35目录下），在<strong>工具-&gt;选择工具箱项</strong>，在.NET Framework组件中点击浏览，选择halcondotnet.dll，这时可看见已添加<strong>HsmarkWindowControl和HWindowControl</strong>（这是图片的显示控件），然后在项目添加现有项，选择halcon导出的cs文件。</p><p>这时，便可在Form1.cs[设计] 中点击工具箱，添加<strong>HsmarkWindowControl或HWindowControl</strong>到窗口，并添加button来控制图片的显示和处理。</p><p><strong>Form1.cs</strong>中先引用halcon</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">using HalconDotNet;</span><br></pre></td></tr></table></figure><h3 id="Form1-cs中使用halcon导出的类"><a href="#Form1-cs中使用halcon导出的类" class="headerlink" title="Form1.cs中使用halcon导出的类"></a><strong>Form1.cs</strong>中使用halcon导出的类</h3><p>先在Form1的类中定义halcon导出的类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HDevelopExport hd &#x3D; new HDevelopExport();</span><br><span class="line">HWindow hwindow; &#x2F;&#x2F; 窗口</span><br></pre></td></tr></table></figure><p>在Form1的创建函数(public Form1)中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hwindow &#x3D; hSmartWindowControl1.HalconWindow;</span><br><span class="line">hd.InitHalcon();</span><br></pre></td></tr></table></figure><p>然后button的点击函数中使用hancon类的处理函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hd.RunHalcon(hwindow);</span><br></pre></td></tr></table></figure><p>这时，最简单的halcon导出便完成了。</p><h1 id="图片的缩放功能"><a href="#图片的缩放功能" class="headerlink" title="图片的缩放功能"></a>图片的缩放功能</h1><p>在Form1的类中先创建my_MouseWheel函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">private void my_MouseWheel(object sender, MouseEventArgs e)</span><br><span class="line"> &#123;</span><br><span class="line">     System.Drawing.Point pt &#x3D; this.Location;</span><br><span class="line">     int leftBorder &#x3D; hSmartWindowControl1.Location.X;</span><br><span class="line">     int rightBorder &#x3D; hSmartWindowControl1.Location.X + hSmartWindowControl1.Size.Width;</span><br><span class="line">     int topBorder &#x3D; hSmartWindowControl1.Location.Y;</span><br><span class="line">     int bottomBorder &#x3D; hSmartWindowControl1.Location.Y + hSmartWindowControl1.Size.Height;</span><br><span class="line">    &#x2F;&#x2F;先判断鼠标位置在hSmartWindowControl窗口里</span><br><span class="line">     if(e.X &gt; leftBorder &amp;&amp; e.X&lt;rightBorder &amp;&amp; e.Y&gt; topBorder &amp;&amp; e.Y&lt;bottomBorder)</span><br><span class="line">     &#123;</span><br><span class="line">         MouseEventArgs newe &#x3D; new MouseEventArgs(e.Button, e.Clicks,</span><br><span class="line">                                              e.X - pt.X, e.Y - pt.Y, e.Delta);</span><br><span class="line">         hSmartWindowControl1.HSmartWindowControl_MouseWheel(sender, newe);</span><br><span class="line">     &#125;           </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>在Form1的创建函数(public Form1)中监听</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this.MouseWheel +&#x3D; new System.Windows.Forms.MouseEventHandler(this.my_MouseWheel);</span><br></pre></td></tr></table></figure><h1 id="读取任意图片-打开资源管理器选择"><a href="#读取任意图片-打开资源管理器选择" class="headerlink" title="读取任意图片(打开资源管理器选择)"></a>读取任意图片(打开资源管理器选择)</h1><p>打开资源管理器选择图片获取图片的地址</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">OpenFileDialog ofd &#x3D; new OpenFileDialog();</span><br><span class="line">if (ofd.ShowDialog() !&#x3D; DialogResult.OK)</span><br><span class="line">              return;</span><br><span class="line">string fileName &#x3D; ofd.FileName;</span><br></pre></td></tr></table></figure><p>图片显示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HObject ho_image &#x3D; new HObject();</span><br><span class="line">HOperatorSet.ReadImage(out ho_image, fileName);</span><br><span class="line">HTuple hv_width, hv_height;</span><br><span class="line">HOperatorSet.GetImageSize(ho_image, out hv_width, out hv_height);</span><br><span class="line"></span><br><span class="line">HOperatorSet.DispObj(ho_image, hwindow);</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public void readImage (out HObject ho_Image, HTuple hv_address)</span><br><span class="line">  &#123;</span><br><span class="line">    HTuple hv_Width &#x3D; new HTuple(), hv_Height &#x3D; new HTuple();</span><br><span class="line">    HTuple hv_WindowID &#x3D; new HTuple();</span><br><span class="line">    HOperatorSet.GenEmptyObj(out ho_Image);</span><br><span class="line">    ho_Image.Dispose();</span><br><span class="line">    HOperatorSet.ReadImage(out ho_Image, hv_address);</span><br><span class="line">    hv_Width.Dispose();hv_Height.Dispose();</span><br><span class="line">    HOperatorSet.GetImageSize(ho_Image, out hv_Width, out hv_Height);</span><br><span class="line">    using (HDevDisposeHelper dh &#x3D; new HDevDisposeHelper())</span><br><span class="line">    &#123;</span><br><span class="line">    hv_WindowID.Dispose();</span><br><span class="line">    dev_open_window_fit_image(ho_Image, 0, 0, hv_Width&#x2F;10, hv_Height&#x2F;10, out hv_WindowID);</span><br><span class="line">    &#125;</span><br><span class="line">    HOperatorSet.DispObj(ho_Image, hv_ExpDefaultWinHandle);</span><br><span class="line">    hv_Width.Dispose();</span><br><span class="line">    hv_Height.Dispose();</span><br><span class="line">    hv_WindowID.Dispose();</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 视觉 </category>
          
          <category> halcon </category>
          
      </categories>
      
      
        <tags>
            
            <tag> halcon </tag>
            
            <tag> 视觉 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>halcon仿射变化</title>
      <link href="/2020/08/11/halcon%E4%BB%BF%E5%B0%84%E5%8F%98%E5%8C%96/"/>
      <url>/2020/08/11/halcon%E4%BB%BF%E5%B0%84%E5%8F%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h1 id="仿射变换"><a href="#仿射变换" class="headerlink" title="仿射变换"></a>仿射变换</h1><h2 id="算子："><a href="#算子：" class="headerlink" title="算子："></a>算子：</h2><h3 id="orientation-region"><a href="#orientation-region" class="headerlink" title="orientation_region"></a>orientation_region</h3><p>​    求区域的角度（配合 <strong>area_center</strong> 使用）</p><h3 id="vector-angle-to-rigid"><a href="#vector-angle-to-rigid" class="headerlink" title="vector_angle_to_rigid"></a>vector_angle_to_rigid</h3><p>​    <strong>求取仿射变换的矩阵</strong>（只能旋转和平移）</p><h3 id="affine-trans-image"><a href="#affine-trans-image" class="headerlink" title="affine_trans_image"></a>affine_trans_image</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector_angle_to_rigid</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 视觉 </category>
          
          <category> halcon </category>
          
      </categories>
      
      
        <tags>
            
            <tag> halcon </tag>
            
            <tag> 视觉 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Halcon：基本例程算子</title>
      <link href="/2020/08/05/Halcon%EF%BC%9A%E5%9F%BA%E6%9C%AC%E4%BE%8B%E7%A8%8B%E7%AE%97%E5%AD%90/"/>
      <url>/2020/08/05/Halcon%EF%BC%9A%E5%9F%BA%E6%9C%AC%E4%BE%8B%E7%A8%8B%E7%AE%97%E5%AD%90/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Lua元表</title>
      <link href="/2020/07/17/Lua%E5%85%83%E8%A1%A8/"/>
      <url>/2020/07/17/Lua%E5%85%83%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="lua元表详解"><a href="#lua元表详解" class="headerlink" title="lua元表详解"></a><a href="https://www.cnblogs.com/blueberryzzz/p/8947446.html" target="_blank" rel="noopener">lua元表详解</a></h1><h3 id="元表的作用"><a href="#元表的作用" class="headerlink" title="元表的作用"></a>元表的作用</h3><p><strong>元表是用来定义对table或userdata操作方式的表</strong></p><p>举个例子</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> t1 = &#123;<span class="number">1</span>&#125;</span><br><span class="line"><span class="keyword">local</span> t2 = &#123;<span class="number">2</span>&#125;</span><br><span class="line"><span class="keyword">local</span> t3 = t1 + t2</span><br></pre></td></tr></table></figure><p>我们直接对两个table执行＋运算，会报错</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lua: /usercode/file.lua:<span class="number">3</span>: attempt to perform arithmetic on <span class="keyword">local</span> <span class="string">'t1'</span> (a <span class="built_in">table</span> value)</span><br></pre></td></tr></table></figure><p>因为程序不知道如何对两个表执行+运行，这时候就需要通过元表来定义如何执行t1的+运算，有点类似于c语言中的运算符重载。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> mt = &#123;&#125;</span><br><span class="line"><span class="comment">--定义mt.__add元方法（其实就是元表中一个特殊的索引值）为将两个表的元素合并后返回一个新表</span></span><br><span class="line">mt.<span class="built_in">__add</span> = <span class="function"><span class="keyword">function</span><span class="params">(t1,t2)</span></span></span><br><span class="line"><span class="keyword">local</span> temp = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> _,v <span class="keyword">in</span> <span class="built_in">pairs</span>(t1) <span class="keyword">do</span></span><br><span class="line"><span class="built_in">table</span>.<span class="built_in">insert</span>(temp,v)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">for</span> _,v <span class="keyword">in</span> <span class="built_in">pairs</span>(t2) <span class="keyword">do</span></span><br><span class="line"><span class="built_in">table</span>.<span class="built_in">insert</span>(temp,v)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">return</span> temp</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">local</span> t1 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line"><span class="keyword">local</span> t2 = &#123;<span class="number">2</span>&#125;</span><br><span class="line"><span class="comment">--设置t1的元表为mt</span></span><br><span class="line"><span class="built_in">setmetatable</span>(t1,mt)</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> t3 = t1 + t2</span><br><span class="line"><span class="comment">--输出t3</span></span><br><span class="line"><span class="keyword">local</span> st = <span class="string">"&#123;"</span></span><br><span class="line"><span class="keyword">for</span> _,v <span class="keyword">in</span> <span class="built_in">pairs</span>(t3) <span class="keyword">do</span></span><br><span class="line">st = st..v..<span class="string">", "</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">st = st..<span class="string">"&#125;"</span></span><br><span class="line"><span class="built_in">print</span>(st)</span><br></pre></td></tr></table></figure><p>结果为：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, &#125;</span><br></pre></td></tr></table></figure><p>因为程序在执行t1+t2的时候，会去调用t1的元表mt的<strong>add元方法进行计算。<br><strong>具体的过程是：</strong><br>1.查看t1是否有元表，若有，则查看t1的元表是否有</strong>add元方法，若有则调用。<br>2.查看t2是否有元表，若有，则查看t2的元表是否有<strong>add元方法，若有则调用。<br>3.若都没有则会报错。<br>**所以说，我们通过定义了t1元表的</strong>add元方法，达到了让两个表通过+号来相加的效果**</p><h1 id="元表的元方法"><a href="#元表的元方法" class="headerlink" title="元表的元方法"></a>元表的元方法</h1><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td>__add</td><td>运算符 +</td></tr><tr><td>__sub</td><td>运算符 -</td></tr><tr><td>__mul</td><td>运算符 *</td></tr><tr><td>__ div</td><td>运算符 /</td></tr><tr><td>__mod</td><td>运算符 %</td></tr><tr><td>__unm</td><td>运算符 -（取反）</td></tr><tr><td>__concat</td><td>运算符 ..</td></tr><tr><td>__eq</td><td>运算符 ==</td></tr><tr><td>__lt</td><td>运算符 &lt;</td></tr><tr><td>__le</td><td>运算符 &lt;=</td></tr><tr><td>__call</td><td>当函数调用</td></tr><tr><td>__tostring</td><td>转化为字符串</td></tr><tr><td>__index</td><td>调用一个索引</td></tr><tr><td>__newindex</td><td>给一个索引赋值</td></tr></tbody></table><h2 id="add"><a href="#add" class="headerlink" title="__add"></a>__add</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">local metaTable &#x3D; &#123;&#125;</span><br><span class="line">-- 表合并</span><br><span class="line">metaTable.__add &#x3D; function (t1, t2)</span><br><span class="line">    local temp &#x3D; &#123;&#125;</span><br><span class="line">    for i, v in pairs(t1) do</span><br><span class="line">        table.insert(temp, v)</span><br><span class="line">    end</span><br><span class="line">    for i, v in pairs(t2) do</span><br><span class="line">        table.insert(temp, v)</span><br><span class="line">    end</span><br><span class="line">    return temp</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h2 id="tostring"><a href="#tostring" class="headerlink" title="__tostring"></a>__tostring</h2><p>__tostring可以修改table转化为字符串的行为</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> metaTable = &#123;&#125;</span><br><span class="line"><span class="comment">-- 打印方法（可以直接打印表）</span></span><br><span class="line">metaTable.<span class="built_in">__tostring</span> = <span class="function"><span class="keyword">function</span> <span class="params">(t)</span></span></span><br><span class="line">    <span class="keyword">local</span> s = <span class="string">"&#123;"</span></span><br><span class="line">    <span class="keyword">for</span> i, v <span class="keyword">in</span> <span class="built_in">ipairs</span>(t)  <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">if</span> i &gt; <span class="number">1</span> <span class="keyword">then</span></span><br><span class="line">            s = s..<span class="string">", "</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        s = s..v</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    s = s..<span class="string">"&#125;"</span></span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">-- 测试</span></span><br><span class="line"><span class="keyword">local</span> t = &#123;<span class="string">"ab"</span>, <span class="string">"cd"</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(a)  </span><br><span class="line"><span class="built_in">setmetatable</span>(t,metaTable)  <span class="built_in">print</span>(a)</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">table</span>: <span class="number">0x14e2050</span></span><br><span class="line">&#123;ab, cd&#125;</span><br></pre></td></tr></table></figure><h2 id="call"><a href="#call" class="headerlink" title="__call"></a>__call</h2><p>__call可以让table当做一个函数来使用。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> mt = &#123;&#125;</span><br><span class="line"><span class="comment">--__call的第一参数是表自己</span></span><br><span class="line">mt.<span class="built_in">__call</span> = <span class="function"><span class="keyword">function</span><span class="params">(mytable,...)</span></span></span><br><span class="line">    <span class="comment">--输出所有参数</span></span><br><span class="line">    <span class="keyword">for</span> _,v <span class="keyword">in</span> <span class="built_in">ipairs</span>&#123;...&#125; <span class="keyword">do</span></span><br><span class="line">        <span class="built_in">print</span>(v)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">t = &#123;&#125;</span><br><span class="line"><span class="built_in">setmetatable</span>(t,mt)</span><br><span class="line"><span class="comment">--将t当作一个函数调用</span></span><br><span class="line">t(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><h2 id="index"><a href="#index" class="headerlink" title="__index"></a>__index</h2><p>调用table的一个不存在的索引时，会使用到元表的<strong>index元方法，和前几个元方法不同，</strong>index可以是一个函数也可是一个table。<br><strong>作为函数：</strong><br>将表和索引作为参数传入__index元方法，return一个返回值</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> mt = &#123;&#125;</span><br><span class="line"><span class="comment">--第一个参数是表自己，第二个参数是调用的索引</span></span><br><span class="line">mt.<span class="built_in">__index</span> = <span class="function"><span class="keyword">function</span><span class="params">(t,key)</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"it is "</span>..key</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">t = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line"><span class="comment">--输出未定义的key索引，输出为nil</span></span><br><span class="line"><span class="built_in">print</span>(t.key)</span><br><span class="line"><span class="built_in">setmetatable</span>(t,mt)</span><br><span class="line"><span class="comment">--设置元表后输出未定义的key索引，调用元表的__index函数，返回"it is key"输出</span></span><br><span class="line"><span class="built_in">print</span>(t.key)</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">nil</span></span><br><span class="line">it is key</span><br></pre></td></tr></table></figure><p><strong>作为table：</strong><br>查找__index元方法表，若有该索引，则返回该索引对应的值，否则返回nil</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> mt = &#123;&#125;</span><br><span class="line">mt.<span class="built_in">__index</span> = &#123;key = <span class="string">"it is key"</span>&#125;</span><br><span class="line"></span><br><span class="line">t = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line"><span class="comment">--输出未定义的key索引，输出为nil</span></span><br><span class="line"><span class="built_in">print</span>(t.key)</span><br><span class="line"><span class="built_in">setmetatable</span>(t,mt)</span><br><span class="line"><span class="comment">--输出表中未定义，但元表的__index中定义的key索引时，输出__index中的key索引值"it is key"</span></span><br><span class="line"><span class="built_in">print</span>(t.key)</span><br><span class="line"><span class="comment">--输出表中未定义，但元表的__index中也未定义的值时，输出为nil</span></span><br><span class="line"><span class="built_in">print</span>(t.key2)</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">nil</span></span><br><span class="line">it is key</span><br><span class="line"><span class="literal">nil</span></span><br></pre></td></tr></table></figure><h2 id="newindex"><a href="#newindex" class="headerlink" title="__newindex"></a>__newindex</h2><p>当为table中一个不存在的索引赋值时，会去调用元表中的__newindex元方法<br><strong>作为函数</strong><br>__newindex是一个函数时会将赋值语句中的表、索引、赋的值当作参数去调用。不对表进行改变</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> mt = &#123;&#125;</span><br><span class="line"><span class="comment">--第一个参数时表自己，第二个参数是索引，第三个参数是赋的值</span></span><br><span class="line">mt.<span class="built_in">__newindex</span> = <span class="function"><span class="keyword">function</span><span class="params">(t,index,value)</span></span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"index is "</span>..index)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"value is "</span>..value)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">t = &#123;key = <span class="string">"it is key"</span>&#125;</span><br><span class="line"><span class="built_in">setmetatable</span>(t,mt)</span><br><span class="line"><span class="comment">--输出表中已有索引key的值</span></span><br><span class="line"><span class="built_in">print</span>(t.key)</span><br><span class="line"><span class="comment">--为表中不存在的newKey索引赋值，调用了元表的__newIndex元方法，输出了参数信息</span></span><br><span class="line">t.newKey = <span class="number">10</span></span><br><span class="line"><span class="comment">--表中的newKey索引值还是空，上面看着是一个赋值操作，其实只是调用了__newIndex元方法，并没有对t中的元素进行改动</span></span><br><span class="line"><span class="built_in">print</span>(t.newKey)</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">it is key</span><br><span class="line">index is newKey</span><br><span class="line">value is <span class="number">10</span></span><br><span class="line"><span class="literal">nil</span></span><br></pre></td></tr></table></figure><p><strong>作为table</strong><br><strong>newindex是一个table时，为t中不存在的索引赋值会将该索引和值赋到</strong>newindex所指向的表中，不对原来的表进行改变。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> mt = &#123;&#125;</span><br><span class="line"><span class="comment">--将__newindex元方法设置为一个空表newTable</span></span><br><span class="line"><span class="keyword">local</span> newTable = &#123;&#125;</span><br><span class="line">mt.<span class="built_in">__newindex</span> = newTable</span><br><span class="line">t = &#123;&#125;</span><br><span class="line"><span class="built_in">setmetatable</span>(t,mt)</span><br><span class="line"><span class="built_in">print</span>(t.newKey,newTable.newKey)</span><br><span class="line"><span class="comment">--对t中不存在的索引进行负值时，由于t的元表中的__newindex元方法指向了一个表，所以并没有对t中的索引进行赋值操作将，而是将__newindex所指向的newTable的newKey索引赋值为了"it is newKey"</span></span><br><span class="line">t.newKey = <span class="string">"it is newKey"</span></span><br><span class="line"><span class="built_in">print</span>(t.newKey,newTable.newKey)</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">nil</span><span class="literal">nil</span></span><br><span class="line"><span class="literal">nil</span>it is newKey</span><br></pre></td></tr></table></figure><h2 id="rawget-和-rawset"><a href="#rawget-和-rawset" class="headerlink" title="rawget 和 rawset"></a>rawget 和 rawset</h2><p>有时候我们希望直接改动或获取表中的值时，就需要rawget和rawset方法了。<br><strong>rawget可以让你直接获取到表中索引的实际值，而不通过元表的__index元方法。</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> mt = &#123;&#125;</span><br><span class="line">mt.<span class="built_in">__index</span> = &#123;key = <span class="string">"it is key"</span>&#125;</span><br><span class="line">t = &#123;&#125;</span><br><span class="line"><span class="built_in">setmetatable</span>(t,mt)</span><br><span class="line"><span class="built_in">print</span>(t.key)</span><br><span class="line"><span class="comment">--通过rawget直接获取t中的key索引</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">rawget</span>(t,<span class="string">"key"</span>))</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">it is key</span><br><span class="line"><span class="literal">nil</span></span><br></pre></td></tr></table></figure><p><strong>rawset可以让你直接为表中索引的赋值，而不通过元表的__newindex元方法。</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> mt = &#123;&#125;</span><br><span class="line"><span class="keyword">local</span> newTable = &#123;&#125;</span><br><span class="line">mt.<span class="built_in">__newindex</span> = newTable</span><br><span class="line">t = &#123;&#125;</span><br><span class="line"><span class="built_in">setmetatable</span>(t,mt)</span><br><span class="line"><span class="built_in">print</span>(t.newKey,newTable.newKey)</span><br><span class="line"><span class="comment">--通过rawset直接向t的newKey索引赋值</span></span><br><span class="line"><span class="built_in">rawset</span>(t,<span class="string">"newKey"</span>,<span class="string">"it is newKey"</span>)</span><br><span class="line"><span class="built_in">print</span>(t.newKey,newTable.newKey)</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">nil</span><span class="literal">nil</span></span><br><span class="line">it is newKey<span class="literal">nil</span></span><br></pre></td></tr></table></figure><h1 id="元表的使用场景"><a href="#元表的使用场景" class="headerlink" title="元表的使用场景"></a>元表的使用场景</h1><h3 id="作为table的元表"><a href="#作为table的元表" class="headerlink" title="作为table的元表"></a>作为table的元表</h3><p>通过为table设置元表可以在lua中实现面向对象编程。</p><h3 id="作为userdata的元表"><a href="#作为userdata的元表" class="headerlink" title="作为userdata的元表"></a>作为userdata的元表</h3><p>通过对userdata和元表可以实现在lua中对c中的结构进行面向对象式的访问。</p><p><font size=5 color=blue >标注：引用自 <a href="https://www.cnblogs.com/blueberryzzz/p/8947446.html" target="_blank" rel="noopener">blueberryzzz博客</a>  </font></p>]]></content>
      
      
      <categories>
          
          <category> lua </category>
          
          <category> lua元表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> lua </tag>
            
            <tag> lua元表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>lua学习</title>
      <link href="/2020/07/16/lua%E5%AD%A6%E4%B9%A0/"/>
      <url>/2020/07/16/lua%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="lua"><a href="#lua" class="headerlink" title="lua"></a>lua</h1><h3 id="函数可变参数"><a href="#函数可变参数" class="headerlink" title="函数可变参数"></a>函数可变参数</h3><p>Lua 函数可以接受可变数目的参数，和 C 语言类似，在函数参数列表中<strong>使用三点 … 表示函数有可变的参数</strong>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function add(...)  </span><br><span class="line">  local s &#x3D; 0  </span><br><span class="line">  local arg &#x3D; &#123;...&#125;--&gt; arg 为一个表，局部变量</span><br><span class="line">  for i, v in ipairs(arg) do   --&gt; &#123;...&#125; 表示一个由所有变长参数构成的数组  </span><br><span class="line">    s &#x3D; s + v  </span><br><span class="line">  end  </span><br><span class="line">  return s  </span><br><span class="line">end  </span><br><span class="line">print(add(3,4,5,6,7))  ---&gt;25</span><br></pre></td></tr></table></figure><h2 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h2><h3 id="链接两个字符串-str1-str2"><a href="#链接两个字符串-str1-str2" class="headerlink" title="链接两个字符串    str1..str2"></a>链接两个字符串    str1..str2</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(&quot;www.runoob.&quot;..&quot;com&quot;)</span><br><span class="line">&#x3D;&gt;  www.runoob.com</span><br></pre></td></tr></table></figure><h3 id="字符串替换-string-gsub"><a href="#字符串替换-string-gsub" class="headerlink" title="字符串替换 string.gsub"></a>字符串替换 string.gsub</h3><p><strong>string.gsub(mainString,findString,replaceString,num)</strong></p><p>在字符串中替换。mainString 为要操作的字符串， findString 为被替换的字符，replaceString 要替换的字符，num 替换次数（可以忽略，则全部替换），如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string.gsub(&quot;aaaa&quot;,&quot;a&quot;,&quot;z&quot;,3);</span><br><span class="line">&#x3D;&gt;  zzza    3(3为替换的次数)</span><br></pre></td></tr></table></figure><h3 id="截取字符串-string-sub"><a href="#截取字符串-string-sub" class="headerlink" title="截取字符串  string.sub"></a>截取字符串  string.sub</h3><p>string.sub() 用于截取字符串，原型为：<code>string.sub(s, i [, j])</code>  截取字符串s的从第i个字符到第j个字符之间的串,j默认为-1,最后一个</p><h3 id="字符串查找-string-find"><a href="#字符串查找-string-find" class="headerlink" title="字符串查找  string.find"></a>字符串查找  <strong>string.find</strong></h3><p><strong>string.find (str, substr, [init, [end]])</strong>   若存在，<strong>则返回2个值</strong>：匹配串开始索引和结束索引。若不存在，返回nil。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">local a, b &#x3D; string.find(&quot;Hello Lua user&quot;, &quot;Lua&quot;, 1)</span><br><span class="line">print(a, b)</span><br><span class="line">&#x3D;&gt; 7  9</span><br></pre></td></tr></table></figure><h3 id="字符串匹对-string-match"><a href="#字符串匹对-string-match" class="headerlink" title="字符串匹对  string.match"></a>字符串匹对  string.match</h3><p><strong>string.match(str, pattern, init)</strong></p><p>string.match()只寻找源字串str中的第一个配对. 参数init可选, 指定搜寻过程的起点, 默认为1。<br>在成功配对时, 函数将返回配对表达式中的所有捕获结果; 如果没有设置捕获标记, 则返回整个配对字符串. 当没有成功的配对时, 返回nil。</p><p>pattern没有指定captures,那么将返回整个匹配内容。<strong>capture是指pattern中用小括号括起来的内容</strong>。<strong>比如print(string.match(“hello world”, “h(ell)o wor”)),这将打印ell</strong>，如果没有这个小括号呢，比如print(string.match(“hello world”, “hello”)),这将打印hello.这就是与“hello”整个相匹配的内容都返回了。</p><p><strong>pattern 要了解lua的正则表达式</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">local str &#x3D; &quot;ACK(22,33,55)&quot;</span><br><span class="line">local res &#x3D; string.match(str, &quot;ACK%((.-)%)$&quot;)  --&gt;  22,33,55</span><br><span class="line">local n1, n2, n3 &#x3D; string.match(s, &quot;(%d+),(%d+),(%d+),&quot;)  --&gt;  22   33  55</span><br></pre></td></tr></table></figure><h3 id="string-gmatch-str-pattern"><a href="#string-gmatch-str-pattern" class="headerlink" title="string.gmatch(str, pattern)"></a>string.gmatch(str, pattern)</h3><p><strong>返回一个迭代器函数</strong>，<strong>每一次调用这个函数，返回一个在字符串 str 找到的下一个符合 pattern 描述的子串</strong>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">local str &#x3D; &quot;Hello Lua user&quot;</span><br><span class="line">local fun &#x3D; string.gmatch(str, &quot;%a+&quot;)</span><br><span class="line">print(fun(),fun(),fun())</span><br><span class="line">&#x3D;&gt;  Hello  Lua  user</span><br></pre></td></tr></table></figure><h3 id="字符串反转-string-reverse-arg"><a href="#字符串反转-string-reverse-arg" class="headerlink" title="字符串反转   string.reverse(arg)"></a>字符串反转   string.reverse(arg)</h3><h3 id="字符串长度-string-len-arg"><a href="#字符串长度-string-len-arg" class="headerlink" title="字符串长度    string.len(arg)"></a>字符串长度    string.len(arg)</h3><h3 id="格式化字符串-string-format"><a href="#格式化字符串-string-format" class="headerlink" title="格式化字符串   string.format"></a>格式化字符串   string.format</h3><p>生成具有特定格式的字符串,第一个参数为格式化串：由指示符和控制格式的字符组成。参数如同C语言的print语法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">local y &#x3D; &#39;2019&#39;; local m &#x3D; &#39;12&#39;; local d &#x3D; &#39;15&#39;;</span><br><span class="line">print(string.format(&quot;%2d&#x2F;%2d&#x2F;%2d&quot;,m, d, y))  &#x3D;&gt;  12&#x2F;15&#x2F;2019</span><br></pre></td></tr></table></figure><h3 id="字符串大小写转换-string-upper-string-lower"><a href="#字符串大小写转换-string-upper-string-lower" class="headerlink" title="字符串大小写转换  string.upper  string.lower"></a>字符串大小写转换  string.upper  string.lower</h3><h3 id="字符串拷贝-string-rep-string-n"><a href="#字符串拷贝-string-rep-string-n" class="headerlink" title="字符串拷贝   string.rep(string, n)"></a>字符串拷贝   string.rep(string, n)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string.rep(&quot;abcd&quot;,2)   &#x3D;&gt;  abcdabcd注意：不改变字符串本身</span><br></pre></td></tr></table></figure><h2 id="Lua-数组"><a href="#Lua-数组" class="headerlink" title="Lua 数组"></a>Lua 数组</h2><p><strong>定义    array = {item1, item2}</strong></p><h3 id="数组的遍历"><a href="#数组的遍历" class="headerlink" title="数组的遍历"></a>数组的遍历</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for key,value in ipairs(array) </span><br><span class="line">do</span><br><span class="line">   print(key, value)</span><br><span class="line">end</span><br><span class="line"> &#x3D;&#x3D;&gt; key 为1，2  value为值， 数组for...in 循环第一个参数也是key</span><br></pre></td></tr></table></figure><h2 id="Lua-表"><a href="#Lua-表" class="headerlink" title="Lua 表"></a>Lua 表</h2><p><strong>定义   mytable = {}</strong></p><h3 id="table-方法"><a href="#table-方法" class="headerlink" title="table 方法"></a>table 方法</h3><h4 id="插入-table-insert-table-pos-value"><a href="#插入-table-insert-table-pos-value" class="headerlink" title="插入  table.insert (table, [pos,] value)"></a>插入  <strong>table.insert</strong> (table, [pos,] value)</h4><p>在table的数组部分指定位置(pos)插入值为value的一个元素. pos参数可选, <strong>默认为数组部分末尾</strong></p><h4 id="移除-table-remove-table-pos"><a href="#移除-table-remove-table-pos" class="headerlink" title="移除  table.remove (table [, pos])"></a>移除  table.remove (table [, pos])</h4><p>返回table数组部分位于pos位置的元素. 其后的元素会被前移. pos参数可选, 默认为table长度, 即从<strong>最后一个元素删起</strong>。</p><h4 id="排序-table-sort-table-comp"><a href="#排序-table-sort-table-comp" class="headerlink" title="排序  table.sort (table [, comp])"></a>排序  table.sort (table [, comp])</h4><p>对给定的table进行升序排序。</p><h4 id="长度-table"><a href="#长度-table" class="headerlink" title="长度   #table"></a>长度   #table</h4><p>也可以自定义方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function table_leng(t)</span><br><span class="line">  local leng&#x3D;0</span><br><span class="line">  for k, v in pairs(t) do</span><br><span class="line">    leng&#x3D;leng+1</span><br><span class="line">  end</span><br><span class="line">  return leng;</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h4 id="Table-连接成字符串-table-concat-table-sep-start-end"><a href="#Table-连接成字符串-table-concat-table-sep-start-end" class="headerlink" title="Table 连接成字符串  table.concat (table [, sep [, start [, end]]])"></a>Table 连接成字符串  table.concat (table [, sep [, start [, end]]])</h4><p>concat是concatenate(连锁, 连接)的缩写. table.concat()函数列出参数中指定table的数组部分从start位置到end位置的所有元素, <strong>元素间以指定的分隔符(sep)隔开</strong>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">local arr &#x3D; &#123;&quot;as&quot;, &quot;bs&quot;, &quot;cs&quot;, &quot;ds&quot;&#125;</span><br><span class="line">print(table.concat(arr))    &#x3D;&gt;   asbscsds</span><br><span class="line">print(table.concat(arr, &quot; &quot;, 2, 3))&#x3D;&gt; bs cs</span><br></pre></td></tr></table></figure><h2 id="Lua-迭代器"><a href="#Lua-迭代器" class="headerlink" title="Lua 迭代器"></a>Lua 迭代器</h2><p>迭代器（iterator）是一种对象，它能够用来遍历标准模板库容器中的部分或全部元素，每个迭代器对象代表容器中的确定的地址。 <strong>Lua 默认提供的迭代函数 ipairs</strong></p><p>在 Lua 中迭代器是一种支持指针类型的结构，它可以遍历集合的每一个元素。</p><h3 id="泛型-for-迭代器"><a href="#泛型-for-迭代器" class="headerlink" title="泛型 for 迭代器"></a>泛型 for 迭代器</h3><p>泛型 for 在自己内部保存迭代函数，实际上它保存三个值：迭代函数、状态常量、控制变量。</p><p>泛型 for 迭代器提供了集合的 <strong>key/value 对</strong>，语法格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">array &#x3D; &#123;&quot;Google&quot;, &quot;Runoob&quot;&#125;</span><br><span class="line">for key,value in ipairs(array) </span><br><span class="line">do</span><br><span class="line">   print(key, value)</span><br><span class="line">end</span><br><span class="line"> &#x3D;&#x3D;&gt; key 为1，2  value为值， 数组for...in 循环第一个参数也是key</span><br></pre></td></tr></table></figure><h3 id="无状态的迭代器"><a href="#无状态的迭代器" class="headerlink" title="无状态的迭代器"></a>无状态的迭代器</h3><p>无状态的迭代器是指不保留任何状态的迭代器，因此在循环中我们可以利用无状态迭代器避免创建闭包花费额外的代价。</p><p>每一次迭代，迭代函数都是用两个变量（状态常量和控制变量）的值作为参数被调用，一个无状态的迭代器只利用这两个值可以获取下一个元素。</p><p>这种无状态迭代器的典型的简单的例子是 ipairs，它遍历数组的每一个元素。</p><h2 id="Lua的模块和包-module"><a href="#Lua的模块和包-module" class="headerlink" title="Lua的模块和包 module"></a>Lua的模块和包 module</h2><p>创建一个模块很简单，就是<strong>创建一个 table，然后把需要导出的常量、函数放入其中，最后返回这个 table</strong> 就行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">-- 文件名为 module.lua</span><br><span class="line">-- 定义一个名为 module 的模块</span><br><span class="line">module &#x3D; &#123;&#125;</span><br><span class="line"> </span><br><span class="line">-- 定义一个常量</span><br><span class="line">module.constant &#x3D; &quot;这是一个常量&quot;</span><br><span class="line"> </span><br><span class="line">-- 定义一个函数</span><br><span class="line">function module.func1()</span><br><span class="line">    io.write(&quot;这是一个公有函数！\n&quot;)</span><br><span class="line">end</span><br><span class="line"> </span><br><span class="line">local function func2()</span><br><span class="line">    print(&quot;这是一个私有函数！&quot;)</span><br><span class="line">end</span><br><span class="line"> </span><br><span class="line">function module.func3()</span><br><span class="line">    func2()</span><br><span class="line">end</span><br><span class="line"> </span><br><span class="line">return module</span><br></pre></td></tr></table></figure><h3 id="加载模块"><a href="#加载模块" class="headerlink" title="加载模块"></a>加载模块</h3><p>Lua提供了一个名为require的函数用来加载模块。要加载一个模块，只需要简单地调用就可以了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">require(&quot;&lt;模块名&gt;&quot;)   如require(&quot;module&quot;) 要求路径时如 require(&quot;&#x2F;module&#x2F;module&quot;)</span><br></pre></td></tr></table></figure><h2 id="Lua的正则表达式"><a href="#Lua的正则表达式" class="headerlink" title="Lua的正则表达式"></a>Lua的正则表达式</h2><p>​    网页跳转到：    <a href="https://blog.csdn.net/xiejunna/article/details/52161097" target="_blank" rel="noopener">Lua的正则表达式</a>    查看详细</p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/lanning5/blogCDN/img/md%E6%88%AA%E5%9B%BE/lua/lua%E6%AD%A3%E5%88%99.png" alt="正则表达式"></p>]]></content>
      
      
      <categories>
          
          <category> lua </category>
          
      </categories>
      
      
        <tags>
            
            <tag> lua </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++学习</title>
      <link href="/2020/07/16/C++%E5%AD%A6%E4%B9%A0/"/>
      <url>/2020/07/16/C++%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="枚举："><a href="#枚举：" class="headerlink" title="枚举："></a>枚举：</h3><p>枚举类型(enumeration)是C++中的一种派生数据类型，它是由用户定义的若干枚举常量的集合。</p><p>如果一个变量只有几种可能的值，可以定义为枚举(enumeration)类型。所谓”枚举”是指将变量的值一一列举出来，变量的值只能在列举出来的值的范围内。</p><h4 id="一般形式"><a href="#一般形式" class="headerlink" title="一般形式"></a>一般形式</h4><p>创建枚举，需要使用关键字 <strong>enum</strong>。枚举类型的一般形式为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">enum 枚举名&#123; </span><br><span class="line">     标识符[&#x3D;整型常数], </span><br><span class="line">     标识符[&#x3D;整型常数], </span><br><span class="line">... </span><br><span class="line">    标识符[&#x3D;整型常数]</span><br><span class="line">&#125; 枚举变量;</span><br></pre></td></tr></table></figure><p>如果枚举没有初始化, 即<strong>省掉”=整型常数”</strong>时, 则从第一个标识符开始。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">例如：</span><br><span class="line">enum color &#123; red, green, blue &#125; c;</span><br><span class="line">c &#x3D; blue;</span><br></pre></td></tr></table></figure><h4 id="枚举类型与基础类型的转换"><a href="#枚举类型与基础类型的转换" class="headerlink" title="枚举类型与基础类型的转换"></a><strong>枚举类型与基础类型的转换</strong></h4><p><strong>基础类型不能隐式转换为枚举类型； 枚举类型也不能隐式转换为基础类型。</strong></p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/lanning5/blogCDN/img/md%E6%88%AA%E5%9B%BE/C++/%E6%9E%9A%E4%B8%BE%E4%B8%8E%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2.png" alt="枚举类型与基础类型的转换"></p><h3 id="存储类"><a href="#存储类" class="headerlink" title="存储类"></a>存储类</h3><p>存储类定义 C++ 程序中变量/函数的范围（可见性）和生命周期。这些说明符放置在它们所修饰的类型之前。下面列出 C++ 程序中可用的存储类：</p><ul><li>auto</li><li>register</li><li>static</li><li>extern</li><li>mutable</li><li>thread_local (C++11)</li></ul><p>从 C++ 17 开始，auto 关键字不再是 C++ 存储类说明符，且 register 关键字被弃用。</p><h4 id="static-存储类"><a href="#static-存储类" class="headerlink" title="static 存储类"></a>static 存储类</h4><p><strong>static</strong> 存储类指示编译器在程序的生命周期内保持局部变量的存在，而不需要在每次它进入和离开作用域时进行创建和销毁。因此，<strong>使用 static 修饰局部变量可以在函数调用之间保持局部变量的值</strong>。</p><p>static 修饰符也可以应用于全局变量。当 static 修饰全局变量时，会使变量的作用域限制在声明它的文件内。</p><p>在 C++ 中，当 static 用在类数据成员上时，会导致仅有一个该成员的副本被类的所有对象共享。</p><center>实例：</center><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt; </span><br><span class="line">&#x2F;&#x2F; 函数声明 </span><br><span class="line">void func(void);</span><br><span class="line"> </span><br><span class="line">static int count &#x3D; 10; &#x2F;* 全局变量 *&#x2F;</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    while(count--)</span><br><span class="line">    &#123;</span><br><span class="line">       func();</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 函数定义</span><br><span class="line">void func( void )</span><br><span class="line">&#123;</span><br><span class="line">    static int i &#x3D; 5; &#x2F;&#x2F; 局部静态变量</span><br><span class="line">    i++;</span><br><span class="line">    std::cout &lt;&lt; &quot;变量 i 为 &quot; &lt;&lt; i ;</span><br><span class="line">    std::cout &lt;&lt; &quot; , 变量 count 为 &quot; &lt;&lt; count &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><center>结果</center><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">变量 i 为 6 , 变量 count 为 9</span><br><span class="line">变量 i 为 7 , 变量 count 为 8</span><br><span class="line">变量 i 为 8 , 变量 count 为 7</span><br><span class="line">变量 i 为 9 , 变量 count 为 6</span><br><span class="line">变量 i 为 10 , 变量 count 为 5</span><br><span class="line">变量 i 为 11 , 变量 count 为 4</span><br><span class="line">变量 i 为 12 , 变量 count 为 3</span><br><span class="line">变量 i 为 13 , 变量 count 为 2</span><br><span class="line">变量 i 为 14 , 变量 count 为 1</span><br><span class="line">变量 i 为 15 , 变量 count 为 0</span><br></pre></td></tr></table></figure><h4 id="extern-存储类"><a href="#extern-存储类" class="headerlink" title="extern 存储类"></a>extern 存储类</h4><p><strong>extern</strong> 存储类用于提供一个全局变量的引用，全局变量对所有的程序文件都是可见的。当您使用 ‘extern’ 时，对于无法初始化的变量，会把变量名指向一个之前定义过的存储位置。</p><p>当您有多个文件且定义了一个可以在其他文件中使用的全局变量或函数时，可以在其他文件中使用 <em>extern</em> 来得到已定义的变量或函数的引用。可以这么理解，<strong><em>extern</em> 是用来在另一个文件中声明一个全局变量或函数</strong>。</p><p>extern 修饰符通常用于当有两个或多个文件共享相同的全局变量或函数的时候，如下所示：</p><center>第一个文件：main.cpp</center><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int count ;</span><br><span class="line">extern void write_extern();</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">   count &#x3D; 5;</span><br><span class="line">   write_extern();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><center>第二个文件：support.cpp</center><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">extern int count;</span><br><span class="line"> </span><br><span class="line">void write_extern(void)</span><br><span class="line">&#123;</span><br><span class="line">   std::cout &lt;&lt; &quot;Count is &quot; &lt;&lt; count &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h3><p>位运算符作用于位，并逐位执行操作。</p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/lanning5/blogCDN/img/md%E6%88%AA%E5%9B%BE/C++/%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6.png" alt="位运算符"></p><h3 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h3><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/lanning5/blogCDN/img/md%E6%88%AA%E5%9B%BE/C++/%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7.png" alt="位运算符"></p><h3 id="解引用"><a href="#解引用" class="headerlink" title="解引用  *"></a>解引用  *</h3><p>指针前加 * 代表解引用， 找到指针指向的内存的数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int a &#x3D; 10; int *p; p &#x3D; &amp;a;</span><br></pre></td></tr></table></figure><h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><h3 id="常量指针"><a href="#常量指针" class="headerlink" title="常量指针"></a>常量指针</h3><p><strong>const int * p</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int a &#x3D; 10, b &#x3D; 20;</span><br><span class="line">const int * p &#x3D; &amp;a;</span><br><span class="line">p &#x3D; &amp;b &#x2F;&#x2F; 可以修改指针的指向</span><br></pre></td></tr></table></figure><p><font color=orange><strong>特点</strong>：<strong>指针的指向可以修改，但是指针指向的值不可以修改</strong></font></p><h3 id="指针常量"><a href="#指针常量" class="headerlink" title="指针常量"></a>指针常量</h3><p><strong>int * const p</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int a &#x3D; 10, b &#x3D; 20;</span><br><span class="line">const int * p &#x3D; &amp;a;</span><br><span class="line">*p &#x3D; 20 &#x2F;&#x2F; 可以修改指针指向的值</span><br></pre></td></tr></table></figure><p><font color=orange><strong>特点</strong>：<strong>指针的指向不可以修改，但是指针指向的值可以修改</strong></font></p><h3 id="const-既修饰指针，又修饰常量"><a href="#const-既修饰指针，又修饰常量" class="headerlink" title="const 既修饰指针，又修饰常量"></a>const 既修饰指针，又修饰常量</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int a &#x3D; 10, b &#x3D; 20;</span><br><span class="line">const int * const p &#x3D; &amp;a;</span><br></pre></td></tr></table></figure><p><font color=orange><strong>特点</strong>：<strong>既不可以修改指针的指向，又不可修改指针指向的值</strong></font></p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="值传递"><a href="#值传递" class="headerlink" title="值传递"></a>值传递</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void swap(a, b)&#123;</span><br><span class="line">int temp &#x3D; a;</span><br><span class="line">a &#x3D; b;</span><br><span class="line">b &#x3D; temp;</span><br><span class="line">&#125;</span><br><span class="line">swap(a,b)</span><br></pre></td></tr></table></figure><p><strong>值传递不会改变原有的数据</strong></p><h3 id="地址传递"><a href="#地址传递" class="headerlink" title="地址传递"></a>地址传递</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void swap(*a, *b)&#123;</span><br><span class="line">int temp &#x3D; *a;</span><br><span class="line">*a &#x3D; *b;</span><br><span class="line">*b &#x3D; temp;</span><br><span class="line">&#125;</span><br><span class="line">swap(&amp;a, &amp;b)</span><br></pre></td></tr></table></figure><p><strong>地址传递</strong></p><p><strong>jizhuomi.com</strong></p><p><strong>51halcon.com</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vs常用快捷键</title>
      <link href="/2020/07/15/vs%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
      <url>/2020/07/15/vs%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="vs"><a href="#vs" class="headerlink" title="vs"></a>vs</h1><h2 id="在vs中设置或查看快捷键"><a href="#在vs中设置或查看快捷键" class="headerlink" title="在vs中设置或查看快捷键"></a>在vs中设置或查看快捷键</h2><p>在工具栏    <font color=red>工具 =&gt; 选项 =&gt; 环境 =&gt; 键盘  </font>  中查看或修改快捷键</p><h2 id="常用快捷键"><a href="#常用快捷键" class="headerlink" title="常用快捷键"></a>常用快捷键</h2><p>智能提示：ctrl + J<br>CTRL + SHIFT + B 生成解决方案<br>F4 显示属性窗口<br>F5 运行调试<br>F10 跨过程序执行<br>F11 单步逐句执行<br>F7: 查看代码<br>Shift+F7: 查看窗体设计器<br>Ctrl+F: 查找<br>F3: 查找下一个<br>Ctrl+H: 替换<br>Ctrl+F5: 开始执行(不调试)<br>F9: 切换断点<br>Ctrl+Shift+F9: 删除全部断点<br>Ctrl+Shift+F: 在文件中查找<br>Ctrl+K,S: 插入外侧代码</p><p><font color=red>代码格式化：ctrl+E+F</font></p><p><font color=red>删除当前行      Ctrl+Shift+L</font>  </p><p><font color=red>注释    Ctrl + K + C    取消注释 Ctrl + K + U</font>  </p><p><font color=red>折叠代码  </font>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Ctrl + M + O: 折叠所有方法</span><br><span class="line"></span><br><span class="line">Ctrl + M + M: 折叠或者展开当前方法</span><br><span class="line"></span><br><span class="line">Ctrl + M + S: 折叠当前区域</span><br><span class="line"></span><br><span class="line">Ctrl + M + L: 展开所有方法</span><br></pre></td></tr></table></figure><p><font color=red>代码排版 ：</font>  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">格式化cs(选中)代码：Ctrl+k+f</span><br><span class="line"></span><br><span class="line">格式化aspx(文档)代码：Ctrl+k+d</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> vs </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>halcon基础学习</title>
      <link href="/2020/07/14/halcon%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
      <url>/2020/07/14/halcon%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="halcon"><a href="#halcon" class="headerlink" title="halcon"></a>halcon</h1><h2 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">控制变量</span><br><span class="line">arr :&#x3D; [1, 2, 3, 4, 5] &#x2F;&#x2F;数组</span><br><span class="line">num :&#x3D; |arr|&#x2F;&#x2F;num&#x3D;5 求模（注意：不是求绝对值）</span><br><span class="line">SingerElenment :&#x3D; arr[3]  &#x2F;&#x2F;SingerElenment&#x3D;4，取数组下标为3的值</span><br><span class="line">Part :&#x3D; arr[1:3] &#x2F;&#x2F;Part&#x3D;[2,3,4] 取下标从1到3的值</span><br><span class="line">Copy :&#x3D; arr[0: |arr|-1]&#x2F;&#x2F;Copy&#x3D;arr, 相当于复杂arr</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">简单的示例</span><br><span class="line">read_image(Image, &#39;filePath&#39;)&#x2F;&#x2F;读取图形， 第二个参数为图片的地址(路径)</span><br><span class="line">regiongrowing(Image, Regions, 3, 3, 6, 100)&#x2F;&#x2F;图像分割，区域增长，把整个图像分成各个区域</span><br><span class="line">count_obj(Regions, Number)&#x2F;&#x2F;统计区域的个数， 第二个参数为变量</span><br><span class="line">open_file(&#39;fileName&#39;, &#39;output&#39;, FileHandle)&#x2F;&#x2F;FileHandle 文件句柄</span><br><span class="line">for i :&#x3D; 1 to Number by 1</span><br><span class="line">select_obj (Regions, Selected, i)</span><br><span class="line">area_center (Selected, Area, Row, Column)</span><br><span class="line">fwrite_string (FileHandle, i + &#39; &#39; + Area)</span><br><span class="line">fnew_line(FileHandle)</span><br><span class="line">endfor</span><br><span class="line">close_file(FileHandle)</span><br></pre></td></tr></table></figure><h2 id="算子"><a href="#算子" class="headerlink" title="算子"></a>算子</h2><h3 id="图像滤波"><a href="#图像滤波" class="headerlink" title="图像滤波"></a>图像滤波</h3><p>图像增强：对比度增强，亮度校正，直方图归一化，直方图均衡化<br>平滑滤波：边缘保护和增强平滑，各向非同性滤波，高斯平滑，二项式滤波，<br>均值<br>滤波，阶梯滤波器（中值，分离系数中值滤波，加权中值等），中度滤波，Sigma滤波，切尾均值，椒盐噪声去除，递归平滑滤波<br>边缘滤波：Canny,Deriche,Lanser,Shen,Frei,Kirsch,Roberts,Prewitt,Roberts,Prewitt,Robinson,Sobel,<br>Laplace算子，高斯差分，高斯导数，边缘闭合<br>点滤波：Foerstner,Harris,Sojka亚像素精度点提取滤波器<br>纹理：Laws滤波（3×3，5×5，7×7），离差，熵<br>算术运算：比例缩放，加，减，乘，绝对值，最大值，最小值，翻转，平方根<br>颜色变换：CIElab,hsv,his,yiq,yuv,CIExyz,hls,his等<br>傅立叶变换：高速FFT；高斯，导数计算，Gabor滤波器，带通，高通，低通滤<br>波，能量，相位，权值计算<br>霍夫变换：线，圆检测。<br>其他类型滤波器：自定义滤波器，点滤波器，灰度骨架抽取，主成分分析，拓<br>扑骨架抽取，高斯金字塔变换，类型转换</p><h3 id="亚像素边缘及线提取"><a href="#亚像素边缘及线提取" class="headerlink" title="亚像素边缘及线提取"></a>亚像素边缘及线提取</h3><p>Canny,Deriche,Lanser和Sobel边缘检测算子；Facet模型及Steger线提取（精度高于1/50像素）；亚像素彩色边缘，线提取；亚像素阈值</p><h3 id="亚像素轮廓处理"><a href="#亚像素轮廓处理" class="headerlink" title="亚像素轮廓处理"></a>亚像素轮廓处理</h3><p>轮廓处理：仿射和投影变换；线，圆，椭圆和矩形的分割<br>提取及拟合：平行轮廓合并；集合算法（交集，并集，差集）；不同标准形状<br>生成<br>形状特征：面积，中心点，方向，圆度，紧密度，周长，椭圆轴，力矩，凸度，离心率，闭合区域（凸，圆，矩形）；基于形状特征的轮廓选择</p><h3 id="边缘位置测量"><a href="#边缘位置测量" class="headerlink" title="边缘位置测量"></a>边缘位置测量</h3><p>沿直线和圆弧的亚像素边缘提取；自动选择边缘（起点，终点，所有点，上<br>升，下降，边缘点对）；边界及边界对寻找评价函数</p><h3 id="Blob分析"><a href="#Blob分析" class="headerlink" title="Blob分析"></a>Blob分析</h3><p>阈值：全局，局部，自动<br>区域处理：连通域分析，骨架，连接点，终点，集合算法（交集，并集，差<br>集，补集）；闭合区域（矩形，圆，椭圆形，凸）；空洞填充，区域生成（矩<br>形，圆形，椭圆形，多边形，方格，网格，任意形状），访问（行程编码，链<br>码，轮廓，多边形）<br>灰度值特征：最小值，最大值，均值，方差，共生距阵，直方图，熵，模糊特<br>征，灰度距<br>形状特征：面积，中点，方向，圆度，直角度，紧密度，空洞数，周长，凸度，椭圆轴，2阶距，3阶距，离心率，Hamming距离，闭合区域（圆，矩形），距离<br>，空间关系，Euler数</p><h3 id="图像分割"><a href="#图像分割" class="headerlink" title="图像分割"></a>图像分割</h3><p>阈值：彩色，后验证分割<br>区域生长：梯度，均值，彩色，纹理<br>分类：基于多层神经网络，支持向量机或n维线性平面或曲面的分类器<br>可变化模型：基于参考图像和经过训练的在一定误差范围内的标准样本的分割</p><h3 id="形态学"><a href="#形态学" class="headerlink" title="形态学"></a>形态学</h3><p>二值形态学：明可夫斯基加减，膨胀，腐蚀，开运算，闭运算，击中击不中变<br>换，边界，修剪，加粗，细化，距离变换<br>灰度形态学：分水岭算法：膨胀，腐蚀，开运算，闭运算</p><h3 id="分类器"><a href="#分类器" class="headerlink" title="分类器"></a>分类器</h3><p>多层感知神经网络分类器：支持向量机分类器：非一致分布n维线平面或曲面的<br>数据集聚类算法</p><h3 id="几何变换"><a href="#几何变换" class="headerlink" title="几何变换"></a>几何变换</h3><p>旋转，比例缩放，平移，镜像，剪切，仿射，透视，极化变换：从点对应<br>到角的近似变换；含自动点匹配的图像融合图像；变形校正；拼图；线扫描图<br>像区域与边界融合</p><h3 id="模式匹配"><a href="#模式匹配" class="headerlink" title="模式匹配"></a>模式匹配</h3><p>基于灰度值，相关性，形状，任意大小和形状的多模板匹配；鲁棒性极佳<br>的识别算法，对于旋转，比例缩放，混乱及部分被遮挡物体和照明变化都能准<br>确识别；彩色及多通道图像的匹配；只需调用一次识别函数，即可识别不同目<br>标及之间有相对位置变化的目标；可以产生综合模型，比如从多边形的图像数<br>据中；自动判断原型</p><h3 id="3D匹配"><a href="#3D匹配" class="headerlink" title="3D匹配"></a>3D匹配</h3><p>从DXF CAD文件建立3维模型；通过三维空间内任意6自由度姿态进行基于<br>形状的匹配；对于混乱或部分被遮挡的物体和照明变化都能够准确识别</p><h3 id="条码及二维码识别"><a href="#条码及二维码识别" class="headerlink" title="条码及二维码识别"></a>条码及二维码识别</h3><p>1维条码识别：EAN13，EAN8，UPC-A，UPC-E，2/5工业，2/5插入式，Codabar,Code39,Code93,Code128,PharmaCode<br>2维码识别：ECC200，QR码，PDF417码；二维码印刷质量检测</p><p>光学字符识别（OCR）<br>基于字符的识别，特殊分割算法，旋转校正，训练字体，可选特征；为多种应<br>用进行字体训练</p><h3 id="光学字符验证（OCV）"><a href="#光学字符验证（OCV）" class="headerlink" title="光学字符验证（OCV）"></a>光学字符验证（OCV）</h3><p>基于灰度值的模板对比算法，对于亮度，位置以及大小变换均能得出一致性结<br>果。</p><h3 id="灰度校正"><a href="#灰度校正" class="headerlink" title="灰度校正"></a>灰度校正</h3><p>为了提供亚像素测量的精确度，对图像采集设备的响应曲线进行校正</p><h3 id="3D定标"><a href="#3D定标" class="headerlink" title="3D定标"></a>3D定标</h3><p>用多幅图像为针孔和远心面阵摄像机或线阵摄像机的内部及外部参数定标；自<br>动校正摄像机旋转；图像和点的变形校正</p><p>3D视觉<br>双目立体视觉：双摄像机标定；自动判断摄像机相对位置；图像校正；亚像素<br>精度的深度及差度计算<br>其它方法：基于聚焦变化的深度图像获取；基于双目视觉的测量</p><p>图像序列<br>背景估计；光流分析</p><p>Sockets的网络传输<br>在HALCON处理器之间变换图像，区域，XLD（轮廓数据）及控制参数</p><p>串口<br>读取或写入数据。</p>]]></content>
      
      
      <categories>
          
          <category> 视觉 </category>
          
          <category> halcon </category>
          
      </categories>
      
      
        <tags>
            
            <tag> halcon </tag>
            
            <tag> 视觉 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实习学习01</title>
      <link href="/2020/07/14/%E5%AE%9E%E4%B9%A0%E5%AD%A6%E4%B9%A001/"/>
      <url>/2020/07/14/%E5%AE%9E%E4%B9%A0%E5%AD%A6%E4%B9%A001/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 视觉 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 视觉 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>markdown的一些语法</title>
      <link href="/2020/07/10/markdown%E7%9A%84%E4%B8%80%E4%BA%9B%E8%AF%AD%E6%B3%95/"/>
      <url>/2020/07/10/markdown%E7%9A%84%E4%B8%80%E4%BA%9B%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="markdown"><a href="#markdown" class="headerlink" title="markdown"></a>markdown</h1><p>Markdown是一种可以使用普通文本编辑器编写的<a href="https://baike.baidu.com/item/标记语言/5964436" target="_blank" rel="noopener"><strong>标记语言</strong></a>，通过简单的标记语法，它可以使普通文本内容具有一定的格式。blog文章的编写就需要掌握一些markdown的语法。</p><p>推荐使用的md编辑器：<a href="https://www.typora.io/" target="_blank" rel="noopener"><strong>typora</strong></a></p><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><h3 id="入门语法"><a href="#入门语法" class="headerlink" title="入门语法"></a>入门语法</h3><p><strong>标题</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 一级标题</span><br><span class="line">## 二级标题</span><br></pre></td></tr></table></figure><p><strong>加粗斜体</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">** 加粗的字体 **</span><br></pre></td></tr></table></figure><p><strong>分割线</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一行，连续输入三个星号 ***</span><br></pre></td></tr></table></figure><p><strong>表格插入</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">书籍名称|书籍编号|学时</span><br><span class="line">---|---|---</span><br><span class="line">计算机网络|002|48</span><br></pre></td></tr></table></figure><p><strong>引用</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;  引用文字</span><br></pre></td></tr></table></figure><p>这些都是很基本的入门语法，还有许多为列出，但是使用 <strong>typora</strong> 等编辑器这些基本语法都无需记牢，编辑器里功能都有，可以快速通过快捷键来写出格式，但是其它的一些格式编写编辑器里不提供，要自己掌握它们的语法去编写，例如居中，文字大小颜色等。</p><h2 id="常用语法"><a href="#常用语法" class="headerlink" title="常用语法"></a>常用语法</h2><h3 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h3><h4 id="颜色"><a href="#颜色" class="headerlink" title="颜色"></a>颜色</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">浅红色文字：&lt;font color&#x3D;&quot;#dd0000&quot;&gt;浅红色文字：&lt;&#x2F;font&gt;</span><br></pre></td></tr></table></figure><p><strong>效果</strong>：<img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/lanning5/blogCDN/img/md%E6%88%AA%E5%9B%BE/md%E8%AF%AD%E6%B3%95/fontcolor.png" alt="浅红色文字效果"></p><h4 id="字体大小"><a href="#字体大小" class="headerlink" title="字体大小"></a>字体大小</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">size为1：&lt;font size&#x3D;&quot;1&quot;&gt;size为1&lt;&#x2F;font&gt;</span><br></pre></td></tr></table></figure><p><strong>size 为1~7， 浏览器默认为3</strong></p><h4 id="标准字体"><a href="#标准字体" class="headerlink" title="标准字体"></a>标准字体</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;font face&#x3D;&quot;黑体&quot;&gt;我是黑体字&lt;&#x2F;font&gt;</span><br><span class="line"></span><br><span class="line">&lt;font face&#x3D;&quot;微软雅黑&quot;&gt;我是微软雅黑&lt;&#x2F;font&gt;</span><br><span class="line"></span><br><span class="line">&lt;font face&#x3D;&quot;STCAIYUN&quot;&gt;我是华文彩云</span><br></pre></td></tr></table></figure><h3 id="背景色"><a href="#背景色" class="headerlink" title="背景色"></a>背景色</h3><p><strong>bgcolor=颜色</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;table&gt;&lt;tr&gt;&lt;td bgcolor&#x3D;#FF00FF&gt;背景色的设置是按照十六进制颜色值：#7FFFD4&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;table&gt;</span><br></pre></td></tr></table></figure><p>效果：<img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/lanning5/blogCDN/img/md%E6%88%AA%E5%9B%BE/md%E8%AF%AD%E6%B3%95/bgcolor.png" alt="背景色展示"></p><h3 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h3><p><strong>基本形式</strong>是：<code>![]()</code> <code>![这里放图片描述](这里放图片链接)</code> 例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![背景色展示](https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;lanning5&#x2F;blogCDN&#x2F;img&#x2F;md截图&#x2F;md语法&#x2F;bgcolor.png)</span><br></pre></td></tr></table></figure><p>也可以用类 <strong>html5</strong>  标签语法格式</p><p><strong>定义尺寸</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img width &#x3D; &#39;550&#39; height &#x3D;&#39;50&#39; src &#x3D;&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;lanning5&#x2F;blogCDN&#x2F;img&#x2F;md截图&#x2F;md语法&#x2F;bgcolor.png&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure><h3 id="对齐方式"><a href="#对齐方式" class="headerlink" title="对齐方式"></a>对齐方式</h3><h4 id="居中"><a href="#居中" class="headerlink" title="居中"></a>居中</h4><h5 id="文字居中："><a href="#文字居中：" class="headerlink" title="文字居中："></a>文字居中：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;center&gt;诶嘿&lt;&#x2F;center&gt;</span><br></pre></td></tr></table></figure><h5 id="图片等居中"><a href="#图片等居中" class="headerlink" title="图片等居中"></a>图片等居中</h5><p><strong>align = center</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;div align&#x3D;center&gt;  &lt;img width &#x3D; &#39;550&#39; height &#x3D;&#39;50&#39; src &#x3D;&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;lanning5&#x2F;blogCDN&#x2F;img&#x2F;md截图&#x2F;md语法&#x2F;bgcolor.png&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><h4 id="左右对齐"><a href="#左右对齐" class="headerlink" title="左右对齐"></a>左右对齐</h4><p><strong>align = left</strong></p><h3 id="换行"><a href="#换行" class="headerlink" title="换行"></a>换行</h3><p><strong>连续两个以上空格+回车</strong>  or <code>&lt;br/&gt;</code></p><h3 id="特殊符号"><a href="#特殊符号" class="headerlink" title="特殊符号"></a>特殊符号</h3><p>利用 <strong>转义字符\</strong> 可输出符号本身 <code>\* 输出*字符</code></p><h4 id="其它特殊字符"><a href="#其它特殊字符" class="headerlink" title="其它特殊字符"></a>其它特殊字符</h4><p>使用 <strong>Unicode码</strong>  示例如下：</p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/lanning5/blogCDN/img/md%E6%88%AA%E5%9B%BE/md%E8%AF%AD%E6%B3%95/%E7%89%B9%E6%AE%8A%E5%AD%97%E7%AC%A6.png" alt="特殊字符"></p><p>字符对应的Unicode码，可以看这个网站：<a href="https://unicode-table.com/cn/" target="_blank" rel="noopener">https://unicode-table.com/cn/</a></p><h3 id="锚点"><a href="#锚点" class="headerlink" title="锚点"></a>锚点</h3><p>在预定的跳转到的位置添加 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">## 目录&#123;#index&#125;</span><br><span class="line">跳转到[目录](</span><br></pre></td></tr></table></figure><p> 然后在文档的其它地方写上连接到锚点的链接。</p><h2 id="高级用法"><a href="#高级用法" class="headerlink" title="高级用法"></a>高级用法</h2><h3 id="Todo-列表"><a href="#Todo-列表" class="headerlink" title="Todo 列表"></a>Todo 列表</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-[] 已处理的事情</span><br><span class="line"></span><br><span class="line">-[x] 未处理的事情</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/lanning5/blogCDN/img/md%E6%88%AA%E5%9B%BE/md%E8%AF%AD%E6%B3%95/todo.png" alt="Todo 列表展示"></p><h3 id="流程图-数学公式-序列图"><a href="#流程图-数学公式-序列图" class="headerlink" title="流程图 数学公式 序列图"></a>流程图 数学公式 序列图</h3><p>请参考CSDN 的一篇文章： <a href="https://blog.csdn.net/u014061630/article/details/81359144?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-9.nonecase&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-9.nonecase#4%E9%94%9A%E7%82%B9" target="_blank" rel="noopener">跳转</a></p>]]></content>
      
      
      <categories>
          
          <category> markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何用hexo建立自己的blog并部署到github中</title>
      <link href="/2020/07/07/%E5%A6%82%E4%BD%95%E7%94%A8hexo%E5%BB%BA%E7%AB%8B%E8%87%AA%E5%B7%B1%E7%9A%84blog%E5%B9%B6%E9%83%A8%E7%BD%B2%E5%88%B0github%E4%B8%AD/"/>
      <url>/2020/07/07/%E5%A6%82%E4%BD%95%E7%94%A8hexo%E5%BB%BA%E7%AB%8B%E8%87%AA%E5%B7%B1%E7%9A%84blog%E5%B9%B6%E9%83%A8%E7%BD%B2%E5%88%B0github%E4%B8%AD/</url>
      
        <content type="html"><![CDATA[<h1 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h1><p>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 <a href="http://daringfireball.net/projects/markdown/" target="_blank" rel="noopener">Markdown</a>（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p><p>hexo的网站：<a href="https://hexo.io/zh-cn" target="_blank" rel="noopener">hexo</a></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h3><ul><li><a href="http://nodejs.org/" target="_blank" rel="noopener">Node.js</a> (Node.js 版本需不低于 8.10，建议使用 Node.js 10.0 及以上版本)</li><li><a href="http://git-scm.com/" target="_blank" rel="noopener">Git</a></li></ul><h3 id="安装-Hexo"><a href="#安装-Hexo" class="headerlink" title="安装 Hexo"></a>安装 Hexo</h3><p>全局安装：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g hexo-cli</span><br></pre></td></tr></table></figure><h2 id="建站"><a href="#建站" class="headerlink" title="建站"></a>建站</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#&#x2F;&#x2F; &lt;folder&gt;是你的文件名  如 hexo init blog</span><br><span class="line">$ hexo init &lt;folder&gt;</span><br><span class="line">$ cd &lt;folder&gt;</span><br><span class="line">$ npm install</span><br></pre></td></tr></table></figure><p>建好后，可以运行<code>$ hexo server</code>查看你的本地博客</p><h2 id="部署到github中"><a href="#部署到github中" class="headerlink" title="部署到github中"></a>部署到github中</h2><ol><li><p>安装 <a href="https://github.com/hexojs/hexo-deployer-git" target="_blank" rel="noopener">hexo-deployer-git</a>.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i --save hexo-deployer-git</span><br></pre></td></tr></table></figure></li><li><p>在github创建一个新的repository，命名为<code>&lt;username&gt;.github.io</code></p></li><li><p>在 <strong>_config.yml</strong>（如果有已存在的请删除）添加如下配置：</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: https:&#x2F;&#x2F;github.com&#x2F;&lt;username&gt;&#x2F;&lt;project&gt;</span><br><span class="line">  #repo是github创建的地址 example, https:&#x2F;&#x2F;github.com&#x2F;hexojs&#x2F;hexojs.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><ol start="4"><li>运行<code>hexo g</code> and <code>hexo deploy</code>推送到github仓库</li></ol><h1 id="hexo-的指令"><a href="#hexo-的指令" class="headerlink" title="hexo 的指令"></a>hexo 的指令</h1><h2 id="官网网址"><a href="#官网网址" class="headerlink" title="官网网址"></a>官网网址</h2><p>hexo指令官网的网址： <a href="https://hexo.io/zh-cn/docs/commands" target="_blank" rel="noopener">网址</a></p><h2 id="常用的指令"><a href="#常用的指令" class="headerlink" title="常用的指令"></a>常用的指令</h2><h3 id="new"><a href="#new" class="headerlink" title="new"></a>new</h3><p>new指令是用来<strong>新建一篇文章</strong>，格式<code>hexo new [layout] &lt;title&gt;</code>  ，例如我要在blog新发布一篇文章，就可以</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new &quot;新建文章名&quot;</span><br></pre></td></tr></table></figure><p>这样，可以在source/_posts/ 文件夹中找到这个文件，直接编写即可。</p><p>要<strong>建立独立的页面</strong>，格式为<code>hexo new page &lt;title&gt;</code>或者<code>hexo new page --path &lt;path&gt; &lt;title&gt;</code> , 例如我要在blog 建立一个图片集页面，就可以 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new page photo</span><br></pre></td></tr></table></figure><p>我的photo页面下有壁纸子页面，壁纸的地址为photo/wallpaper/，则可以</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new page --path photo&#x2F;wallpaper&#x2F;index.md &quot;壁纸&quot;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> butterfly </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redux and react-redux</title>
      <link href="/2020/07/05/redux/"/>
      <url>/2020/07/05/redux/</url>
      
        <content type="html"><![CDATA[<h1 id="redux"><a href="#redux" class="headerlink" title="redux"></a>redux</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>React有props和state:</p><ol><li>props意味着父级分发下来的属性</li><li>state意味着组件内部可以自行管理的状态，并且整个React没有数据向上回溯的能力，这就是react的单向数据流</li></ol><p>这就意味着如果是一个数据状态非常复杂的应用，更多的时候发现<strong>React根本无法让两个组件互相交流</strong>，使用对方的数据，react的通过层级传递数据的这种方法是非常难受的，这个时候，迫切需要一个机制，<strong>把所有的state集中到组件顶部，能够灵活的将所有state各取所需的分发给所有的组件</strong>，是的，这就是redux</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ol><li>redux是的诞生是为了给 React 应用提供「可预测化的状态管理」机制。</li><li>Redux会将整个应用状态(其实也就是数据)存储到到一个地方，称为store</li><li>这个store里面保存一棵状态树(state tree)</li><li>组件改变state的唯一方法是通过调用store的dispatch方法，触发一个action，这个action被对应的reducer处理，于是state完成更新</li><li>组件可以派发(dispatch)行为(action)给store,而不是直接通知其它组件</li><li>其它组件可以通过订阅store中的状态(state)来刷新自己的视图</li></ol><h2 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h2><ol><li>创建reducer<ul><li>可以使用单独的一个reducer,也可以将多个reducer合并为一个reducer，即：<code>combineReducers()</code></li><li>action发出命令后将state放入reucer加工函数中，返回新的state,对state进行加工处理</li></ul></li><li>创建action<ul><li>用户是接触不到state的，只能有view触发，所以，这个action可以理解为指令，需要发出多少动作就有多少指令</li><li>action是一个对象，必须有一个叫type的参数，定义action类型</li></ul></li><li>创建的store，使用createStore方法<ul><li>store 可以理解为有多个加工机器的总工厂</li><li>提供subscribe，dispatch，getState这些方法。</li></ul></li></ol><h2 id="按步骤手把手实战。"><a href="#按步骤手把手实战。" class="headerlink" title="按步骤手把手实战。"></a>按步骤手把手实战。</h2><p>上述步骤，对应的序号，我会在相关代码标出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">npm install redux -S &#x2F;&#x2F; 安装</span><br><span class="line"></span><br><span class="line">import &#123; createStore &#125; from &#39;redux&#39; &#x2F;&#x2F; 引入</span><br><span class="line"></span><br><span class="line">const reducer &#x3D; (state &#x3D; &#123;count: 0&#125;, action) &#x3D;&gt; &#123;----------&gt; ⑴</span><br><span class="line">  switch (action.type)&#123;</span><br><span class="line">    case &#39;INCREASE&#39;: return &#123;count: state.count + 1&#125;;</span><br><span class="line">    case &#39;DECREASE&#39;: return &#123;count: state.count - 1&#125;;</span><br><span class="line">    default: return state;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const actions &#x3D; &#123;----------&gt;⑵</span><br><span class="line">  increase: () &#x3D;&gt; (&#123;type: &#39;INCREASE&#39;&#125;),</span><br><span class="line">  decrease: () &#x3D;&gt; (&#123;type: &#39;DECREASE&#39;&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const store &#x3D; createStore(reducer);----------&gt;⑶</span><br><span class="line"></span><br><span class="line">store.subscribe(() &#x3D;&gt;</span><br><span class="line">  console.log(store.getState())</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">store.dispatch(actions.increase()) &#x2F;&#x2F; &#123;count: 1&#125;</span><br><span class="line">store.dispatch(actions.increase()) &#x2F;&#x2F; &#123;count: 2&#125;</span><br><span class="line">store.dispatch(actions.increase()) &#x2F;&#x2F; &#123;count: 3&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>自己画了一张非常简陋的流程图，方便理解redux的工作流程</p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/lanning5/blogCDN/img/20200709000020.png" alt="img"></p><h1 id="react-redux"><a href="#react-redux" class="headerlink" title="react-redux"></a>react-redux</h1><p>刚开始就说了，如果把store直接集成到React应用的顶层props里面，只要各个子组件能访问到顶层props就行了，比如这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;顶层组件 store&#x3D;&#123;store&#125;&gt;</span><br><span class="line">  &lt;App &#x2F;&gt;</span><br><span class="line">&lt;&#x2F;顶层组件&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>不就ok了吗？这就是 react-redux。Redux 官方提供的 React 绑定库。 具有高效且灵活的特性。</p><h2 id="React-Redux-将组件区分为-容器组件-和-UI-组件"><a href="#React-Redux-将组件区分为-容器组件-和-UI-组件" class="headerlink" title="React Redux 将组件区分为 容器组件 和 UI 组件"></a><strong>React Redux 将组件区分为 容器组件 和 UI 组件</strong></h2><ol><li>前者会处理逻辑</li><li>后者只负责显示和交互，内部不处理逻辑，状态完全由外部掌控</li></ol><h2 id="两个核心"><a href="#两个核心" class="headerlink" title="两个核心"></a>两个核心</h2><h3 id="Provider"><a href="#Provider" class="headerlink" title="Provider"></a>Provider</h3><p>看我上边那个代码的<strong>顶层组件</strong>4个字。对，你没有猜错。这个顶级组件就是Provider,一般我们都将顶层组件包裹在Provider组件之中，这样的话，所有组件就都可以在react-redux的控制之下了,<strong>但是store必须作为参数放到Provider组件中去</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;Provider store &#x3D; &#123;store&#125;&gt;</span><br><span class="line">    &lt;App &#x2F;&gt;</span><br><span class="line">&lt;Provider&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">这个组件的目的是让所有组件都能够访问到Redux中的数据。 </span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="connect"><a href="#connect" class="headerlink" title="connect"></a>connect</h3><p>这个才是react-redux中比较难的部分，我们详细解释一下</p><p>首先，先记住下边的这行代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">connect(mapStateToProps, mapDispatchToProps)(MyComponent)</span><br></pre></td></tr></table></figure><h4 id="mapStateToProps"><a href="#mapStateToProps" class="headerlink" title="mapStateToProps"></a>mapStateToProps</h4><p>这个单词翻译过来就是<strong>把state映射到props中去</strong> ,其实也就是<strong>把Redux中的数据映射到React中的props中去。</strong></p><p>举个栗子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    const mapStateToProps &#x3D; (state) &#x3D;&gt; &#123;</span><br><span class="line">      return &#123;</span><br><span class="line">      &#x2F;&#x2F; prop : state.xxx  | 意思是将state中的某个数据映射到props中</span><br><span class="line">        foo: state.bar</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>然后渲染的时候就可以使用this.props.foo</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Foo extends Component &#123;</span><br><span class="line">    constructor(props)&#123;</span><br><span class="line">        super(props);</span><br><span class="line">    &#125;</span><br><span class="line">    render()&#123;</span><br><span class="line">        return(</span><br><span class="line">        &#x2F;&#x2F; 这样子渲染的其实就是state.bar的数据了</span><br><span class="line">            &lt;div&gt;this.props.foo&lt;&#x2F;div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Foo &#x3D; connect()(Foo);</span><br><span class="line">export default Foo;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>然后这样就可以完成渲染了</p><h4 id="mapDispatchToProps"><a href="#mapDispatchToProps" class="headerlink" title="mapDispatchToProps"></a>mapDispatchToProps</h4><p>这个单词翻译过来就是就是<strong>把各种dispatch也变成了props让你可以直接使用</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">const mapDispatchToProps &#x3D; (dispatch) &#x3D;&gt; &#123; &#x2F;&#x2F; 默认传递参数就是dispatch</span><br><span class="line">  return &#123;</span><br><span class="line">    onClick: () &#x3D;&gt; &#123;</span><br><span class="line">      dispatch(&#123;</span><br><span class="line">        type: &#39;increatment&#39;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br><span class="line">class Foo extends Component &#123;</span><br><span class="line">    constructor(props)&#123;</span><br><span class="line">        super(props);</span><br><span class="line">    &#125;</span><br><span class="line">    render()&#123;</span><br><span class="line">        return(</span><br><span class="line">        </span><br><span class="line">             &lt;button onClick &#x3D; &#123;this.props.onClick&#125;&gt;点击increase&lt;&#x2F;button&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Foo &#x3D; connect()(Foo);</span><br><span class="line">export default Foo;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>组件也就改成了上边这样，可以直接通过this.props.onClick，来调用dispatch,这样子就不需要在代码中来进行store.dispatch了</p><h4 id="mapDispatchToProps多种写法"><a href="#mapDispatchToProps多种写法" class="headerlink" title="mapDispatchToProps多种写法"></a>mapDispatchToProps多种写法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">传统写法：</span><br><span class="line">const mapDispatchToProps &#x3D; (dispatch)&#x3D;&gt;&#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    abc:(aaa)&#x3D;&gt;</span><br><span class="line">      dispatch(&#123;</span><br><span class="line">        type:&#39;ADD&#39;,</span><br><span class="line">        id:num++,</span><br><span class="line">        text:aaa,</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">      qqw:(aaa)&#x3D;&gt;&#123;</span><br><span class="line">          dispatch(&#123;</span><br><span class="line">              type:&#39;TYY&#39;,</span><br><span class="line">              id:num++,</span><br><span class="line">              text:aaa,</span><br><span class="line">          &#125;)</span><br><span class="line">      &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">或者：</span><br><span class="line">function mapDispatchToProps(dispatch) &#123;</span><br><span class="line">   return &#123;</span><br><span class="line">         onIncrement: (...args) &#x3D;&gt; dispatch(actions.onIncrement(...args)),</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">第二种写法：</span><br><span class="line">const ActionCreators &#x3D; &#123;</span><br><span class="line"> abc:aaa&#x3D;&gt;&#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            type:&#39;ADD&#39;,</span><br><span class="line">            id:num++,</span><br><span class="line">            text:aaa,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    qqw:aaa&#x3D;&gt;(&#123;</span><br><span class="line">        type:&#39;TYY&#39;,</span><br><span class="line">        id:num++,</span><br><span class="line">        text:aaa,</span><br><span class="line">    &#125;),</span><br><span class="line">&#125;</span><br><span class="line">const mapDispatchToProps &#x3D; ActionCreators</span><br><span class="line">实例：</span><br><span class="line">import &#123; creament, decreament, setcount &#125; from &#39;..&#x2F;redux&#x2F;actions.js&#39;</span><br><span class="line">import ReduxTest from &#39;..&#x2F;views&#x2F;reduxTest.jsx&#39;</span><br><span class="line"></span><br><span class="line">export default connect((state) &#x3D;&gt; (&#123;count: state.count &#125;), &#123;</span><br><span class="line">  creament,</span><br><span class="line">  decreament,</span><br><span class="line">  setcount,</span><br><span class="line">&#125;)(ReduxTest)</span><br><span class="line"></span><br><span class="line">方法三：</span><br><span class="line">const mapDispatchToProps &#x3D; (dispatch) &#x3D;&gt; &#123;</span><br><span class="line">return bindActionCreators(ActionCreators, dispatch)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>react-redux的基本介绍就到这里了</p><h1 id="Redux-DevTool"><a href="#Redux-DevTool" class="headerlink" title="Redux DevTool"></a>Redux DevTool</h1><p><code>npm i --save--dev redux-devtools-extension</code></p><h1 id="redux-saga"><a href="#redux-saga" class="headerlink" title="redux-saga"></a>redux-saga</h1><p>如果按照原始的redux工作流程，当组件中产生一个action后会直接触发reducer修改state，reducer又是一个纯函数，也就是不能再reducer中进行异步操作；</p><p><strong>而往往实际中，组件中发生的action后，在进入reducer之前需要完成一个异步任务,比如发送ajax请求后拿到数据后，再进入reducer,显然原生的redux是不支持这种操作的</strong></p><p>这个时候急需一个中间件来处理这种业务场景，目前最优雅的处理方式自然就是redux-saga</p><h2 id="核心讲解"><a href="#核心讲解" class="headerlink" title="核心讲解"></a>核心讲解</h2><h3 id="1、Saga-辅助函数"><a href="#1、Saga-辅助函数" class="headerlink" title="1、Saga 辅助函数"></a><strong>1、Saga 辅助函数</strong></h3><p>redux-saga提供了一些辅助函数，用来在一些特定的action 被发起到Store时派生任务，下面我先来讲解两个辅助函数：<code>takeEvery</code> 和 <code>takeLatest</code></p><ul><li><h4 id="takeEvery"><a href="#takeEvery" class="headerlink" title="takeEvery"></a>takeEvery</h4></li></ul><p><strong>takeEvery就像一个流水线的洗碗工，过来一个脏盘子就直接执行后面的洗碗函数，一旦你请了这个洗碗工他会一直执行这个工作，绝对不会停止接盘子的监听过程和触发洗盘子函数</strong></p><p>例如：每次点击 按钮去Fetch获取数据时时，我们发起一个 FETCH_REQUESTED 的 action。 我们想通过启动一个任务从服务器获取一些数据，来处理这个action，类似于</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">window.addEventLister(&#39;xxx&#39;,fn)</span><br></pre></td></tr></table></figure><p>当dispatch xxx的时候，就会执行fn方法，</p><p>首先我们创建一个将执行异步 action 的任务(也就是上边的fn)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; put：你就认为put就等于 dispatch就可以了；</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; call：可以理解为实行一个异步函数,是阻塞型的，只有运行完后面的函数，才会继续往下；</span><br><span class="line">&#x2F;&#x2F; 在这里可以片面的理解为async中的await！但写法直观多了！</span><br><span class="line">import &#123; call, put &#125; from &#39;redux-saga&#x2F;effects&#39;</span><br><span class="line"></span><br><span class="line">export function* fetchData(action) &#123;</span><br><span class="line">   try &#123;</span><br><span class="line">      const apiAjax &#x3D; (params) &#x3D;&gt; fetch(url, params);</span><br><span class="line">      const data &#x3D; yield call(apiAjax);</span><br><span class="line">      yield put(&#123;type: &quot;FETCH_SUCCEEDED&quot;, data&#125;);</span><br><span class="line">   &#125; catch (error) &#123;</span><br><span class="line">      yield put(&#123;type: &quot;FETCH_FAILED&quot;, error&#125;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>然后在每次 FETCH_REQUESTED action 被发起时启动上面的任务,也就<strong>相当于每次触发一个名字为 FETCH_REQUESTED 的action就会执行上边的任务</strong>,代码如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import &#123; takeEvery &#125; from &#39;redux-saga&#39;</span><br><span class="line"></span><br><span class="line">function* watchFetchData() &#123;</span><br><span class="line"></span><br><span class="line">  yield* takeEvery(&quot;FETCH_REQUESTED&quot;, fetchData)</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：上面的 takeEvery 函数可以使用下面的写法替换</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function* watchFetchData() &#123;</span><br><span class="line">  </span><br><span class="line">   while(true)&#123;</span><br><span class="line">     yield take(&#39;FETCH_REQUESTED&#39;);</span><br><span class="line">     yield fork(fetchData);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><ul><li><h4 id="takeLatest"><a href="#takeLatest" class="headerlink" title="takeLatest"></a>takeLatest</h4></li></ul><p>在上面的例子中，takeEvery <strong>允许多个 fetchData 实例同时启动</strong>，在某个特定时刻，我们可以启动一个新的 fetchData 任务， 尽管之前还有一个或多个 fetchData 尚未结束</p><p>如果我们<strong>只想得到最新那个请求的响应</strong>（例如，始终显示最新版本的数据），我们可以使用 takeLatest 辅助函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import &#123; takeLatest &#125; from &#39;redux-saga&#39;</span><br><span class="line"></span><br><span class="line">function* watchFetchData() &#123;</span><br><span class="line">  yield* takeLatest(&#39;FETCH_REQUESTED&#39;, fetchData)</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><strong>和takeEvery不同，在任何时刻 takeLatest 只允许执行一个 fetchData 任务，并且这个任务是最后被启动的那个，如果之前已经有一个任务在执行，那之前的这个任务会自动被取消</strong></p><h3 id="2、Effect-Creators"><a href="#2、Effect-Creators" class="headerlink" title="2、Effect Creators"></a><strong>2、Effect Creators</strong></h3><p>redux-saga框架提供了很多创建effect的函数，下面我们就来简单的介绍下开发中最常用的几种</p><ul><li>take(pattern)</li><li>put(action)</li><li>call(fn, …args)</li><li>fork(fn, …args)</li><li>select(selector, …args)</li></ul><h4 id="take-pattern"><a href="#take-pattern" class="headerlink" title="take(pattern)"></a><strong>take(pattern)</strong></h4><p>take函数可以理解为监听未来的action，它创建了一个命令对象，告诉middleware等待一个特定的action， Generator会暂停，直到一个与pattern匹配的action被发起，才会继续执行下面的语句，也就是说，take是一个阻塞的 effect</p><p>用法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function* watchFetchData() &#123;</span><br><span class="line">   while(true) &#123;</span><br><span class="line">   &#x2F;&#x2F; 监听一个type为 &#39;FETCH_REQUESTED&#39; 的action的执行，直到等到这个Action被触发，才会接着执行下面的 yield fork(fetchData)  语句</span><br><span class="line">     yield take(&#39;FETCH_REQUESTED&#39;);</span><br><span class="line">     yield fork(fetchData);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="put-action"><a href="#put-action" class="headerlink" title="put(action)"></a><strong>put(action)</strong></h4><p>put函数是用来发送action的 effect，你可以简单的<strong>把它理解成为redux框架中的dispatch函数</strong>，当put一个action后，reducer中就会计算新的state并返回，<strong>注意：</strong> <strong>put 也是阻塞 effect</strong></p><p>用法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">export function* toggleItemFlow() &#123;</span><br><span class="line">    let list &#x3D; []</span><br><span class="line">    &#x2F;&#x2F; 发送一个type为 &#39;UPDATE_DATA&#39; 的Action，用来更新数据，参数为 &#96;data：list&#96;</span><br><span class="line">    yield put(&#123;</span><br><span class="line">      type: actionTypes.UPDATE_DATA,</span><br><span class="line">      data: list</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="call-fn-…args"><a href="#call-fn-…args" class="headerlink" title="call(fn, …args)"></a><strong>call(fn, …args)</strong></h4><p><strong>call函数你可以把它简单的理解为就是可以调用其他函数的函数</strong>，它命令 middleware 来调用fn 函数， args为函数的参数，<strong>注意：</strong> <strong>fn 函数可以是一个 Generator 函数，也可以是一个返回 Promise 的普通函数</strong>，call 函数也是<strong>阻塞 effect</strong></p><p>用法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">export const delay &#x3D; ms &#x3D;&gt; new Promise(resolve &#x3D;&gt; setTimeout(resolve, ms))</span><br><span class="line"></span><br><span class="line">export function* removeItem() &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    &#x2F;&#x2F; 这里call 函数就调用了 delay 函数，delay 函数为一个返回promise 的函数</span><br><span class="line">    return yield call(delay, 500)</span><br><span class="line">  &#125; catch (err) &#123;</span><br><span class="line">    yield put(&#123;type: actionTypes.ERROR&#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="fork-fn-…args"><a href="#fork-fn-…args" class="headerlink" title="fork(fn, …args)"></a><strong>fork(fn, …args)</strong></h4><p>fork 函数和 call 函数很像，<strong>都是用来调用其他函数的，但是fork函数是非阻塞函数</strong>，也就是说，<strong>程序执行完 <code>yield fork(fn， args)</code> 这一行代码后，会立即接着执行下一行代码语句，而不会等待fn函数返回结果后</strong>，在执行下面的语句</p><p>用法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import &#123; fork &#125; from &#39;redux-saga&#x2F;effects&#39;</span><br><span class="line"></span><br><span class="line">export default function* rootSaga() &#123;</span><br><span class="line">  &#x2F;&#x2F; 下面的四个 Generator 函数会一次执行，不会阻塞执行</span><br><span class="line">  yield fork(addItemFlow)</span><br><span class="line">  yield fork(removeItemFlow)</span><br><span class="line">  yield fork(toggleItemFlow)</span><br><span class="line">  yield fork(modifyItem)</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="select-selector-…args"><a href="#select-selector-…args" class="headerlink" title="select(selector, …args)"></a><strong>select(selector, …args)</strong></h4><p>select 函数是用来指示 middleware调用提供的选择器获取Store上的state数据，你也可以简单的把它理解为<strong>redux框架中获取store上的 state数据一样的功能</strong> ：<code>store.getState()</code></p><p>用法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">export function* toggleItemFlow() &#123;</span><br><span class="line">     &#x2F;&#x2F; 通过 select effect 来获取 全局 state上的 &#96;getTodoList&#96; 中的 list</span><br><span class="line">     let tempList &#x3D; yield select(state &#x3D;&gt; state.getTodoList.list)</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h1 id="一个具体的实例"><a href="#一个具体的实例" class="headerlink" title="一个具体的实例"></a>一个具体的实例</h1><p>*<em>index.js *</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">import React from &#39;react&#39;;</span><br><span class="line">import ReactDOM from &#39;react-dom&#39;;</span><br><span class="line">import &#123;createStore, applyMiddleware&#125; from &#39;redux&#39;</span><br><span class="line">import createSagaMiddleware from &#39;redux-saga&#39;</span><br><span class="line"></span><br><span class="line">import rootSaga from &#39;.&#x2F;sagas&#39;</span><br><span class="line">import Counter from &#39;.&#x2F;Counter&#39;</span><br><span class="line">import rootReducer from &#39;.&#x2F;reducers&#39;</span><br><span class="line"></span><br><span class="line">const sagaMiddleware &#x3D; createSagaMiddleware() &#x2F;&#x2F; 创建了一个saga中间件实例</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 下边这句话和下边的两行代码创建store的方式是一样的</span><br><span class="line">&#x2F;&#x2F; const store &#x3D; createStore(reducers,applyMiddlecare(middlewares))</span><br><span class="line"></span><br><span class="line">const createStoreWithMiddleware &#x3D; applyMiddleware(middlewares)(createStore)</span><br><span class="line">const store &#x3D; createStoreWithMiddleware(rootReducer)</span><br><span class="line"></span><br><span class="line">sagaMiddleware.run(rootSaga)</span><br><span class="line"></span><br><span class="line">const action &#x3D; type &#x3D;&gt; store.dispatch(&#123; type &#125;)</span><br><span class="line"></span><br><span class="line">function render() &#123;</span><br><span class="line">  ReactDOM.render(</span><br><span class="line">    &lt;Counter</span><br><span class="line">      value&#x3D;&#123;store.getState()&#125;</span><br><span class="line">      onIncrement&#x3D;&#123;() &#x3D;&gt; action(&#39;INCREMENT&#39;)&#125;</span><br><span class="line">      onDecrement&#x3D;&#123;() &#x3D;&gt; action(&#39;DECREMENT&#39;)&#125;</span><br><span class="line">      onIncrementAsync&#x3D;&#123;() &#x3D;&gt; action(&#39;INCREMENT_ASYNC&#39;)&#125; &#x2F;&gt;,</span><br><span class="line">    document.getElementById(&#39;root&#39;)</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">render()</span><br><span class="line"></span><br><span class="line">store.subscribe(render)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><strong>sagas.js</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">import &#123; put, call, take,fork &#125; from &#39;redux-saga&#x2F;effects&#39;;</span><br><span class="line">import &#123; takeEvery, takeLatest &#125; from &#39;redux-saga&#39;</span><br><span class="line"></span><br><span class="line">export const delay &#x3D; ms &#x3D;&gt; new Promise(resolve &#x3D;&gt; setTimeout(resolve, ms));</span><br><span class="line"></span><br><span class="line">function* incrementAsync() &#123;</span><br><span class="line">  &#x2F;&#x2F; 延迟 1s 在执行 + 1操作</span><br><span class="line">  yield call(delay, 1000);</span><br><span class="line">  yield put(&#123; type: &#39;INCREMENT&#39; &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default function* rootSaga() &#123;</span><br><span class="line">  &#x2F;&#x2F; while(true)&#123;</span><br><span class="line">  &#x2F;&#x2F;   yield take(&#39;INCREMENT_ASYNC&#39;);</span><br><span class="line">  &#x2F;&#x2F;   yield fork(incrementAsync);</span><br><span class="line">  &#x2F;&#x2F; &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 下面的写法与上面的写法上等效</span><br><span class="line">  yield* takeEvery(&quot;INCREMENT_ASYNC&quot;, incrementAsync)</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><strong>reducer.js</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">export default function counter(state &#x3D; 0, action) &#123;</span><br><span class="line">  switch (action.type) &#123;</span><br><span class="line">    case &#39;INCREMENT&#39;:</span><br><span class="line">      return state + 1</span><br><span class="line">    case &#39;DECREMENT&#39;:</span><br><span class="line">      return state - 1</span><br><span class="line">    case &#39;INCREMENT_ASYNC&#39;:</span><br><span class="line">      return state</span><br><span class="line">    default:</span><br><span class="line">      return state</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>从上面的代码结构可以看出，redux-saga的使用方式还是比较简单的，相比较之前的redux框架的CounterApp，多了一个sagas的文件，reducers文件还是之前的使用方式</p><h3 id="redux-saga基本用法总结："><a href="#redux-saga基本用法总结：" class="headerlink" title="redux-saga基本用法总结："></a>redux-saga基本用法总结：</h3><ol><li><strong>使用 createSagaMiddleware 方法创建 saga 的 Middleware ，然后在创建的 redux 的 store 时，使用 applyMiddleware 函数将创建的 saga Middleware 实例绑定到 store 上，最后可以调用 saga Middleware 的 run 函数来执行某个或者某些 Middleware 。</strong></li><li><strong>在 saga 的 Middleware 中，可以使用 takeEvery 或者 takeLatest 等 API 来监听某个 action ，当某个 action 触发后， saga 可以使用 call 发起异步操作，操作完成后使用 put 函数触发 action ，同步更新 state ，从而完成整个 State 的更新。</strong></li></ol><hr><p>ok,故事到这里就接近尾声了，以上主要介绍了redux,react-redux和redux-saga目前redux全家桶主流的一些产品,接下来,主要会产出一下根据源码,<strong>手写一下redux和react-redux的轮子</strong></p>]]></content>
      
      
      <categories>
          
          <category> web前端 </category>
          
          <category> redux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web前端 </tag>
            
            <tag> redux </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
